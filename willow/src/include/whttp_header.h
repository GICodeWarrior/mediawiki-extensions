/* @(#) $Id$ */
/* This source code is in the public domain. */
/*
 * Willow: Lightweight HTTP reverse-proxy.
 * whttp_header: header processing implementation.
 */

#ifndef WHTTP_HEADER
#define WHTTP_HEADER

#if defined __SUNPRO_C || defined __DECC || defined __HP_cc
# pragma ident "@(#)$Id$"
#endif

#include "config.h"
#include "whttp.h"
#include "willow.h"
#include "wnet.h"
#include "flowio.h"

/*
 * Do NOT change these values, they are used in the UDP
 * log packets.
 */
#define REQTYPE_GET	0
#define REQTYPE_POST	1
#define REQTYPE_HEAD	2
#define REQTYPE_TRACE	3
#define REQTYPE_OPTIONS	4
#define REQTYPE_INVALID	-1

extern struct request_type {
	const char *name;
	int len;
	int type;
} supported_reqtypes[];

struct header : freelist_allocator<header> {
	header(ptstring const &, ptstring const &);
	~header() {}

	void	swap(header &);

	ptstring	 hr_name;
	ptstring	 hr_value;
};

struct header_list {
	header_list();
	~header_list() {};

	void	 add		(ptstring const &, ptstring const &);
	void	 add		(char const *, char const *);
	void	 add		(char const *, size_t, char const *, size_t);
	void	 append_last	(const char *, size_t);
	char	*build		(void);
	void	 remove		(const char *);
	void	 dump		(int);
	int	 undump		(int, off_t *);
struct header	*find		(const char *name);

	header			*hl_last;
	vector<header, pt_allocator<header> >	 hl_hdrs;
	int			 hl_len;
};

struct qvalue {
	float	 val;
const	char	*name;

	bool operator< (qvalue const &rhs) const {
		return val < rhs.val;
	}
};

/*
 * header_spigot: output an HTTP response built from a pre-defined list
 * of headers.  used for responses generated by us.
 */
struct header_spigot : io::spigot
{
	header_spigot(int, char const *);

	void	add		(char const *, char const *);
	void	body		(string const &);
	void	body		(string &);
	void	sp_uncork	(void);
	void	sp_cork		(void);

private:
	header_list	_headers;
	bool		_built;
	string		_first;
	string		_body;
	wnet::buffer	_buf;
	bool		_corked;
};

/*
 * header_parser: parse and store headers.  This is both a sink (for
 * reading headers and parsing them) and a spigot (for sending headers
 * to a backend or client).
 */
struct header_parser : io::sink, io::spigot
{
	header_parser() 
		: _got_reqtype(false)
		, _built(false)
		, _corked(true)
		, _is_response(false)
		, _content_length(-1)
		, _response(0)
		, _is_msie(false)
		, _http_reqtype(REQTYPE_INVALID)
		{
			_flags.f_chunked = 0;
	}

	io::sink_result	data_ready		(char const *buf, size_t len, ssize_t&);
	io::sink_result	data_empty		(void);

	int		parse_reqtype		(char const *buf, char const *endp);
	int		parse_response		(char const *buf, char const *endp);
	void		completed_callback	(void);
	void		error_callback		(void);
	void		sp_cork			(void);
	void		sp_uncork		(void);
	void 		set_response		(void);

	static inline char const *find_rn(char const *buf, char const *end) {
	char const	*s;
		for (s = buf; s < end; s += 2) {
			if (*s != '\r' && *s != '\n')
				continue;
			if (s + 1 < end && s[0] == '\r' && s[1] == '\n')
				return s;
			if (s > buf && s[-1] == '\r' && s[0] == '\n')
				return s - 1;
		}
		return NULL;
	}

	polycaller<>	 _completed_callee;
	polycaller<>	 _error_callee;
	header_list	 _headers;
	bool		 _got_reqtype;
	http_version	 _http_vers;
	string		 _http_path;
	bool		 _built;
	bool		 _corked;
	bool		 _is_response;
	ssize_t		 _content_length;
	int		 _response;
	bool		 _is_msie;
	int		 _http_reqtype;
	string		 _http_host;
	string		 _http_backend;
	wnet::buffer	 _buf;

	struct {
		unsigned int	f_chunked:1;
	}		 _flags;
};

#endif
