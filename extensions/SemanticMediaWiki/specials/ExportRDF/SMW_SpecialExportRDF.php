<?php
/**
 * @author Markus KrÃ¶tzsch
 *
 * This special page for MediaWiki implements an RDF-export of
 * semantic data, gathered both from the annotations in articles,
 * and from metadata already present in the database.
 */

if (!defined('MEDIAWIKI')) die();

require_once($smwgIP . '/includes/SMW_Storage.php');
require_once( "$IP/includes/SpecialPage.php" );

$wgExtensionFunctions[] = "wfExportRDFExtension";

function wfExportRDFExtension()
{
	smwfInitMessages(); // initialize messages, always called before anything else on this page
	SpecialPage::addPage( new SpecialPage('ExportRDF','',true,'doSpecialExportRDF',false) );
}


function doSpecialExportRDF($page = '')
{
	global $wgOut, $wgRequest, $wgUser, $smwgAllowRecursiveExport, $smwgExportBacklinks;
	
	$recursive = 0;  //default, no recursion
	$backlinks = $smwgExportBacklinks; //default
	
	// check whether we already know what to export //
	
	if ($page=='') { //try to get GET parameter; simple way of calling the export
		$page = $wgRequest->getVal( 'page' );
	}

	if ($page=='') { //try to get POST list; some settings are only available via POST
		$pageblob = $wgRequest->getText( 'pages' );
		if ('' != $pageblob) {
			$pages = explode( "\n", $pageblob );
		}
	} else {
		$pages = array($page);
	}
	
	if( isset($pages) ) {  // export to RDF
		$wgOut->disable();
		ob_start();

		// Only use rdf+xml mimetype if explicitly requested
		// TODO: should the see also links in the exported RDF then have this parameter as well?
		if ( $wgRequest->getVal( 'xmlmime' )=='rdf' ) { 
			header( "Content-type: application/rdf+xml; charset=UTF-8" );
		} else {
			header( "Content-type: application/xml; charset=UTF-8" );
		}

		if ( $wgRequest->getText( 'postform' ) == 1 ) {
			$postform = true; //effect: assume "no" from missing parameters generated by checkboxes
		} else $postform = false;

		$rec = $wgRequest->getText( 'recursive' );
		if ('' == $rec) $rec = $wgRequest->getVal( 'recursive' );
		if ( ($rec == '1') && ($smwgAllowRecursiveExport || $wgUser->isAllowed('delete')) ) {
			$recursive = 1; //users may be allowed to switch it on
		}
		$bl = $wgRequest->getText( 'backlinks' );
		if ('' == $bl) $bl = $wgRequest->getVal( 'backlinks' );
		if (($bl == '1') && ($wgUser->isAllowed('delete'))) {
			$backlinks = true; //admins can always switch on backlinks
		} elseif ( ($bl == '0') || ( '' == $bl && $postform) ) {
			$backlinks = false; //everybody can explicitly switch off backlinks
		}

		$exRDF = new ExportRDF();
		$exRDF->printPages($pages,$recursive,$backlinks);
		return;
	}

	// nothing exported yet; show user interface:
	$html = '<form name="tripleSearch" action="" method="POST">' . "\n" .
	        wfMsg('smw_exportrdf_docu') . "\n" .
	        '<input type="hidden" name="postform" value="1"/>' . "\n" .
	        '<textarea name="pages" cols="40" rows="10"></textarea><br />' . "\n";
	if ( $wgUser->isAllowed('delete') || $smwgAllowRecursiveExport) {
		$html .= '<input type="checkbox" name="recursive" value="1" id="rec">&nbsp;<label for="rec">' . wfMsg('smw_exportrdf_recursive') . '</label></input><br />' . "\n";
	}
	if ( $wgUser->isAllowed('delete') || $smwgExportBacklinks) {
		$html .= '<input type="checkbox" name="backlinks" value="1" default="true" id="bl">&nbsp;<label for="bl">' . wfMsg('smw_exportrdf_backlinks') . '</label></input><br />' . "\n";
	}
	$html .= "<br /><input type=\"submit\"/>\n</form>";
	$wgOut->addHTML($html);
}





class ExportRDF
{
	/**#@+
	 * @access private
	 */

	/**
	 * The basic namespace for acrticles in this wiki (computed on creation).
	 * Version suitable for URLs.
	 */
	var $wiki_xmlns_url;

	/**
	 * The basic namespace for acrticles in this wiki (computed on creation).
	 * Version suitable for XML identifiers.
	 */
	var $wiki_xmlns_xml;

	/**
	 * An array that keeps track of the elements for which we still need to
	 * write auxilliary definitions.
	 */
	var $element_queue;

	/**
	 * URL of this special page
	 */
	var $special_url;

	/**
	 * Database handler -- needed multiple times, so "cache" it
	 */
	var $db;

	/**
	 * Array of additional namespaces (abbreviation => URI), flushed on
	 * closing the current namespace tag. Since we export RDF in a streamed
	 * way, it is not always possible to embed additional namespaces into
	 * the RDF-tag which might have been sent to the client already. But we
	 * wait with printing the current Description so that extra namespaces
	 * from this array can still be printed (note that you never know which
	 * extra namespaces you encounter during export).
	 */
	var $extra_namespaces;

	/**
	 * Array of namespaces that have been declared globally already. Contains
	 * entries of format 'namespace abbreviation' => true, assuming that the 
	 * same abbreviation always refers to the same URI (i.e. you cannot import
	 * something as rdf:bla if you do not want rdf to be the standard 
	 * namespace that is already given in every RDF export).
	 */
	var $global_namespaces;

	/**
	 * Unprinted XML is composed from the strings $pre_ns_buffer and $post_ns_buffer.
	 * The split between the two is such that one can append additional namespace 
	 * declarations to $pre_ns_buffer so that they affect all current elements. The
	 * buffers are flushed during output in order to achieve "streaming" RDF export
	 * for larger files.
	 */
	var $pre_ns_buffer;

	/**
	 * See documentation for ExportRDF::pre_ns_buffer.
	 */
	var $post_ns_buffer;

	/**
	 * Boolean that is true as long as nothing was flushed yet. Indicates that
	 * extra namespaces can still become global.
	 */
	var $first_flush;

	/**
	 * Integer that counts down the number of objects we still process before 
	 * doing the first flush. Aggregating some output before flushing is useful
	 * to get more namespaces global. Flushing will only happen if $delay_flush
	 * is 0.
	 */
	var $delay_flush;

	function ExportRDF()
	{
		global $smwgServer; // server address for URIs (without http://)
		global $wgServer;   // actual server address (with http://)
		global $wgScript;   // "/subdirectory/of/wiki/index.php"
		//@TODO: generate this properly, using $wgArticlePath
		$this->wiki_xmlns_url = $wgServer . $wgScript . '/';
		$this->wiki_xmlns_xml = 'http://' . $this->makeXMLExportId($smwgServer . $wgScript) . '/';

		$title = Title::makeTitle( NS_SPECIAL, 'ExportRDF' );
		$this->special_url = '&wikiurl;' . $title->getPrefixedURL();

		$this->element_queue = Array();
	}

	/**
	 * This function prints all selected pages. The parameter $recursion determines
	 * how referenced ressources are treated:
	 * '0' : add brief declarations for each
	 * '1' : add full descriptions for each, thus beginning real recursion (and 
	 *       probably retrieving the whole wiki ...)
	 * else: ignore them, though -1 might become a synonym for "export *all*" in the future
	 * The parameter $backlinks determines whether or not subjects of incoming 
	 * properties are exported as well. Enables "browsable RDF."
	 */
	function printPages($pages,$recursion=1,$backlinks=true) {
		$this->db = & wfGetDB( DB_MASTER );
		$this->pre_ns_buffer = '';
		$this->post_ns_buffer = '';
		$this->first_flush = true;
		$this->delay_flush = 10; //flush only after (fully) printing 11 objects
		$this->extra_namespaces = array();
		// $this->global_namespaces = array(); -> initialised when printing header
		$this->printHeader();

		while (count($pages)>0) {
			// first, print all selected pages
			foreach ( $pages as $page) {
				$title = Title::newFromText($page);
				if (NULL === $title) continue; //invalid title name given
				$this->printTriples($title);
				// add backlinks to element queue
				if ($backlinks===true) {
					extract($this->db->tableNames( 'smw_attributes','smw_relations','smw_specialprops' ));
					$res = $this->db->query(
					    "SELECT DISTINCT subject_id FROM $smw_relations 
					     WHERE object_title=" . $this->db->addQuotes($title->getDBKey()), 
					     'SMW::printPages');
					if($this->db->numRows( $res ) > 0) {
						$row = $this->db->fetchObject($res);
						while($row) {
							$subject_title = Title::newfromID($row->subject_id);
							if (NULL!==$subject_title) {
								$suris = $this->getURIsFromTitle($subject_title);
								if ((!array_key_exists($suris[2],$this->element_queue))||
								    ($this->element_queue[$suris[2]]!=false)) {
									//$this->element_queue[$suris[2]] = true;
									//if ($this->element_queue[$suris[2]]!=false)
										$this->printTriples($subject_title);
								}
							}
							$row = $this->db->fetchObject($res);
						}
					}
				}
				if ($this->delay_flush > 0) $this->delay_flush--;
			}
			// then look for related pages that were encountered
			$pages = array();
			if (1 == $recursion) {
				foreach ( $this->element_queue as $page => $open ) {
					if ($open) {
						$pages[] = $page;
						$this->element_queue[$page] = false; // prevent loops even if this code is buggy
					}
				}
			}
		}

		// if pages are not processed recursively, at least print the declarations
		// of related pages
		if (0 == $recursion) {
			if ( '' != $this->pre_ns_buffer ) {
				$this->post_ns_buffer .= "\t<!-- auxilliary definitions -->\n";
			} else {
				print "\t<!-- auxilliary definitions -->\n"; // just print this comment, so that later outputs still find the empty pre_ns_buffer!
			}
			foreach ( $this->element_queue as $page => $open ) {
				if ($open) {
					$title = Title::newFromText($page);	
					$this->printTriples($title,false);
				}
			}
		}

		$this->printFooter();
		$this->flushBuffers(true);
	}
	
	/* Functions for exporting RDF */

	function printHeader() {
		global $wgContLang;
		
		$this->pre_ns_buffer .=
			"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" .
			"<!DOCTYPE rdf:RDF[\n" .
			"\t<!ENTITY rdf 'http://www.w3.org/1999/02/22-rdf-syntax-ns#'>\n" .
			"\t<!ENTITY rdfs 'http://www.w3.org/2000/01/rdf-schema#'>\n" .
			"\t<!ENTITY owl 'http://www.w3.org/2002/07/owl#'>\n" .
			"\t<!ENTITY smw 'http://smw.ontoware.org/2005/smw#'>\n" .
			"\t<!ENTITY smwdt 'http://smw.ontoware.org/2005/smw-datatype#'>\n" .
			"\t<!ENTITY wiki '" . $this->wiki_xmlns_xml .  "'>\n" .
			"\t<!ENTITY thing '" . $this->wiki_xmlns_xml . '_' .  "'>\n" .
			"\t<!ENTITY relation '" . $this->wiki_xmlns_xml . '_' .
			$this->makeXMLExportId(urlencode(str_replace(' ', '_', $wgContLang->getNsText(SMW_NS_RELATION) . ':'))) .  "'>\n" .
			"\t<!ENTITY attribute '" . $this->wiki_xmlns_xml . '_' . 
			$this->makeXMLExportId(urlencode(str_replace(' ', '_', $wgContLang->getNsText(SMW_NS_ATTRIBUTE) . ':'))) .  "'>\n" .
			"\t<!ENTITY wikiurl '" . $this->wiki_xmlns_url .  "'>\n" .
			"]>\n\n" .
			"<rdf:RDF\n" .
			"\txmlns:rdf=\"&rdf;\"\n" .
			"\txmlns:rdfs=\"&rdfs;\"\n" .
			"\txmlns:owl =\"&owl;\"\n" .
			"\txmlns:smw=\"&smw;\"\n" .
			"\txmlns:wiki=\"&wiki;\"\n" .
			"\txmlns:thing=\"&thing;\"\n" .
			"\txmlns:relation=\"&relation;\"\n" .
			"\txmlns:attribute=\"&attribute;\"";
		$this->global_namespaces = array('rdf'=>true, 'rdfs'=>true, 'owl'=>true, 'smw'=>true, 'wiki'=>true, 'thing'=>true, 'relation'=>true, 'attribute'=>true);

		$this->post_ns_buffer .=
			">\n\t<!-- reference to the Semantic MediaWiki schema -->\n" .
			"\t<owl:AnnotationProperty rdf:about=\"&smw;hasArticle\">\n" .
			"\t\t<rdfs:isDefinedBy rdf:resource=\"http://smw.ontoware.org/2005/smw\"/>\n" .
			"\t</owl:AnnotationProperty>\n" .
			"\t<owl:AnnotationProperty rdf:about=\"&smw;hastype\">\n" .
			"\t\t<rdfs:isDefinedBy rdf:resource=\"http://smw.ontoware.org/2005/smw\"/>\n" .
			"\t</owl:AnnotationProperty>\n" .
			"\t<owl:Class rdf:about=\"&smw;Thing\">\n" .
			"\t\t<rdfs:isDefinedBy rdf:resource=\"http://smw.ontoware.org/2005/smw\"/>\n" .
			"\t</owl:Class>\n" .
			"\t<!-- exported page data -->\n";
	}

	function printFooter() {
		$this->post_ns_buffer .= '</rdf:RDF>';
	}
	
	function printTriples($title, $fullexport=true) {
		if ($title === NULL) { return; } //this should not happen ...
		
		//// == normalize title text ==
		// This deserves some explanation: we process the given page name via
		// a title object since this eliminates acceptable discrepancies in 
		// the user input. However, we have to recover the fragment part as
		// well since we use fragments to encode units for attributes, which
		// is required especially when calling this method recursively. For the
		// recursive case, the normlization step is not required, since it was 
		// already performed in getURIs. However, we need the title for our
		// database access anyway, and thus we do not loose much. It might be
		// questionable whether the normalization of the fragement part is 
		// actually desirable, since it is normally different from the unit string
		// that the datatype object returns for storing in the internal database.
		// Maybe we should do a title-normalization of the internal unit strings
		// when storing them.
		
		$pageURIs = $this->getURIsFromTitle($title);
		$pageID = $title->getArticleID();
		
		$subrel_rel = false;
		$datatype_rel = false;
		$subatt_rel = false;
		$category_rel = false;
		$equality_rel = false;
		
		switch ($title->getNamespace()) {
			case SMW_NS_RELATION:
				$type = 'owl:ObjectProperty';
				$equality_rel = "owl:equivalentProperty";
				$subrel_rel = "rdfs:subPropertyOf";
				break;
			case SMW_NS_ATTRIBUTE:
				$datatypes = smwfGetSpecialProperties($title,SMW_SP_HAS_TYPE,NULL);
				if (0 == count($datatypes)) return; //Attribute without type not exportable
				$datatype_handler = SMWTypeHandlerFactory::getTypeHandlerByLabel($datatypes[0][2]);
				if (count($datatypes) != 0) {
					if ( ('annouri' == $datatype_handler->getID()) || ('annostring' == $datatype_handler->getID()) ) {
						$type = 'owl:AnnotationProperty'; // cannot be a subproperty, etc.
					} else {
						if ('' != $datatype_handler->getXSDType()) {
							$type = 'owl:DatatypeProperty';
						} else { // no xsd-type -> treat as object property
							$type = 'owl:ObjectProperty';
						}
						$equality_rel = "owl:equivalentProperty";
						$subatt_rel = "rdfs:subPropertyOf";
					}
				}
				break;
			case NS_CATEGORY:
				$type = 'owl:Class';
				$category_rel = "rdfs:subClassOf";
				$equality_rel = "owl:equivalentClass";
				break;
			default:
				$type = 'smw:Thing';
				$category_rel = "rdf:type";
				$equality_rel = "owl:sameAs";
				break;
		}

		if ('' == $this->pre_ns_buffer) { // start new ns block
			$this->pre_ns_buffer .= "\t<$type rdf:about=\"" . $pageURIs[0] . "\"";
		} else {
			$this->post_ns_buffer .= "\t<$type rdf:about=\"" . $pageURIs[0] . "\"";
		}
		$this->post_ns_buffer .= ">\n" .
		      "\t\t<rdfs:label>" . str_replace('&','&amp;',$pageURIs[2]) . "</rdfs:label>\n" .
		      "\t\t<smw:hasArticle rdf:resource=\"&wikiurl;" .
		              $title->getPrefixedURL() . "\"/>\n" .
		      "\t\t<rdfs:isDefinedBy rdf:resource=\"" .
		              $this->special_url . '/' . $title->getPrefixedURL() . "\"/>\n";

		if ($fullexport) {
			$this->element_queue[$pageURIs[2]] = false; //do not process this element again
			
			// add statements about categories
			if ($category_rel) {
				$dbr =& wfGetDB( DB_MASTER );
				$res = $dbr->query( "SELECT cl_to FROM " . $dbr->tableName('categorylinks') . " WHERE cl_from=$pageID", "SMW::ExportRDF");
				
				if($dbr->numRows( $res ) > 0) {
					$row = $dbr->fetchObject($res);
					while($row) {
						//foreach ($catlinks as $catlink) {
						$catURIs = $this->getURIs($row->cl_to, NS_CATEGORY);

						$this->post_ns_buffer .= "\t\t<" . $category_rel . ' rdf:resource="' . $catURIs[0] .  "\"/>\n";
						
						if (!array_key_exists($catURIs[2], $this->element_queue)) {
							$this->element_queue[$catURIs[2]] = true;
						}
						$row = $dbr->fetchObject($res);
					}
				}
			}
			
			// add statements about equivalence to (external) URIs
			if ($equality_rel) {
				$equalities = smwfGetSpecialProperties($title,SMW_SP_HAS_URI,NULL);
				$fragment = $title->getFragment();
				if( '' != $fragment ) {
					$fragment = '#' . $fragment;
				}
				foreach ($equalities as $equality) {
					$this->post_ns_buffer .= "\t\t<" . $equality_rel . ' rdf:resource="' . $equality[2] . $fragment .  "\"/>\n";
				}
			}
			
			// add rdf:type statements
			if (isset($datatype_handler)) {
				$this->post_ns_buffer .= "\t\t<smw:hasType " . 'rdf:resource="&smwdt;' . $datatype_handler->getID() . "\"/>\n";
			}
			
			// add rdfs:subPropertyOf statements
			if ($subrel_rel) {
				$relations = smwfGetSpecialProperties($title,SMW_SP_IS_SUBRELATION_OF,NULL);
				foreach ($relations as $relation) {
					$relURIs = $this->getURIs($relation[2],0);
					//@TODO: do type checks here or on saving ...
					$this->post_ns_buffer .= "\t\t<$subrel_rel rdf:resource=\"$relURIs[0]\"/>\n";
					if (!array_key_exists($relURIs[2], $this->element_queue)) {
							$this->element_queue[$relURIs[2]] = true;
					}
				}
			}
			if ($subatt_rel) {
				$attributes = smwfGetSpecialProperties($title,SMW_SP_IS_SUBRELATION_OF,NULL);
				foreach ($attributes as $attribute) {
					$attURIs = $this->getURIs($attribute[2],0);
					//@TODO: do type checks here or on saving ...
					$this->post_ns_buffer .= "\t\t<$subatt_rel rdf:resource=\"$attURIs[0]\"/>\n";
					if (!array_key_exists($attURIs[2], $this->element_queue)) {
							$this->element_queue[$attURIs[2]] = true;
					}
				}
			}
			
			//print all relations and attributes
			$as=smwfGetRelations($title,NULL,NULL);
			if ($as!==false && count($as)>0) {
				foreach($as as $a) {
					$this->processRelation($a);
				}
			}
			$as=smwfGetAttributes($title,NULL,NULL,NULL,NULL);
			if ($as!==false && count($as)>0) {
				foreach($as as $a) {
					$this->processAttribute($a);
				}
			}
		}
		
		$this->post_ns_buffer .= "\t</" . $type . ">\n";
		$this->flushBuffers();
	}

	/**
	 * Flush all buffers and extra namespaces by printing them to stdout and flushing
	 * the output buffers afterwards.
	 *
	 * @param force if true, the flush cannot be delayed any longer
	 */
	function flushBuffers($force = false) {
		if ( '' == $this->post_ns_buffer ) return; // nothing to flush (every non-empty pre_ns_buffer also requires a non-empty post_ns_buffer)
		if ( (0 != $this->delay_flush) && !$force ) return; // wait a little longer

		print $this->pre_ns_buffer;
		$this->pre_ns_buffer = '';
		foreach ($this->extra_namespaces as $nsshort => $nsuri) {
			if ($this->first_flush) {
				$this->global_namespaces[$nsshort] = true;
				print "\n\t";
			} else print ' ';
			print "xmlns:$nsshort=\"$nsuri\"";
		}
		$this->extra_namespaces = array();
		print $this->post_ns_buffer;
		$this->post_ns_buffer = '';
		// Ship data in small chunks (even though browsers often do not display anything
		// before the file is complete -- this might be due to sysntax highlighting features
		// for app/xml). You may want to sleep(1) here for debugging this.
		ob_flush();
		flush();
		$this->first_flush = false;
	}

	/**
	 * Add an extra namespace that was encountered during output. The method
	 * checks whether the required namespace is available globally and adds
	 * it to the list of extra_namesapce otherwise.
	 */
	function addExtraNamespace($nsshort,$nsuri) {
		if (!array_key_exists($nsshort,$this->global_namespaces)) {
			$this->extra_namespaces[$nsshort] = $nsuri;
		}
	}

	/**
	 * Print the RDF for some object property (relation) statement, 
	 * given as an array.
	 */
	function processRelation($rel) {
		$relURIs = $this->getURIs($rel[1],SMW_NS_RELATION);
		$objURIs = $this->getURIs($rel[3],$rel[2]);

		$this->post_ns_buffer .= "\t\t<" . $relURIs[1] . ' rdf:resource="' . $objURIs[0] .  "\"/>\n";

		if (!array_key_exists($relURIs[2], $this->element_queue)) {
			$this->element_queue[$relURIs[2]] = true;
		}
		if (!array_key_exists($objURIs[2], $this->element_queue)) {
			$this->element_queue[$objURIs[2]] = true;
		}
		return;
	}

	/**
	 * Print the RDF for some data property (attribute) statement,
	 * given as an array.
	 */
	function processAttribute($att) {
		if ( $att[2] != '' ) {
			$attlabel = $att[1] . '#' . $att[2];
		} else {
			$attlabel = $att[1];
		}
		$attURIs = $this->getURIs($attlabel,SMW_NS_ATTRIBUTE);

		$xsdtype = SMWTypeHandlerFactory::getXSDTypeByID($att[3]);
		if ( ($xsdtype !== '') && ($xsdtype !== NULL) ) {
			$this->post_ns_buffer .= "\t\t<" . $attURIs[1] . ' rdf:datatype="' . $xsdtype .  '">' . $att[4] . '</' . $attURIs[1] . ">\n";
		} elseif ($xsdtype === '') { // no xsd-type -> export as object property
			$this->post_ns_buffer .= "\t\t<" . $attURIs[1] . ' rdf:resource="' . $att[4] .  "\"/>\n";
		} else {
			$this->post_ns_buffer .= "<!-- Sorry, type '$att[3]' of attribute '$attlabel' could not be resolved to XSD. Probably an upgrade issue. Try saving the respective article again. -->";
		}

		$attname = $attURIs[2];
		if (!array_key_exists($attURIs[2], $this->element_queue)) {
			$this->element_queue[$attURIs[2]] = true;
		}
		return;
	}

	/** Create full and abbreviated URIs for XML export. The inputs are
	 * $text -- standard text form of the main part of the article name 
	 *          (no namespace, no urlencode)
	 * $namespace -- the namespace constant
	 * 
	 * Returns an array with three entries: the full (0) and the abbreviated
	 * (1) XML URI, and the human readable prefixed text version (2)
	 */
	function getURIs($text, $namespace) {
		$title = Title::newFromText($text, $namespace);
		if ($title === NULL) {
			$this->post_ns_buffer .= "<!-- Error: \"$nstext$text\" is not a valid article. -->\n";
			return array("","",""); // returning this to an unprepared caller is not elegant, but better than crashing; the situation only can occur when the semantic tables are inconsistent with the wiki
		}
		
		return $this->getURIsFromTitle($title);
	}

	/**
	 * Like getURIs, but with different input. Expects a non-NULL title.
	 */
	function getURIsFromTitle($title) {
		global $wgContLang;
		$result = Array();

		$ns_text = $wgContLang->getNsText($title->getNamespace());
		if ($ns_text!='') {
			$ns_text .= ':';
			$ns_uri = $this->makeXMLExportId(urlencode(str_replace(' ', '_', $ns_text)));
		} else {
			$ns_uri = '';
		}

		$text = $title->getText(); //normalize title text
		$fragment = $title->getFragment();
		if( '' != $fragment ) {
			$text .= '#' . $fragment;
		}

		$uris = smwfGetSpecialProperties($title,SMW_SP_EXT_BASEURI,NULL);
		if (count($uris)>0) {
			$nsuri = $uris[0][2];
			$uris = smwfGetSpecialProperties($title,SMW_SP_EXT_NSID,NULL);
			$nsshort = $uris[0][2];
			$uris = smwfGetSpecialProperties($title,SMW_SP_EXT_SECTION,NULL);
			$result[0] = $nsuri . $uris[0][2];
			$result[1] = $nsshort . ':' . $uris[0][2];
			$this->addExtraNamespace($nsshort,$nsuri);
		} else {
			$baseXML = $this->makeXMLExportId(urlencode(str_replace(' ', '_', $text)));

			switch ($title->getNamespace()) {
				case SMW_NS_RELATION:
					$xmlprefix = 'relation:';
					$xmlent = '&relation;';
					break;
				case SMW_NS_ATTRIBUTE:
					$xmlprefix = 'attribute:';
					$xmlent = '&attribute;';
					break;
				default:
					$xmlprefix = 'thing:';
					$xmlent = '&thing;';
					$baseXML = $ns_uri . $baseXML;
					$ns_uri = '';
					break;
			}

			//$result[] = $this->wiki_xmlns_xml . '_' . $ns_uri . $baseXML;
			$result[0] = $xmlent . $baseXML;
			if (mb_substr($baseXML,0,1)=='-') {
				$result[1] = 'wiki:_' . $ns_uri . $baseXML;
			} else {
				$result[1] = $xmlprefix . $baseXML;
			}
		}

		$result[2] = $ns_text . $text;

		return $result;
	}
	
	/** This function transforms a valid url-encoded URI into a string
	 *  that can be used as an XML-ID. The mapping should be injective.
	 */
	function makeXMLExportId($uri) {
		$uri = str_replace( '-', '-2D', $uri);
		//$uri = str_replace( ':', '-3A', $uri); //already done by PHP
		//$uri = str_replace( '_', '-5F', $uri); //not necessary
		$uri = str_replace( array('"','#','&',"'",'+','%'), 
		                    array('-22','-23','-26','-27','-2B','-'), 
		                    $uri);
		return $uri;
	}
}
?>
