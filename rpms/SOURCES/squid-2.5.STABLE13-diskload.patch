# 
# 
# add_file "doc/README.diskload"
#  content [a508e639e8882f32ac170fb695a3550052212abe]
# 
# patch "src/enums.h"
#  from [d3225c7b17f9312bef8509d7dd1284df1f0fcf98]
#    to [955437e924a040325c5940579961596c655549ca]
# 
# patch "src/fs/aufs/store_dir_aufs.c"
#  from [99f2f1eebf5dd0b8e29deb65369dcd0c44bb0cd6]
#    to [434e3a5f048cd6111395e88fb1397144b4f2cc14]
# 
# patch "src/fs/coss/store_dir_coss.c"
#  from [19d4f9ab9f40836bd89d4b34d6a707fb07315f80]
#    to [371e6c070f6001f5e22de7286ec60b880529ff4b]
# 
# patch "src/fs/diskd/store_dir_diskd.c"
#  from [b338483de8d86584e890188328fb92711677fc7f]
#    to [29790dc96bd0f60cad3f36d201be8a32655cf28d]
# 
# patch "src/fs/null/store_null.c"
#  from [fa5f237c80376f490212dc9b5431584958991925]
#    to [eda38ac409bcb678d4d853ce97e8eecb25ee57e7]
# 
# patch "src/fs/ufs/store_dir_ufs.c"
#  from [4793d2c314a1b2a0085408592b65bb858ab30058]
#    to [7fea6eabaa15ef88ff1cbbc3b2a8f95da3419aa6]
# 
# patch "src/store_dir.c"
#  from [e795049d82fdee67d27f34a53aed344c9c60f488]
#    to [299ef0c831c2b8f781cfe9992ca0912e5baa5792]
# 
# patch "src/store_io.c"
#  from [b3189954bb7b33712f066ccf62783d2b0506f710]
#    to [8a31eb00c0678314dbf38b0fa41d2bbd3f96f3b9]
# 
# patch "src/structs.h"
#  from [09fd7df0ee0cc66a8be6be822cf34b2203aac563]
#    to [2cc0257c851aa9f3899204538a4037888a0465cf]
# 
# patch "src/typedefs.h"
#  from [0a1930b4adf4cddddda7f44324e88fb53311162f]
#    to [af3aabd123fce77fbe2ce6bfc45c942e516c8640]
# 
============================================================
--- doc/README.diskload	a508e639e8882f32ac170fb695a3550052212abe
+++ doc/README.diskload	a508e639e8882f32ac170fb695a3550052212abe
@@ -0,0 +1,37 @@
+
+The disk load calculation code has been modified slightly - it now
+attempts to shed load during both periods of extraordinarily busy
+disk activity.
+
+Each filesystem implements slightly different semantics for knowing
+when its busy:
+
+* aufs: doesn't have a concept of 'per-storedir' IO as the thread
+  pool is shared between all aufs storedir; loadav is the number
+  of currently busy threads out of the number of maximum threads.
+
+* ufs: since it is synchronous the "busy" heuristic is simply the
+  number of currently open files in the storedir. This allows for
+  the usage of the storedirs to be relatively even but it doesn't
+  help manage disk load.
+
+* diskd: each storedir has its own SYSV SHM/MSG queue; so the load
+  average is calculated based on the number of currently queued
+  messages compared to magic1 and magic2.
+
+* coss: each coss storedir has its own async-io queue (currently
+  128 entries deep); load average the percentage of these in use
+
+* null: the cache is always busy.
+
+The main problem with this; Squid will invalidate cached objects
+if there's a problem swapping them in; so heavy disk load can cause
+both your hit rate to drop and your cache to start losing objects.
+
+This isn't easily solvable! We'd need to be able to compare what
+we've retrieved against what we have (kind of like an IMS) to see
+whether we've fetched something "fresher". If we have then we should
+invalidate what we have in the cache. If the object we've fetched is
+just as fresh as what we have in the cache then we should hold onto
+our cached object. This will require a little more thought.
+
============================================================
--- src/enums.h	d3225c7b17f9312bef8509d7dd1284df1f0fcf98
+++ src/enums.h	955437e924a040325c5940579961596c655549ca
@@ -744,4 +744,10 @@
 
 #endif
 
+typedef enum {
+	ST_OP_NONE,
+	ST_OP_OPEN,
+	ST_OP_CREATE
+} store_op_t;
+
 #endif /* SQUID_ENUMS_H */
============================================================
--- src/fs/aufs/store_dir_aufs.c	99f2f1eebf5dd0b8e29deb65369dcd0c44bb0cd6
+++ src/fs/aufs/store_dir_aufs.c	434e3a5f048cd6111395e88fb1397144b4f2cc14
@@ -106,6 +106,7 @@
 static STDUMP storeAufsDirDump;
 static STMAINTAINFS storeAufsDirMaintain;
 static STCHECKOBJ storeAufsDirCheckObj;
+static STCHECKLOADAV storeAufsDirCheckLoadAv;
 static STREFOBJ storeAufsDirRefObj;
 static STUNREFOBJ storeAufsDirUnrefObj;
 static QS rev_int_sort;
@@ -1591,26 +1592,23 @@
  * object is able to be stored on this filesystem. AUFS filesystems will
  * happily store anything as long as the LRU time isn't too small.
  */
-int
+char
 storeAufsDirCheckObj(SwapDir * SD, const StoreEntry * e)
 {
-    int loadav;
-    int ql;
+    return 1;
+}
 
-#if OLD_UNUSED_CODE
-    if (storeAufsDirExpiredReferenceAge(SD) < 300) {
-	debug(47, 3) ("storeAufsDirCheckObj: NO: LRU Age = %d\n",
-	    storeAufsDirExpiredReferenceAge(SD));
-	/* store_check_cachable_hist.no.lru_age_too_low++; */
-	return -1;
-    }
-#endif
-    ql = aioQueueSize();
-    if (ql == 0)
-	loadav = 0;
-    loadav = ql * 1000 / MAGIC1;
-    debug(47, 9) ("storeAufsDirCheckObj: load=%d\n", loadav);
-    return loadav;
+int
+storeAufsDirCheckLoadAv(SwapDir *SD, store_op_t op)
+{
+	int loadav, ql;
+
+	ql = aioQueueSize();
+	if (ql == 0) {
+		return 1;
+	}
+	loadav = ql * 1000 / MAGIC1;
+	return loadav;
 }
 
 /*
@@ -1896,6 +1894,7 @@
     sd->statfs = storeAufsDirStats;
     sd->maintainfs = storeAufsDirMaintain;
     sd->checkobj = storeAufsDirCheckObj;
+    sd->checkload = storeAufsDirCheckLoadAv;
     sd->refobj = storeAufsDirRefObj;
     sd->unrefobj = storeAufsDirUnrefObj;
     sd->callback = aioCheckCallbacks;
============================================================
--- src/fs/coss/store_dir_coss.c	19d4f9ab9f40836bd89d4b34d6a707fb07315f80
+++ src/fs/coss/store_dir_coss.c	371e6c070f6001f5e22de7286ec60b880529ff4b
@@ -691,17 +691,21 @@
  * not store everything. We don't check for maxobjsize here since its
  * done by the upper layers.
  */
-int
+char
 storeCossDirCheckObj(SwapDir * SD, const StoreEntry * e)
 {
-    CossInfo *cs = (CossInfo *) SD->fsdata;
-    int loadav;
-
     /* Check if the object is a special object, we can't cache these */
     if (EBIT_TEST(e->flags, ENTRY_SPECIAL))
-	return -1;
+	return 0;
+    return 1;
+}
 
-    /* Otherwise, we're ok */
+int
+storeCossDirCheckLoadAv(SwapDir *SD, store_op_t op)
+{
+    CossInfo *cs = (CossInfo *) SD->fsdata;
+    int loadav;
+
     /* Return load, cs->aq.aq_numpending out of MAX_ASYNCOP */
     loadav = cs->aq.aq_numpending * 1000 / MAX_ASYNCOP;
     return loadav;
@@ -780,6 +784,7 @@
     sd->statfs = storeCossDirStats;
     sd->maintainfs = NULL;
     sd->checkobj = storeCossDirCheckObj;
+    sd->checkload = storeCossDirCheckLoadAv;
     sd->refobj = NULL;		/* LRU is done in storeCossRead */
     sd->unrefobj = NULL;
     sd->callback = storeCossDirCallback;
============================================================
--- src/fs/diskd/store_dir_diskd.c	b338483de8d86584e890188328fb92711677fc7f
+++ src/fs/diskd/store_dir_diskd.c	29790dc96bd0f60cad3f36d201be8a32655cf28d
@@ -110,6 +110,7 @@
 static STDUMP storeDiskdDirDump;
 static STMAINTAINFS storeDiskdDirMaintain;
 static STCHECKOBJ storeDiskdDirCheckObj;
+static STCHECKLOADAV storeDiskdDirCheckLoadAv;
 static STREFOBJ storeDiskdDirRefObj;
 static STUNREFOBJ storeDiskdDirUnrefObj;
 static QS rev_int_sort;
@@ -1819,15 +1820,24 @@
  * object is able to be stored on this filesystem. DISKD filesystems will
  * happily store anything as long as the LRU time isn't too small.
  */
-int
+char
 storeDiskdDirCheckObj(SwapDir * SD, const StoreEntry * e)
 {
     diskdinfo_t *diskdinfo = SD->fsdata;
     /* Check the queue length */
     if (diskdinfo->away >= diskdinfo->magic1)
-	return -1;
+	return 0;
+    return 1;
+}
+
+int
+storeDiskdDirCheckLoadAv(SwapDir *SD, store_op_t op)
+{
+    diskdinfo_t *diskdinfo = SD->fsdata;
     /* Calculate the storedir load relative to magic2 on a scale of 0 .. 1000 */
     /* the parse function guarantees magic2 is positivie */
+    if (diskdinfo->away >= diskdinfo->magic1)
+	return -1;
     return diskdinfo->away * 1000 / diskdinfo->magic2;
 }
 
@@ -2199,6 +2209,7 @@
     sd->statfs = storeDiskdDirStats;
     sd->maintainfs = storeDiskdDirMaintain;
     sd->checkobj = storeDiskdDirCheckObj;
+    sd->checkload = storeDiskdDirCheckLoadAv;
     sd->refobj = storeDiskdDirRefObj;
     sd->unrefobj = storeDiskdDirUnrefObj;
     sd->callback = storeDiskdDirCallback;
============================================================
--- src/fs/null/store_null.c	fa5f237c80376f490212dc9b5431584958991925
+++ src/fs/null/store_null.c	eda38ac409bcb678d4d853ce97e8eecb25ee57e7
@@ -87,9 +87,18 @@
     storeRebuildComplete(&counts);
 }
 
-static int
+static char
 storeNullDirCheckObj(SwapDir * SD, const StoreEntry * e)
 {
+    return 0;
+}
+
+/*
+ * We should never, in theory, see an open/create, but just in case..
+ */
+static int
+storeNullDirCheckLoadAv(SwapDir *SD, store_op_t op)
+{
     return -1;
 }
 
@@ -113,6 +122,7 @@
     sd->statfs = storeNullDirStats;
     sd->init = storeNullDirInit;
     sd->checkobj = storeNullDirCheckObj;
+    sd->checkload = storeNullDirCheckLoadAv;
     sd->log.clean.start = storeNullDirWriteCleanStart;
     sd->log.clean.done = storeNullDirWriteCleanDone;
     parse_cachedir_options(sd, NULL, 0);
============================================================
--- src/fs/ufs/store_dir_ufs.c	4793d2c314a1b2a0085408592b65bb858ab30058
+++ src/fs/ufs/store_dir_ufs.c	7fea6eabaa15ef88ff1cbbc3b2a8f95da3419aa6
@@ -104,6 +104,7 @@
 static STDUMP storeUfsDirDump;
 static STMAINTAINFS storeUfsDirMaintain;
 static STCHECKOBJ storeUfsDirCheckObj;
+static STCHECKLOADAV storeUfsDirCheckLoadAv;
 static STREFOBJ storeUfsDirRefObj;
 static STUNREFOBJ storeUfsDirUnrefObj;
 static QS rev_int_sort;
@@ -1613,9 +1614,20 @@
  * object is able to be stored on this filesystem. UFS filesystems will
  * happily store anything as long as the LRU time isn't too small.
  */
-int
+char
 storeUfsDirCheckObj(SwapDir * SD, const StoreEntry * e)
 {
+    return 1;
+}
+
+/*
+ * storeUfsDirCheckLoadAv
+ *
+ * Return load average from 0 to 1000.
+ */
+int
+storeUfsDirCheckLoadAv(SwapDir *SD, store_op_t op)
+{
     ufsinfo_t *ufsinfo = SD->fsdata;
     return 500 + ufsinfo->open_files / 2;
 }
@@ -1906,6 +1918,7 @@
     sd->statfs = storeUfsDirStats;
     sd->maintainfs = storeUfsDirMaintain;
     sd->checkobj = storeUfsDirCheckObj;
+    sd->checkload = storeUfsDirCheckLoadAv;
     sd->refobj = storeUfsDirRefObj;
     sd->unrefobj = storeUfsDirUnrefObj;
     sd->callback = NULL;
============================================================
--- src/store_dir.c	e795049d82fdee67d27f34a53aed344c9c60f488
+++ src/store_dir.c	299ef0c831c2b8f781cfe9992ca0912e5baa5792
@@ -156,7 +156,10 @@
 	if (!storeDirValidSwapDirSize(dirn, objsize))
 	    continue;
 	/* check for error or overload condition */
-	load = sd->checkobj(sd, e);
+        if (sd->checkobj(sd, e) == 0) {
+            continue;
+        }
+	load = sd->checkload(sd, ST_OP_CREATE);
 	if (load < 0 || load > 1000) {
 	    continue;
 	}
@@ -197,7 +200,10 @@
     for (i = 0; i < Config.cacheSwap.n_configured; i++) {
 	SD = &Config.cacheSwap.swapDirs[i];
 	SD->flags.selected = 0;
-	load = SD->checkobj(SD, e);
+        if (SD->checkobj(SD, e) == 0) {
+            continue;
+        }
+	load = SD->checkload(SD, ST_OP_CREATE);
 	if (load < 0 || load > 1000) {
 	    continue;
 	}
============================================================
--- src/store_io.c	b3189954bb7b33712f066ccf62783d2b0506f710
+++ src/store_io.c	8a31eb00c0678314dbf38b0fa41d2bbd3f96f3b9
@@ -7,6 +7,12 @@
 	int create_fail;
 	int success;
     } create;
+    struct {
+        int calls;
+        int success;
+        int open_fail;
+        int loadav_fail;
+    } open;
 } store_io_stats;
 
 OBJH storeIOStats;
@@ -61,8 +67,23 @@
 storeOpen(StoreEntry * e, STFNCB * file_callback, STIOCB * callback,
     void *callback_data)
 {
+    int load;
+    storeIOState *sio;
+
     SwapDir *SD = &Config.cacheSwap.swapDirs[e->swap_dirn];
-    return SD->obj.open(SD, e, file_callback, callback, callback_data);
+    store_io_stats.open.calls++;
+    load = SD->checkload(SD, ST_OP_OPEN);
+    if (load < 0 || load > 1000) {
+        store_io_stats.open.loadav_fail++;
+        return NULL;
+    }
+    sio = SD->obj.open(SD, e, file_callback, callback, callback_data);
+    if (sio == NULL) {
+        store_io_stats.open.open_fail++;
+    } else {
+        store_io_stats.open.success++;
+    }
+    return sio;
 }
 
 void
@@ -114,4 +135,8 @@
     storeAppendPrintf(sentry, "create.select_fail %d\n", store_io_stats.create.select_fail);
     storeAppendPrintf(sentry, "create.create_fail %d\n", store_io_stats.create.create_fail);
     storeAppendPrintf(sentry, "create.success %d\n", store_io_stats.create.success);
+    storeAppendPrintf(sentry, "open.calls %d\n", store_io_stats.open.calls);
+    storeAppendPrintf(sentry, "open.success %d\n", store_io_stats.open.success);
+    storeAppendPrintf(sentry, "open.loadav_fail %d\n", store_io_stats.open.loadav_fail);
+    storeAppendPrintf(sentry, "open.open_fail %d\n", store_io_stats.open.open_fail);
 }
============================================================
--- src/structs.h	09fd7df0ee0cc66a8be6be822cf34b2203aac563
+++ src/structs.h	2cc0257c851aa9f3899204538a4037888a0465cf
@@ -1616,6 +1616,7 @@
     STSTATFS *statfs;		/* Dump fs statistics */
     STMAINTAINFS *maintainfs;	/* Replacement maintainence */
     STCHECKOBJ *checkobj;	/* Check if the fs will store an object */
+    STCHECKLOADAV *checkload;	/* Check if the fs is getting overloaded .. */
     /* These two are notifications */
     STREFOBJ *refobj;		/* Reference this object */
     STUNREFOBJ *unrefobj;	/* Unreference this object */
============================================================
--- src/typedefs.h	0a1930b4adf4cddddda7f44324e88fb53311162f
+++ src/typedefs.h	af3aabd123fce77fbe2ce6bfc45c942e516c8640
@@ -288,7 +288,8 @@
 typedef int STDBLCHECK(SwapDir *, StoreEntry *);
 typedef void STSTATFS(SwapDir *, StoreEntry *);
 typedef void STMAINTAINFS(SwapDir *);
-typedef int STCHECKOBJ(SwapDir *, const StoreEntry *);
+typedef int STCHECKLOADAV(SwapDir *, store_op_t op);
+typedef char STCHECKOBJ(SwapDir *, const StoreEntry *);
 typedef void STREFOBJ(SwapDir *, StoreEntry *);
 typedef void STUNREFOBJ(SwapDir *, StoreEntry *);
 typedef void STSETUP(storefs_entry_t *);
