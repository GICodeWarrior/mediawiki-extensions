--- htcp.c.mark	2006-05-04 01:25:52.984375000 +1000
+++ src/htcp.c	2006-05-04 01:43:53.859375000 +1000
@@ -158,11 +158,9 @@
 static MemPool *htcpSpecifierPool = NULL;
 static MemPool *htcpDetailPool = NULL;
 
-
-static char *htcpBuildPacket(htcpStuff * stuff, ssize_t * len);
+static ssize_t htcpBuildPacket(char* buf, size_t buflen, htcpStuff * stuff);
 static htcpSpecifier *htcpUnpackSpecifier(char *buf, int sz);
 static htcpDetail *htcpUnpackDetail(char *buf, int sz);
-static int htcpUnpackCountstr(char *buf, int sz, char **str);
 static ssize_t htcpBuildAuth(char *buf, size_t buflen);
 static ssize_t htcpBuildCountstr(char *buf, size_t buflen, const char *s);
 static ssize_t htcpBuildData(char *buf, size_t buflen, htcpStuff * stuff);
@@ -361,40 +359,38 @@
     return off;
 }
 
-static char *
-htcpBuildPacket(htcpStuff * stuff, ssize_t * len)
+/*
+ * Build an HTCP packet into buf, maximum length buflen.
+ * Returns the packet length, or zero on failure.
+ */
+static ssize_t
+htcpBuildPacket(char* buf, size_t buflen, htcpStuff * stuff)
 {
-    size_t buflen = 8192;
     ssize_t s;
     ssize_t off = 0;
     size_t hdr_sz = sizeof(htcpHeader);
     htcpHeader hdr;
-    char *buf = xcalloc(buflen, 1);
     /* skip the header -- we don't know the overall length */
     if (buflen < hdr_sz) {
-	xfree(buf);
-	return NULL;
+	return 0;
     }
     off += hdr_sz;
     s = htcpBuildData(buf + off, buflen - off, stuff);
     if (s < 0) {
-	xfree(buf);
-	return NULL;
+	return 0;
     }
     off += s;
     s = htcpBuildAuth(buf + off, buflen - off);
     if (s < 0) {
-	xfree(buf);
-	return NULL;
+	return 0;
     }
     off += s;
     hdr.length = htons((u_short) off);
     hdr.major = 0;
     hdr.minor = 0;
     xmemcpy(buf, &hdr, hdr_sz);
-    *len = off;
     debug(31, 3) ("htcpBuildPacket: size %d\n", (int) off);
-    return buf;
+    return off;
 }
 
 static void
@@ -420,122 +416,158 @@
 static void
 htcpFreeSpecifier(htcpSpecifier * s)
 {
-    safe_free(s->method);
-    safe_free(s->uri);
-    safe_free(s->version);
-    safe_free(s->req_hdrs);
     memPoolFree(htcpSpecifierPool, s);
 }
 
 static void
 htcpFreeDetail(htcpDetail * d)
 {
-    safe_free(d->resp_hdrs);
-    safe_free(d->entity_hdrs);
-    safe_free(d->cache_hdrs);
     memPoolFree(htcpDetailPool, d);
 }
 
-static int
-htcpUnpackCountstr(char *buf, int sz, char **str)
-{
-    u_short l;
-    debug(31, 3) ("htcpUnpackCountstr: sz = %d\n", sz);
-    if (sz < 2) {
-	debug(31, 3) ("htcpUnpackCountstr: sz < 2\n");
-	return -1;
-    }
-    htcpHexdump("htcpUnpackCountstr", buf, sz);
-    xmemcpy(&l, buf, 2);
-    l = ntohs(l);
-    buf += 2;
-    sz -= 2;
-    debug(31, 3) ("htcpUnpackCountstr: LENGTH = %d\n", (int) l);
-    if (sz < l) {
-	debug(31, 3) ("htcpUnpackCountstr: sz(%d) < l(%d)\n", sz, l);
-	return -1;
-    }
-    if (str) {
-	*str = xmalloc(l + 1);
-	xstrncpy(*str, buf, l + 1);
-	debug(31, 3) ("htcpUnpackCountstr: TEXT = {%s}\n", *str);
-    }
-    return (int) l + 2;
-}
-
+/*
+ * Unpack an HTCP SPECIFIER in place
+ * This will overwrite any following AUTH block
+ */
 static htcpSpecifier *
 htcpUnpackSpecifier(char *buf, int sz)
 {
     htcpSpecifier *s = memPoolAlloc(htcpSpecifierPool);
-    int o;
-    debug(31, 3) ("htcpUnpackSpecifier: %d bytes\n", (int) sz);
-    o = htcpUnpackCountstr(buf, sz, &s->method);
-    if (o < 0) {
+    
+    /* Find length of METHOD */
+    u_short l = ntohs(*(u_short*)buf);
+    sz -= 2;
+    buf += 2;
+    if (l > sz) {
 	debug(31, 1) ("htcpUnpackSpecifier: failed to unpack METHOD\n");
 	htcpFreeSpecifier(s);
 	return NULL;
     }
-    buf += o;
-    sz -= o;
-    o = htcpUnpackCountstr(buf, sz, &s->uri);
-    if (o < 0) {
+    /* Set METHOD */
+    s->method = buf;
+    buf += l;
+    sz -= l;
+    
+    /* Find length of URI */
+    l = ntohs(*(u_short*)buf);
+    sz -= 2;
+    if (l > sz) {
 	debug(31, 1) ("htcpUnpackSpecifier: failed to unpack URI\n");
 	htcpFreeSpecifier(s);
 	return NULL;
     }
-    buf += o;
-    sz -= o;
-    o = htcpUnpackCountstr(buf, sz, &s->version);
-    if (o < 0) {
+    /* Add terminating null to METHOD */
+    *buf = '\0';
+    /* Set URI */
+    buf += 2;
+    s->uri = buf;
+    buf += l;
+    sz -= l;
+
+    /* Find length of VERSION */
+    l = ntohs(*(u_short*)buf);
+    sz -= 2;
+    if (l > sz) {
 	debug(31, 1) ("htcpUnpackSpecifier: failed to unpack VERSION\n");
 	htcpFreeSpecifier(s);
 	return NULL;
     }
-    buf += o;
-    sz -= o;
-    o = htcpUnpackCountstr(buf, sz, &s->req_hdrs);
-    if (o < 0) {
+    /* Add terminating null to URI */
+    *buf = '\0';
+    /* Set VERSION */
+    buf += 2;
+    s->version = buf;
+    buf += l;
+    sz -= l;
+
+    /* Find length of REQ-HDRS */
+    l = ntohs(*(u_short*)buf);
+    sz -= 2;
+    if (l > sz) {
 	debug(31, 1) ("htcpUnpackSpecifier: failed to unpack REQ-HDRS\n");
 	htcpFreeSpecifier(s);
 	return NULL;
     }
-    buf += o;
-    sz -= o;
+    /* Add terminating null to URI */
+    *buf = '\0';
+    /* Set REQ-HDRS */
+    buf += 2;
+    s->req_hdrs = buf;
+    buf += l;
+    sz -= l;
+
     debug(31, 3) ("htcpUnpackSpecifier: %d bytes left\n", sz);
+    /* 
+     * Add terminating null to REQ-HDRS. This is possible because we allocated 
+     * an extra byte when we received the packet. This will overwrite any following
+     * AUTH block.
+     */
+    *buf = '\0';
     return s;
 }
 
+/*
+ * Unpack an HTCP DETAIL in place
+ * This will overwrite any following AUTH block
+ */
 static htcpDetail *
 htcpUnpackDetail(char *buf, int sz)
 {
     htcpDetail *d = memPoolAlloc(htcpDetailPool);
-    int o;
-    debug(31, 3) ("htcpUnpackDetail: %d bytes\n", (int) sz);
-    o = htcpUnpackCountstr(buf, sz, &d->resp_hdrs);
-    if (o < 0) {
-	debug(31, 1) ("htcpUnpackDetail: failed to unpack RESP_HDRS\n");
+
+    /* Find length of RESP-HDRS */
+    u_short l = ntohs(*(u_short*)buf);
+    sz -= 2;
+    buf += 2;
+    if (l > sz) {
+	debug(31, 1) ("htcpUnpackDetail: failed to unpack RESP-HDRS\n");
 	htcpFreeDetail(d);
 	return NULL;
     }
-    buf += o;
-    sz -= o;
-    o = htcpUnpackCountstr(buf, sz, &d->entity_hdrs);
-    if (o < 0) {
-	debug(31, 1) ("htcpUnpackDetail: failed to unpack ENTITY_HDRS\n");
+    /* Set RESP-HDRS */
+    d->resp_hdrs = buf;
+    buf += l;
+    sz -= l;
+    
+    /* Find length of ENTITY-HDRS */
+    l = ntohs(*(u_short*)buf);
+    sz -= 2;
+    if (l > sz) {
+	debug(31, 1) ("htcpUnpackDetail: failed to unpack ENTITY-HDRS\n");
 	htcpFreeDetail(d);
 	return NULL;
     }
-    buf += o;
-    sz -= o;
-    o = htcpUnpackCountstr(buf, sz, &d->cache_hdrs);
-    if (o < 0) {
-	debug(31, 1) ("htcpUnpackDetail: failed to unpack CACHE_HDRS\n");
+    /* Add terminating null to RESP-HDRS */
+    *buf = '\0';
+    /* Set ENTITY-HDRS */
+    buf += 2;
+    d->entity_hdrs = buf;
+    buf += l;
+    sz -= l;
+
+    /* Find length of CACHE-HDRS */
+    l = ntohs(*(u_short*)buf);
+    sz -= 2;
+    if (l > sz) {
+	debug(31, 1) ("htcpUnpackDetail: failed to unpack CACHE-HDRS\n");
 	htcpFreeDetail(d);
 	return NULL;
     }
-    buf += o;
-    sz -= o;
+    /* Add terminating null to ENTITY-HDRS */
+    *buf = '\0';
+    /* Set CACHE-HDRS */
+    buf += 2;
+    d->cache_hdrs = buf;
+    buf += l;
+    sz -= l;
+
     debug(31, 3) ("htcpUnpackDetail: %d bytes left\n", sz);
+    /* 
+     * Add terminating null to CACHE-HDRS. This is possible because we allocated 
+     * an extra byte when we received the packet. This will overwrite any following
+     * AUTH block.
+     */
+    *buf = '\0';
     return d;
 }
 
@@ -543,7 +575,7 @@
 htcpTstReply(htcpDataHeader * dhdr, StoreEntry * e, htcpSpecifier * spec, struct sockaddr_in *from)
 {
     htcpStuff stuff;
-    char *pkt;
+    static char pkt[8192];
     HttpHeader hdr;
     MemBuf mb;
     Packer p;
@@ -600,23 +632,22 @@
 	httpHeaderClean(&hdr);
 	packerClean(&p);
     }
-    pkt = htcpBuildPacket(&stuff, &pktlen);
+    pktlen = htcpBuildPacket(pkt, sizeof(pkt), &stuff);
     safe_free(stuff.D.resp_hdrs);
     safe_free(stuff.D.entity_hdrs);
     safe_free(stuff.D.cache_hdrs);
-    if (pkt == NULL) {
+    if (!pktlen) {
 	debug(31, 0) ("htcpTstReply: htcpBuildPacket() failed\n");
 	return;
     }
     htcpSend(pkt, (int) pktlen, from);
-    xfree(pkt);
 }
 
 static void
 htcpClrReply(htcpDataHeader * dhdr, int purgeSucceeded, struct sockaddr_in *from)
 {
     htcpStuff stuff;
-    char *pkt;
+    static char pkt[8192];
     ssize_t pktlen;
 
     /* If dhdr->F1 == 0, no response desired */
@@ -630,13 +661,12 @@
     stuff.response = purgeSucceeded ? 0 : 2;
     debug(31, 3) ("htcpClrReply: response = %d\n", stuff.response);
     stuff.msg_id = dhdr->msg_id;
-    pkt = htcpBuildPacket(&stuff, &pktlen);
-    if (pkt == NULL) {
+    pktlen = htcpBuildPacket(pkt, sizeof(pkt), &stuff);
+    if (pktlen == 0) {
 	debug(31, 0) ("htcpClrReply: htcpBuildPacket() failed\n");
 	return;
     }
     htcpSend(pkt, (int) pktlen, from);
-    xfree(pkt);
 }
 
 static void
@@ -968,7 +998,8 @@
     socklen_t flen = sizeof(struct sockaddr_in);
     memset(&from, '\0', flen);
     statCounter.syscalls.sock.recvfroms++;
-    len = recvfrom(fd, buf, 8192, 0, (struct sockaddr *) &from, &flen);
+    /* Receive up to 8191 bytes, leaving room for a null */
+    len = recvfrom(fd, buf, sizeof(buf)-1, 0, (struct sockaddr *) &from, &flen);
     debug(31, 3) ("htcpRecv: FD %d, %d bytes from %s:%d\n",
 	fd, len, inet_ntoa(from.sin_addr), ntohs(from.sin_port));
     htcpHandle(buf, len, &from);
@@ -1029,7 +1060,7 @@
 htcpQuery(StoreEntry * e, request_t * req, peer * p)
 {
     cache_key *save_key;
-    char *pkt;
+    static char pkt[8192];
     ssize_t pktlen;
     char vbuf[32];
     htcpStuff stuff;
@@ -1059,9 +1090,9 @@
     httpHeaderClean(&hdr);
     packerClean(&pa);
     stuff.S.req_hdrs = mb.buf;
-    pkt = htcpBuildPacket(&stuff, &pktlen);
+    pktlen = htcpBuildPacket(pkt, sizeof(pkt), &stuff);
     memBufClean(&mb);
-    if (pkt == NULL) {
+    if (!pktlen) {
 	debug(31, 0) ("htcpQuery: htcpBuildPacket() failed\n");
 	return;
     }
@@ -1069,7 +1100,6 @@
     save_key = queried_keys[stuff.msg_id % N_QUERIED_KEYS];
     storeKeyCopy(save_key, e->hash.key);
     debug(31, 3) ("htcpQuery: key (%p) %s\n", save_key, storeKeyText(save_key));
-    xfree(pkt);
 }
 
 /*  
