package net.psammead.functional;

import static net.psammead.functional.Functions.*;
import net.psammead.util.annotation.FullyStatic;
import net.psammead.util.ref.WeakAssociation;

@FullyStatic 
public final class Converters {
	private Converters() {}
	
	/** create a Converter not changing anything */
	public static <T> Converter<T,T> identity() {
		return new Converter<T,T>() {
			public T apply(T original) {
				return original;
			}
			public T unapply(T derived) {
				return derived;
			}
		};
	}
	
	public static <S,T> Converter<T,S> inverse(final Converter<S,T> source) {
		return new Converter<T,S>() {
			public S apply(T original) {
				return source.unapply(original);
			}
			public T unapply(S derived) {
				return source.apply(derived);
			}
		};
	}
	
	/** create a {@link Converter} from a forward and a reverse {@link Function} */
	public static <S,T> Converter<S,T> functionConverter(final Function<? super S,? extends T> forward, final Function<? super T,? extends S> reverse) {
		return new Converter<S,T>() {
			public T apply(S original) {
				return forward.apply(original);
			}
			public S unapply(T derived) {
				return reverse.apply(derived);
			}
		};
	}
	
	/** create a {@link Function} converting forward by calling {@link Converter#apply(Object)} */
	public static final <S,T> Function<S,T> forwardFunction(final Converter<S,T> converter) {
		return new Function<S,T>() {
			public T apply(S source) {
				return converter.apply(source);
			}
		};
	}
	
	/** create a {@link Function} converting reverse by calling {@link Converter#unapply(Object)}  */
	public static final <S,T> Function<T,S> reverseFunction(final Converter<S,T> converter) {
		return new Function<T,S>() {
			public S apply(T source) {
				return converter.unapply(source);
			}
		};
	}
	
	/** caches forward references generated by the delegate and allows reverse lookup */
	public static final <S,T> Converter<S,T> backRef(final Function<S,T> delegate) {
		final WeakAssociation<T,S>	association	= new WeakAssociation<T,S>();

		return new Converter<S,T>() {
			public T apply(S original) {
				T	target	= delegate.apply(original);
				association.put(target, original);
				return target;
			}

			public S unapply(T target) {
				return association.get(target);
			}
		};
	}
	
	/** 
	 * converts a single value into another value and leaves all other values unchanged 
	 * this can be used to convert null into a sentinel value
	 */
	public static <T> Converter<T,T> replaceConverter(final T originalValue, final T derivedValue) {
		return functionConverter(
				replace(originalValue,derivedValue), 
				replace(derivedValue, originalValue));
	}
}
