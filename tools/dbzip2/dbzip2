#!/usr/bin/python

# In progress proof of concept for distributed parallel bzip2 compression.
# Breaks incoming data stream into blocks, sends them out for separate
# compression on multiple threads.
#
# Currently running bzip2 chunks in local threads, will try moving to
# remotable network daemons distcc-style. It might or might not be worth
# it depending on the overhead of slinging around all the data.
#
# Like pbzip2 the output files will work with the regular 'bzip2' tool
# but may not work with other programs because each chunk is its own
# separate stream. Other tools tend to end at the first stream's end.
# it might be possible to combine the streams in some way, should
# investigate.
#
# Brion Vibber <brion@pobox.com>
# 2006-05-12

# TODO:
# Use a thread pool?
# Selectable remote threads
# Selectable block size
# Handle remote failures gracefully
# Merge blocks to single, more compatible stream
# Accept file input/output, behavior like bzip2

import bz2
import getopt
import random
import socket
import struct
import sys
import thread
import time

import DistBits

class Compressor(object):
	def __init__(self, args):
		self.inputStream = sys.stdin
		self.outputStream = sys.stdout
		self.blockSize = 900000 # 900k default blocksize
		self.threads = 1
		self.verbosity = 0
		
		self.readCount = 0
		self.writeCount = 0
		self.bytesRead = 0L
		self.bytesWritten = 0L
		
		self.remotes = []
		
		self.queue = []
		self.done = False
		self.threadLock = thread.allocate_lock()
		
		self.processArgs(args)
	
	def processArgs(self, args):
		(options, remainder) = getopt.getopt(args, "vp:r:")
		for (opt, val) in options:
			if opt == "-v":
				self.verbosity += 1
			elif opt == "-p":
				self.threads = int(val)
			elif opt == "-r":
				self.remotes.append(self.splitHost(val))
	
	def splitHost(self, val):
		if ":" in val:
			(host, port) = val.split(":")
			return (host, int(port))
		else:
			return (val, 12345)
	
	def debug(self, level, text):
		if self.verbosity >= level:
			sys.stderr.write(text + "\n")
	
	def run(self):
		thread.start_new_thread(self.readerThread, ())
		self.writerThread()
	
	def sleep(self):
		"""Wait a short time when out of data."""
		time.sleep(0.01)
	
	def lock(self):
		self.threadLock.acquire()
		assert self.threadLock.locked()
	
	def unlock(self):
		self.threadLock.release()
	
	def readerThread(self):
		"""Producer thread: run through the file handing out blocks."""
		self.debug(2, "readerThread: starting!")
		block = self.nextBlock()
		while block:
			while not self.ready():
				self.debug(4, "readerThread: full at %d; waiting" % len(self.queue))
				self.sleep()
			
			self.lock()
			self.readCount += 1
			self.debug(2, "readerThread: dispatching block %d" % self.readCount)
			self.dispatch(block)
			self.unlock()
			
			block = self.nextBlock()
		self.done = True
		self.debug(2, "readerThread: done; read %d blocks" % self.readCount)
	
	def nextBlock(self):
		buffer = self.inputStream.read(self.blockSize)
		self.bytesRead += len(buffer)
		self.debug(3, "nextBlock: %d" % len(buffer))
		return buffer
	
	def ready(self):
		"""Check if we've gone over the limit of waiting connections."""
		return len(self.queue) < self.threads

	def dispatch(self, block):
		"""Queue a block of data for remote compression."""
		assert self.threadLock.locked()
		buffer = QueuedBuffer(self.readCount)
		self.queue.append(buffer)
		thread.start_new_thread(self.remoteThread, (block, buffer))
	
	
	def writerThread(self):
		"""Consumer thread: as we receive compressed blocks from the
		distributed compressors, write them to the output file.
		Currently only writes blocks in order."""
		self.debug(2, "writerThread: starting")
		startTime = time.time()
		while not (self.done and self.writeCount == self.readCount):
			self.lock()
			buffer = self.dequeue()
			self.unlock()
			
			if buffer:
				self.writeCount += 1
				self.debug(2, "writerThread: writing block %d" % self.writeCount)
				self.writeBuffer(buffer)
			else:
				self.debug(4, "writerThread: sleeping")
				self.sleep()
		delta = time.time() - startTime
		megabyte = 1024.0 * 1024.0
		rateIn = (float(self.bytesRead) / megabyte) / delta
		rateOut = (float(self.bytesWritten) / megabyte) / delta
		self.debug(1, "Wrote %d blocks in %0.1f seconds (%0.3f MB/s in, %0.3f MB/s out)" % (
			self.writeCount, delta, rateIn, rateOut))
	
	def dequeue(self):
		"""Fetch the next completed block for writing."""
		assert self.threadLock.locked()
		if len(self.queue) and self.queue[0].ready():
			return self.queue.pop(0)
		else:
			return None
	
	def writeBuffer(self, buffer):
		"""Write a buffer to the file. Currently requires that buffers
		be processed in streaming order."""
		self.debug(3, "writeBuffer: writing block %d" % buffer.index)
		assert buffer.contents is not None
		assert buffer.index == self.writeCount
		self.bytesWritten += len(buffer.contents)
		self.outputStream.write(buffer.contents)
	
	
	def remoteThread(self, block, buffer):
		"""Worker thread: send a block to a foreign server and receive data."""
		compressor = self.pickCompressor()
		data = compressor.compress(block)
		self.debug(4, "remoteThread: got data!")
		buffer.set(data)
		# After it's been fulfilled, the writer thread will dequeue and write it.
	
	def pickCompressor(self):
		numRemotes = len(self.remotes)
		if numRemotes:
			index = random.randint(0, numRemotes - 1)
			return RemoteCompressor(self.remotes[index])
		else:
			# Need to take a local...
			return LocalCompressor()


class QueuedBuffer(object):
	"""Placeholder for received compressed buffer items."""
	
	def __init__(self, index):
		"""Initialize an empty placeholder, no data yet."""
		self.contents = None
		self.index = index
	
	def ready(self):
		return self.contents is not None
	
	def set(self, data):
		"""Store data and declare that we're ready to be flushed out."""
		assert self.contents is None
		assert data is not None
		self.contents = data


class LocalCompressor(object):
	"""For initial testing, we just compress locally."""
	
	def algo(self, algo):
		assert algo == "bzip2"
	
	def compress(self, block):
		return bz2.compress(block)
	
	def close(self):
		pass

class RemoteCompressor(object):
	def __init__(self, address):
		"""Address is a (host, port) tuple."""
		self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		self.socket.connect(address)
		self.connection = DistBits.Connection(self.socket)
		self.connection.send("COMP", struct.pack(">l", 1))
		self.connection.send("ALGO", "bzip2")
	
	def compress(self, data):
		self.connection.send("HUGE", data)
		(atom, retdata) = self.connection.receive()
		if atom == "SMAL":
			return retdata
		elif atom == "EROR":
			raise Exception(data)
		else:
			raise Exception("Unknown return atom type")
	
	def close(self):
		self.connection.send("CLOS")
		self.connection.close()
		self.socket.close()
		self.connection = None

if __name__ == "__main__":
	compressor = Compressor(sys.argv[1:])
	compressor.run()
