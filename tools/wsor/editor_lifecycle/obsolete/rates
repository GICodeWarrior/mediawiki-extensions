#!/usr/bin/python
#:vim:ts=python:

''' compute editor lifecycle '''

'''
Copyright (C) 2011 GIOVANNI LUCA CIAMPAGLIA, GCIAMPAGLIA@WIKIMEDIA.ORG
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
http://www.gnu.org/copyleft/gpl.html
'''

import re
import os
from argparse import ArgumentParser
import numpy as np
from collections import deque
import datetime as dt

from lifecycle.rates import *

__prog__ = os.path.basename(os.path.abspath(__file__))

parser = ArgumentParser(description=__doc__)
parser.add_argument('data_file', metavar='data')
parser.add_argument(metavar='minact', type=int, dest='minimum_activity')
parser.add_argument(metavar='maxact', type=int, dest='maximum_activity')
parser.add_argument('-key')
parser.add_argument('-every', type=int, help='default: %(default)d days',
        default=30, metavar='NUM')
parser.add_argument('-inactivity', type=int, default=180, help='default: '
        '%(default)d days', metavar='NUM')
parser.add_argument('-all', dest='dump_all', action='store_true')


def main(ns):
    if ns.key is None:
        m = re.match('(.*?)\.npz', ns.data_file, re.I)
        if m is not None:
            ns.key = m.groups()[0]
        else:
            print >> sys.stderr, '%s: cannot determine key from file name: %s'\
                    % (__prog__, ns.data_file)
            sys.exit(1)
    if ns.minimum_activity >= ns.maximum_activity:
        print >> sys.stderr, '%s: error: minact >= maxact' % __prog__
        sys.exit(1)

    # load data 
    npzarchive = np.load(ns.data_file)

    if ns.dump_all:
        fn = mkfn('cycles', ns, 'npz')
        values_iter = itercycles(npzarchive, ns.every)
        keys = npzarchive.files
        tmp = dict(zip(keys, list(values_iter)))
        np.savez(fn, **tmp)
        print '%s: output saved to %s' % (__prog__, fn)
    else:
        # compute lifetime distribution
        lt = lifetimes(npzarchive)

        # compute inactive subgroups
        inactive_users = find_inactives(npzarchive, ns.inactivity, ns.minimum_activity,
                ns.maximum_activity)

        ratesbyday = groupbyday(npzarchive, ns.every)
        ratesbyday_inact = groupbyday(npzarchive, ns.every, inactive_users)

        avg_all = averagecycle(ratesbyday)
        avg_inact = averagecycle(ratesbyday_inact)
        
        lens = [ len(npzarchive.files), len(inactive_users) ]

        names = ['lt', 'len', 'all', 'inact' ]
        arrs = [ lt, lens, avg_all, avg_inact ]
        
        for n, a in zip(names, arrs):
            fn = '%s_%s.%s' % (ns.key, n, 'tsv')
            np.savetxt(fn, a)
            print '%s: output saved to %s' % (__prog__, fn)

if __name__ == '__main__':
    ns = parser.parse_args()
    main(ns)
