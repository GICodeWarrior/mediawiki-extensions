To: vim-dev@vim.org
Subject: patch 7.1.001
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.001
Problem:    Still can't build with Gnome libraries.
Solution:   Fix typo in bind_textdomain_codeset. (Mike Kelly)
Files:	    src/gui_gtk.c, src/gui_gtk_x11.c


*** ../vim-7.1.000/src/gui_gtk.c	Thu May 10 20:27:29 2007
--- src/gui_gtk.c	Mon May 14 14:40:54 2007
***************
*** 53,60 ****
  # ifdef bindtextdomain
  #  undef bindtextdomain
  # endif
! # ifdef bindtextdomain_codeset
! #  undef bindtextdomain_codeset
  # endif
  # if defined(FEAT_GETTEXT) && !defined(ENABLE_NLS)
  #  define ENABLE_NLS	/* so the texts in the dialog boxes are translated */
--- 53,60 ----
  # ifdef bindtextdomain
  #  undef bindtextdomain
  # endif
! # ifdef bind_textdomain_codeset
! #  undef bind_textdomain_codeset
  # endif
  # if defined(FEAT_GETTEXT) && !defined(ENABLE_NLS)
  #  define ENABLE_NLS	/* so the texts in the dialog boxes are translated */
*** ../vim-7.1.000/src/gui_gtk_x11.c	Thu May 10 21:17:51 2007
--- src/gui_gtk_x11.c	Mon May 14 14:41:06 2007
***************
*** 36,43 ****
  # ifdef bindtextdomain
  #  undef bindtextdomain
  # endif
! # ifdef bindtextdomain_codeset
! #  undef bindtextdomain_codeset
  # endif
  # if defined(FEAT_GETTEXT) && !defined(ENABLE_NLS)
  #  define ENABLE_NLS	/* so the texts in the dialog boxes are translated */
--- 36,43 ----
  # ifdef bindtextdomain
  #  undef bindtextdomain
  # endif
! # ifdef bind_textdomain_codeset
! #  undef bind_textdomain_codeset
  # endif
  # if defined(FEAT_GETTEXT) && !defined(ENABLE_NLS)
  #  define ENABLE_NLS	/* so the texts in the dialog boxes are translated */
*** ../vim-7.1.000/src/version.c	Sat May 12 16:34:15 2007
--- src/version.c	Mon May 14 14:42:19 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     1,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
127. You bring your laptop and cellular phone to church.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.002
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.002
Problem:    Oracle Pro*C/C++ files are not detected.
Solution:   Add the missing star. (Micah J. Cowan)
Files:	    runtime/filetype.vim


*** ../vim-7.1.001/runtime/filetype.vim	Thu May 10 20:42:30 2007
--- runtime/filetype.vim	Tue May 15 09:12:06 2007
***************
*** 1,7 ****
  " Vim support file to detect file types
  "
  " Maintainer:	Bram Moolenaar <Bram@vim.org>
! " Last Change:	2007 May 10
  
  " Listen very carefully, I will say this only once
  if exists("did_load_filetypes")
--- 1,7 ----
  " Vim support file to detect file types
  "
  " Maintainer:	Bram Moolenaar <Bram@vim.org>
! " Last Change:	2007 May 15
  
  " Listen very carefully, I will say this only once
  if exists("did_load_filetypes")
***************
*** 1286,1292 ****
  au BufNewFile,BufRead *.it,*.ih			setf ppwiz
  
  " Oracle Pro*C/C++
! au BufNewFile,BufRead .pc			setf proc
  
  " Privoxy actions file
  au BufNewFile,BufRead *.action			setf privoxy
--- 1286,1292 ----
  au BufNewFile,BufRead *.it,*.ih			setf ppwiz
  
  " Oracle Pro*C/C++
! au BufNewFile,BufRead *.pc			setf proc
  
  " Privoxy actions file
  au BufNewFile,BufRead *.action			setf privoxy
*** ../vim-7.1.001/src/version.c	Mon May 14 19:35:51 2007
--- src/version.c	Tue May 15 09:13:11 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     2,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
132. You come back and check this list every half-hour.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.003 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.003 (extra)
Problem:    The "Tear off this menu" message appears in the message history
	    when using a menu. (Yongwei Wu)
Solution:   Disable message history when displaying the menu tip.
Files:	    src/gui_w32.c


*** ../vim-7.1.002/src/gui_w32.c	Thu May 10 22:17:22 2007
--- src/gui_w32.c	Sat Jun  9 13:43:07 2007
***************
*** 1051,1057 ****
--- 1051,1059 ----
  	    if (pMenu != NULL && pMenu->strings[MENU_INDEX_TIP] != 0
  		    && GetMenuState(s_menuBar, pMenu->id, MF_BYCOMMAND) != -1)
  	    {
+ 		++msg_hist_off;
  		msg(pMenu->strings[MENU_INDEX_TIP]);
+ 		--msg_hist_off;
  		setcursor();
  		out_flush();
  		did_menu_tip = TRUE;
*** ../vim-7.1.002/src/version.c	Tue May 15 09:14:33 2007
--- src/version.c	Tue Jun 19 10:08:17 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     3,
  /**/

-- 
In his lifetime van Gogh painted 486 oil paintings. Oddly enough, 8975
of them are to be found in the United States.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.004
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.004
Problem:    Crash when doing ":next directory". (Raphael Finkel)
Solution:   Do not use "buf", it may be invalid after autocommands.
Files:	    src/ex_cmds.c


*** ../vim-7.1.003/src/ex_cmds.c	Thu May 10 21:24:24 2007
--- src/ex_cmds.c	Mon Jun 18 22:03:56 2007
***************
*** 3367,3373 ****
  		 * was in this window (or another window).  If not used
  		 * before, reset the local window options to the global
  		 * values.  Also restores old folding stuff. */
! 		get_winopts(buf);
  #ifdef FEAT_SPELL
  		did_get_winopts = TRUE;
  #endif
--- 3367,3373 ----
  		 * was in this window (or another window).  If not used
  		 * before, reset the local window options to the global
  		 * values.  Also restores old folding stuff. */
! 		get_winopts(curbuf);
  #ifdef FEAT_SPELL
  		did_get_winopts = TRUE;
  #endif
***************
*** 3649,3656 ****
  #ifdef FEAT_SPELL
      /* If the window options were changed may need to set the spell language.
       * Can only do this after the buffer has been properly setup. */
!     if (did_get_winopts && curwin->w_p_spell && *buf->b_p_spl != NUL)
! 	did_set_spelllang(buf);
  #endif
  
      if (command == NULL)
--- 3649,3656 ----
  #ifdef FEAT_SPELL
      /* If the window options were changed may need to set the spell language.
       * Can only do this after the buffer has been properly setup. */
!     if (did_get_winopts && curwin->w_p_spell && *curbuf->b_p_spl != NUL)
! 	did_set_spelllang(curbuf);
  #endif
  
      if (command == NULL)
*** ../vim-7.1.003/src/version.c	Tue Jun 19 10:09:15 2007
--- src/version.c	Tue Jun 19 11:53:34 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     4,
  /**/

-- 
FIRST HEAD:  Oh! quick! get the sword out I want to cut his head off.
THIRD HEAD:  Oh, cut your own head off.
SECOND HEAD: Yes - do us all a favour.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.005
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.005
Problem:    "cit" used on <foo></foo> deletes <foo>.  Should not delete
	    anything and start insertion, like "ci'" does on "". (Michal
	    Bozon)
Solution:   Handle an empty object specifically.  Made it work consistent for
	    various text objects.
Files:	    src/search.c


*** ../vim-7.1.004/src/search.c	Thu May 10 20:54:46 2007
--- src/search.c	Mon Jun  4 12:31:04 2007
***************
*** 3600,3612 ****
      {
  	oap->start = start_pos;
  	oap->motion_type = MCHAR;
  	if (sol)
- 	{
  	    incl(&curwin->w_cursor);
! 	    oap->inclusive = FALSE;
! 	}
! 	else
  	    oap->inclusive = TRUE;
      }
  
      return OK;
--- 3600,3615 ----
      {
  	oap->start = start_pos;
  	oap->motion_type = MCHAR;
+ 	oap->inclusive = FALSE;
  	if (sol)
  	    incl(&curwin->w_cursor);
! 	else if (lt(start_pos, curwin->w_cursor))
! 	    /* Include the character under the cursor. */
  	    oap->inclusive = TRUE;
+ 	else
+ 	    /* End is before the start (no text in between <>, [], etc.): don't
+ 	     * operate on any text. */
+ 	    curwin->w_cursor = start_pos;
      }
  
      return OK;
***************
*** 3734,3740 ****
  
  	if (in_html_tag(FALSE))
  	{
! 	    /* cursor on start tag, move to just after it */
  	    while (*ml_get_cursor() != '>')
  		if (inc_cursor() < 0)
  		    break;
--- 3737,3743 ----
  
  	if (in_html_tag(FALSE))
  	{
! 	    /* cursor on start tag, move to its '>' */
  	    while (*ml_get_cursor() != '>')
  		if (inc_cursor() < 0)
  		    break;
***************
*** 3838,3844 ****
  	/* Exclude the start tag. */
  	curwin->w_cursor = start_pos;
  	while (inc_cursor() >= 0)
! 	    if (*ml_get_cursor() == '>' && lt(curwin->w_cursor, end_pos))
  	    {
  		inc_cursor();
  		start_pos = curwin->w_cursor;
--- 3841,3847 ----
  	/* Exclude the start tag. */
  	curwin->w_cursor = start_pos;
  	while (inc_cursor() >= 0)
! 	    if (*ml_get_cursor() == '>')
  	    {
  		inc_cursor();
  		start_pos = curwin->w_cursor;
***************
*** 3860,3866 ****
  #ifdef FEAT_VISUAL
      if (VIsual_active)
      {
! 	if (*p_sel == 'e')
  	    ++curwin->w_cursor.col;
  	VIsual = start_pos;
  	VIsual_mode = 'v';
--- 3863,3873 ----
  #ifdef FEAT_VISUAL
      if (VIsual_active)
      {
! 	/* If the end is before the start there is no text between tags, select
! 	 * the char under the cursor. */
! 	if (lt(end_pos, start_pos))
! 	    curwin->w_cursor = start_pos;
! 	else if (*p_sel == 'e')
  	    ++curwin->w_cursor.col;
  	VIsual = start_pos;
  	VIsual_mode = 'v';
***************
*** 3872,3878 ****
      {
  	oap->start = start_pos;
  	oap->motion_type = MCHAR;
! 	oap->inclusive = TRUE;
      }
      retval = OK;
  
--- 3879,3893 ----
      {
  	oap->start = start_pos;
  	oap->motion_type = MCHAR;
! 	if (lt(end_pos, start_pos))
! 	{
! 	    /* End is before the start: there is no text between tags; operate
! 	     * on an empty area. */
! 	    curwin->w_cursor = start_pos;
! 	    oap->inclusive = FALSE;
! 	}
! 	else
! 	    oap->inclusive = TRUE;
      }
      retval = OK;
  
*** ../vim-7.1.004/src/version.c	Tue Jun 19 11:54:23 2007
--- src/version.c	Tue Jun 19 12:57:03 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     5,
  /**/

-- 
Life would be so much easier if we could just look at the source code.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.006
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.006
Problem:    Resetting 'modified' in a StdinReadPost autocommand doesn't work.
Solution:   Set 'modified' before the autocommands instead of after it.
Files:	    src/buffer.c


*** ../vim-7.1.005/src/buffer.c	Thu May 10 18:43:46 2007
--- src/buffer.c	Fri Jun  8 20:59:04 2007
***************
*** 171,176 ****
--- 171,183 ----
  	    /* Put the cursor on the first line. */
  	    curwin->w_cursor.lnum = 1;
  	    curwin->w_cursor.col = 0;
+ 
+ 	    /* Set or reset 'modified' before executing autocommands, so that
+ 	     * it can be changed there. */
+ 	    if (!readonlymode && !bufempty())
+ 		changed();
+ 	    else if (retval != FAIL)
+ 		unchanged(curbuf, FALSE);
  #ifdef FEAT_AUTOCMD
  # ifdef FEAT_EVAL
  	    apply_autocmds_retval(EVENT_STDINREADPOST, NULL, NULL, FALSE,
***************
*** 194,209 ****
      /* When reading stdin, the buffer contents always needs writing, so set
       * the changed flag.  Unless in readonly mode: "ls | gview -".
       * When interrupted and 'cpoptions' contains 'i' set changed flag. */
!     if ((read_stdin && !readonlymode && !bufempty())
  #ifdef FEAT_AUTOCMD
  		|| modified_was_set	/* ":set modified" used in autocmd */
  # ifdef FEAT_EVAL
  		|| (aborting() && vim_strchr(p_cpo, CPO_INTMOD) != NULL)
  # endif
  #endif
! 		|| (got_int && vim_strchr(p_cpo, CPO_INTMOD) != NULL))
  	changed();
!     else if (retval != FAIL)
  	unchanged(curbuf, FALSE);
      save_file_ff(curbuf);		/* keep this fileformat */
  
--- 201,216 ----
      /* When reading stdin, the buffer contents always needs writing, so set
       * the changed flag.  Unless in readonly mode: "ls | gview -".
       * When interrupted and 'cpoptions' contains 'i' set changed flag. */
!     if ((got_int && vim_strchr(p_cpo, CPO_INTMOD) != NULL)
  #ifdef FEAT_AUTOCMD
  		|| modified_was_set	/* ":set modified" used in autocmd */
  # ifdef FEAT_EVAL
  		|| (aborting() && vim_strchr(p_cpo, CPO_INTMOD) != NULL)
  # endif
  #endif
!        )
  	changed();
!     else if (retval != FAIL && !read_stdin)
  	unchanged(curbuf, FALSE);
      save_file_ff(curbuf);		/* keep this fileformat */
  
*** ../vim-7.1.005/src/version.c	Tue Jun 19 12:58:55 2007
--- src/version.c	Tue Jun 19 15:37:53 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     6,
  /**/

-- 
If I tell you "you have a beautiful body", would you hold it against me?

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.007 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.007 (extra)
Problem:    Mac: Context menu doesn't work on Intel Macs.
            Scrollbars are not dimmed when Vim is not the active application.
Solution:   Remove the test whether context menus are supported.  They are
            always there in OS/X.  Handle the dimming. (Nicolas Weber)
Files:      src/gui_mac.c, src/gui.h


*** ../vim-7.1.006/src/gui_mac.c	Thu May 10 20:07:25 2007
--- src/gui_mac.c	Sat Jun  9 14:19:25 2007
***************
*** 1676,1688 ****
  	/* TODO: NEEDED? */
  	clickIsPopup = FALSE;
  
! 	if ((gui.MacOSHaveCntxMenu) && (mouse_model_popup()))
! 	    if (IsShowContextualMenuClick(theEvent))
! 	    {
! 		vimMouseButton = MOUSE_RIGHT;
! 		vimModifiers &= ~MOUSE_CTRL;
! 		clickIsPopup = TRUE;
! 	    }
  
  	/* Is it a double click ? */
  	dblClick = ((theEvent->when - lastMouseTick) < GetDblTime());
--- 1676,1687 ----
  	/* TODO: NEEDED? */
  	clickIsPopup = FALSE;
  
! 	if (mouse_model_popup() && IsShowContextualMenuClick(theEvent))
! 	{
! 	    vimMouseButton = MOUSE_RIGHT;
! 	    vimModifiers &= ~MOUSE_CTRL;
! 	    clickIsPopup = TRUE;
! 	}
  
  	/* Is it a double click ? */
  	dblClick = ((theEvent->when - lastMouseTick) < GetDblTime());
***************
*** 1920,1943 ****
      WindowPtr	whichWindow;
  
      whichWindow = (WindowPtr) event->message;
!     if ((event->modifiers) & activeFlag)
! 	/* Activate */
! 	gui_focus_change(TRUE);
!     else
      {
! 	/* Deactivate */
! 	gui_focus_change(FALSE);
! /*	DON'T KNOW what the code below was doing
! 	found in the deactivate clause, but the
! 	clause writing TRUE into in_focus (BUG)
!  */
! 
! #if 0	/* Removed by Dany as per above June 2001 */
! 	a_bool = false;
! 	SetPreserveGlyph(a_bool);
! 	SetOutlinePreferred(a_bool);
! #endif
      }
  }
  
  
--- 1919,1937 ----
      WindowPtr	whichWindow;
  
      whichWindow = (WindowPtr) event->message;
!     /* Dim scrollbars */
!     if (whichWindow == gui.VimWindow)
      {
!         ControlRef rootControl;
!         GetRootControl(gui.VimWindow, &rootControl);
!         if ((event->modifiers) & activeFlag)
!             ActivateControl(rootControl);
!         else
!             DeactivateControl(rootControl);
      }
+ 
+     /* Activate */
+     gui_focus_change((event->modifiers) & activeFlag);
  }
  
  
***************
*** 2559,2574 ****
      OSErr	error;
  
      /* Handle contextual menu right now (if needed) */
!     if (gui.MacOSHaveCntxMenu)
! 	if (IsShowContextualMenuClick(event))
! 	{
  # if 0
! 	    gui_mac_handle_contextual_menu(event);
  # else
! 	    gui_mac_doMouseDownEvent(event);
  # endif
! 	    return;
! 	}
  
      /* Handle normal event */
      switch (event->what)
--- 2553,2567 ----
      OSErr	error;
  
      /* Handle contextual menu right now (if needed) */
!     if (IsShowContextualMenuClick(event))
!     {
  # if 0
!         gui_mac_handle_contextual_menu(event);
  # else
!         gui_mac_doMouseDownEvent(event);
  # endif
!         return;
!     }
  
      /* Handle normal event */
      switch (event->what)
***************
*** 2782,2795 ****
      (void) InstallAEHandlers();
  #endif
  
-     if (Gestalt(gestaltContextualMenuAttr, &gestalt_rc) == noErr)
- 	gui.MacOSHaveCntxMenu = BitTst(&gestalt_rc, 31-gestaltContextualMenuTrapAvailable);
-     else
- 	gui.MacOSHaveCntxMenu = false;
- 
-     if (gui.MacOSHaveCntxMenu)
- 	gui.MacOSHaveCntxMenu = (InitContextualMenus()==noErr);
- 
      pomme = NewMenu(256, "\p\024"); /* 0x14= = Apple Menu */
  
      AppendMenu(pomme, "\pAbout VIM");
--- 2775,2780 ----
***************
*** 2941,2946 ****
--- 2926,2932 ----
  #ifdef USE_CARBONKEYHANDLER
      EventHandlerRef keyEventHandlerRef;
  #endif
+     ControlRef rootControl;
  
      if (Gestalt(gestaltSystemVersion, &gMacSystemVersion) != noErr)
  	gMacSystemVersion = 0x1000; /* TODO: Default to minimum sensible value */
***************
*** 2954,2968 ****
      (void) InstallAEHandlers();
  #endif
  
-     /* Ctrl click */
-     if (Gestalt(gestaltContextualMenuAttr, &gestalt_rc) == noErr)
- 	gui.MacOSHaveCntxMenu = BitTst(&gestalt_rc, 31-gestaltContextualMenuTrapAvailable);
-     else
- 	gui.MacOSHaveCntxMenu = false;
- 
-     if (gui.MacOSHaveCntxMenu)
- 	gui.MacOSHaveCntxMenu = (InitContextualMenus()==noErr);
- 
      pomme = NewMenu(256, "\p\024"); /* 0x14= = Apple Menu */
  
      AppendMenu(pomme, "\pAbout VIM");
--- 2940,2945 ----
***************
*** 2981,2986 ****
--- 2958,2964 ----
      gui.VimWindow = NewCWindow(nil, &windRect, "\pgVim on Macintosh", true,
  			zoomDocProc,
  			(WindowPtr)-1L, true, 0);
+     CreateRootControl(gui.VimWindow, &rootControl);
      InstallReceiveHandler((DragReceiveHandlerUPP)receiveHandler,
  	    gui.VimWindow, NULL);
      SetPortWindowPort(gui.VimWindow);
*** ../vim-7.1.006/src/gui.h	Thu May 10 19:18:46 2007
--- src/gui.h	Sat Jun  9 14:10:34 2007
***************
*** 460,466 ****
      WindowPtr	VimWindow;
      MenuHandle	MacOSHelpMenu;	    /* Help menu provided by the MacOS */
      int		MacOSHelpItems;	    /* Nr of help-items supplied by MacOS */
-     int		MacOSHaveCntxMenu;  /* Contextual menu available */
      WindowPtr	wid;		    /* Window id of text area */
      int		visibility;	    /* Is window partially/fully obscured? */
  #endif
--- 460,465 ----
*** ../vim-7.1.006/src/version.c	Tue Jun 19 15:40:51 2007
--- src/version.c	Tue Jun 19 15:44:15 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     7,
  /**/

-- 
       When danger reared its ugly head,
       He bravely turned his tail and fled
       Yes, Brave Sir Robin turned about
       And gallantly he chickened out
       Bravely taking to his feet
       He beat a very brave retreat
       Bravest of the brave Sir Robin
       Petrified of being dead
       Soiled his pants then brave Sir Robin
       Turned away and fled.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.008 (correction
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Oops, forgot the src/version.c change.

Patch 7.1.008
Problem:    getfsize() returns a negative number for very big files.
Solution:   Check for overflow and return -2.
Files:	    runtime/doc/eval.txt, src/eval.c


*** ../vim-7.1.007/runtime/doc/eval.txt	Sat May 12 16:38:23 2007
--- runtime/doc/eval.txt	Sat Jun  9 15:48:40 2007
***************
*** 1,4 ****
! *eval.txt*      For Vim version 7.1.  Last change: 2007 May 11
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
--- 1,4 ----
! *eval.txt*      For Vim version 7.1.  Last change: 2007 Jun 09
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
***************
*** 2824,2829 ****
--- 2824,2831 ----
  		given file {fname}.
  		If {fname} is a directory, 0 is returned.
  		If the file {fname} can't be found, -1 is returned.
+ 		If the size of {fname} is too big to fit in a Number then -2
+ 		is returned.
  
  getfontname([{name}])					*getfontname()*
  		Without an argument returns the name of the normal font being
*** ../vim-7.1.007/src/eval.c	Thu May 10 21:30:00 2007
--- src/eval.c	Sat Jun  9 15:46:46 2007
***************
*** 10136,10142 ****
--- 10136,10148 ----
  	if (mch_isdir(fname))
  	    rettv->vval.v_number = 0;
  	else
+ 	{
  	    rettv->vval.v_number = (varnumber_T)st.st_size;
+ 
+ 	    /* non-perfect check for overflow */
+ 	    if ((off_t)rettv->vval.v_number != (off_t)st.st_size)
+ 		rettv->vval.v_number = -2;
+ 	}
      }
      else
  	  rettv->vval.v_number = -1;
*** ../vim-7.1.007/src/version.c	Tue Jun 19 16:33:53 2007
--- src/version.c	Tue Jun 19 17:30:50 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     8,
  /**/


-- 
ZOOT:  I'm afraid our life must seem very dull and quiet compared to yours.
       We are but eightscore young blondes, all between sixteen and
       nineteen-and-a-half, cut off in this castle, with no one to protect us.
       Oooh.  It is a lonely life ... bathing ...  dressing ... undressing ...
       making exciting underwear....
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.009
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.009
Problem:    In diff mode, displaying the difference between a tab and spaces
	    is not highlighted correctly.
Solution:   Only change highlighting at the end of displaying a tab.
Files:	    src/screen.c


*** ../vim-7.1.008/src/screen.c	Thu May 10 20:15:31 2007
--- src/screen.c	Mon Jun 11 21:49:44 2007
***************
*** 3459,3467 ****
  #ifdef FEAT_DIFF
  	    if (diff_hlf != (hlf_T)0)
  	    {
! 		if (diff_hlf == HLF_CHD && ptr - line >= change_start)
  		    diff_hlf = HLF_TXD;		/* changed text */
! 		if (diff_hlf == HLF_TXD && ptr - line > change_end)
  		    diff_hlf = HLF_CHD;		/* changed line */
  		line_attr = hl_attr(diff_hlf);
  	    }
--- 3459,3469 ----
  #ifdef FEAT_DIFF
  	    if (diff_hlf != (hlf_T)0)
  	    {
! 		if (diff_hlf == HLF_CHD && ptr - line >= change_start
! 							      && n_extra == 0)
  		    diff_hlf = HLF_TXD;		/* changed text */
! 		if (diff_hlf == HLF_TXD && ptr - line > change_end
! 							      && n_extra == 0)
  		    diff_hlf = HLF_CHD;		/* changed line */
  		line_attr = hl_attr(diff_hlf);
  	    }
*** ../vim-7.1.008/src/version.c	Tue Jun 19 17:33:52 2007
--- src/version.c	Tue Jun 19 17:36:36 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     9,
  /**/

-- 
Linux is just like a wigwam: no Windows, no Gates and an Apache inside.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.010
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.010
Problem:    The Gnome session file doesn't restore tab pages.
Solution:   Add SSOP_TABPAGES to the session flags. (Matias D'Ambrosio)
Files:	    src/gui_gtk_x11.c


*** ../vim-7.1.009/src/gui_gtk_x11.c	Mon May 14 19:35:51 2007
--- src/gui_gtk_x11.c	Sat Jun  9 16:54:13 2007
***************
*** 2188,2195 ****
      escaped_filename = vim_strsave_escaped(filename, escape_chars);
      if (escaped_filename == NULL)
  	return FALSE;
!     mksession_cmdline = g_strconcat("mksession ", (char *)escaped_filename, NULL);
      vim_free(escaped_filename);
      /*
       * Use a reasonable hardcoded set of 'sessionoptions' flags to avoid
       * unpredictable effects when the session is saved automatically.  Also,
--- 2188,2197 ----
      escaped_filename = vim_strsave_escaped(filename, escape_chars);
      if (escaped_filename == NULL)
  	return FALSE;
!     mksession_cmdline = g_strconcat("mksession ", (char *)escaped_filename,
! 									NULL);
      vim_free(escaped_filename);
+ 
      /*
       * Use a reasonable hardcoded set of 'sessionoptions' flags to avoid
       * unpredictable effects when the session is saved automatically.  Also,
***************
*** 2199,2205 ****
       */
      save_ssop_flags = ssop_flags;
      ssop_flags = (SSOP_BLANK|SSOP_CURDIR|SSOP_FOLDS|SSOP_GLOBALS
! 		  |SSOP_HELP|SSOP_OPTIONS|SSOP_WINSIZE);
  
      do_cmdline_cmd((char_u *)"let Save_VV_this_session = v:this_session");
      failed = (do_cmdline_cmd((char_u *)mksession_cmdline) == FAIL);
--- 2201,2207 ----
       */
      save_ssop_flags = ssop_flags;
      ssop_flags = (SSOP_BLANK|SSOP_CURDIR|SSOP_FOLDS|SSOP_GLOBALS
! 		  |SSOP_HELP|SSOP_OPTIONS|SSOP_WINSIZE|SSOP_TABPAGES);
  
      do_cmdline_cmd((char_u *)"let Save_VV_this_session = v:this_session");
      failed = (do_cmdline_cmd((char_u *)mksession_cmdline) == FAIL);
*** ../vim-7.1.009/src/version.c	Tue Jun 19 17:49:12 2007
--- src/version.c	Tue Jun 19 18:07:09 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     10,
  /**/

-- 
GALAHAD: No look, really, this isn't nescess ...
PIGLET:  We must examine you.
GALAHAD: There's nothing wrong with ... that.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.011
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.011
Problem:    Possible buffer overflow when $VIMRUNTIME is very long. (Victor
	    Stinner)
Solution:   Use vim_snprintf().
Files:	    src/main.c


*** ../vim-7.1.010/src/main.c	Thu May 10 21:12:25 2007
--- src/main.c	Sat Jun  9 22:37:46 2007
***************
*** 1360,1367 ****
  	p = vim_getenv((char_u *)"VIMRUNTIME", &mustfree);
  	if (p != NULL && *p != NUL)
  	{
! 	    STRCPY(NameBuff, p);
! 	    STRCAT(NameBuff, "/lang");
  	    bindtextdomain(VIMPACKAGE, (char *)NameBuff);
  	}
  	if (mustfree)
--- 1360,1366 ----
  	p = vim_getenv((char_u *)"VIMRUNTIME", &mustfree);
  	if (p != NULL && *p != NUL)
  	{
! 	    vim_snprintf((char *)NameBuff, MAXPATHL, "%s/lang", p);
  	    bindtextdomain(VIMPACKAGE, (char *)NameBuff);
  	}
  	if (mustfree)
*** ../vim-7.1.010/src/version.c	Tue Jun 19 18:07:52 2007
--- src/version.c	Tue Jun 19 20:29:44 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     11,
  /**/

-- 
   GALAHAD hurries to the door and pushes through it.  As he leaves the room
   we CUT TO the reverse to show that he is now in a room full of bathing
   and romping GIRLIES, all innocent, wide-eyed and beautiful.  They smile
   enchantingly at him as he tries to keep walking without being diverted by
   the lovely sights assaulting his eyeballs.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.012
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.012
Problem:    ":let &shiftwidth = 'asdf'" doesn't produce an error message.
Solution:   Check for a string argument. (Chris Lubinski)
Files:	    src/option.c


*** ../vim-7.1.011/src/option.c	Sun May  6 15:37:32 2007
--- src/option.c	Tue Jun 19 20:56:36 2007
***************
*** 8219,8224 ****
--- 8219,8243 ----
  	    varp = get_varp(&options[opt_idx]);
  	    if (varp != NULL)	/* hidden option is not changed */
  	    {
+ 		if (number == 0 && string != NULL)
+ 		{
+ 		    int index;
+ 
+ 		    /* Either we are given a string or we are setting option
+ 		     * to zero. */
+ 		    for (index = 0; string[index] == '0'; ++index)
+ 			;
+ 		    if (string[index] != NUL || index == 0)
+ 		    {
+ 			/* There's another character after zeros or the string
+ 			 * is empty.  In both cases, we are trying to set a
+ 			 * num option using a string. */
+ 			EMSG3(_("E521: Number required: &%s = '%s'"),
+ 								name, string);
+ 			return;     /* do nothing as we hit an error */
+ 
+ 		    }
+ 		}
  		if (flags & P_NUM)
  		    (void)set_num_option(opt_idx, varp, number,
  							  NULL, 0, opt_flags);
*** ../vim-7.1.011/src/version.c	Tue Jun 19 20:30:46 2007
--- src/version.c	Tue Jun 19 20:53:15 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     12,
  /**/

-- 
Ten million Linux users can't be wrong!

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.013
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.013
Problem:    ":syn include" only loads the first file, while it is documented
	    as doing the equivalent of ":runtime!".
Solution:   Change the argument to source_runtime(). (James Vega)
Files:	    src/syntax.c


*** ../vim-7.1.012/src/syntax.c	Thu May 10 20:54:33 2007
--- src/syntax.c	Sun Jun 17 22:03:30 2007
***************
*** 4460,4467 ****
      current_syn_inc_tag = ++running_syn_inc_tag;
      prev_toplvl_grp = curbuf->b_syn_topgrp;
      curbuf->b_syn_topgrp = sgl_id;
!     if (source ? do_source(eap->arg, FALSE, FALSE) == FAIL
! 				: source_runtime(eap->arg, DOSO_NONE) == FAIL)
  	EMSG2(_(e_notopen), eap->arg);
      curbuf->b_syn_topgrp = prev_toplvl_grp;
      current_syn_inc_tag = prev_syn_inc_tag;
--- 4460,4467 ----
      current_syn_inc_tag = ++running_syn_inc_tag;
      prev_toplvl_grp = curbuf->b_syn_topgrp;
      curbuf->b_syn_topgrp = sgl_id;
!     if (source ? do_source(eap->arg, FALSE, DOSO_NONE) == FAIL
! 				: source_runtime(eap->arg, TRUE) == FAIL)
  	EMSG2(_(e_notopen), eap->arg);
      curbuf->b_syn_topgrp = prev_toplvl_grp;
      current_syn_inc_tag = prev_syn_inc_tag;
*** ../vim-7.1.012/src/version.c	Tue Jun 19 20:56:52 2007
--- src/version.c	Thu Jun 28 11:58:25 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     13,
  /**/

-- 
MORTICIAN:    What?
CUSTOMER:     Nothing -- here's your nine pence.
DEAD PERSON:  I'm not dead!
MORTICIAN:    Here -- he says he's not dead!
CUSTOMER:     Yes, he is.
DEAD PERSON:  I'm not!
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.014
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.014
Problem:    Crash when doing C indenting. (Chris Monson)
Solution:   Obtain the current line again after invoking cin_islabel().
Files:	    src/edit.c


*** ../vim-7.1.013/src/edit.c	Thu May 10 20:44:18 2007
--- src/edit.c	Wed Jun 20 18:25:54 2007
***************
*** 7215,7220 ****
--- 7215,7222 ----
  		p = ml_get_curline();
  		if (cin_iscase(p) || cin_isscopedecl(p) || cin_islabel(30))
  		    return TRUE;
+ 		/* Need to get the line again after cin_islabel(). */
+ 		p = ml_get_curline();
  		if (curwin->w_cursor.col > 2
  			&& p[curwin->w_cursor.col - 1] == ':'
  			&& p[curwin->w_cursor.col - 2] == ':')
*** ../vim-7.1.013/src/version.c	Thu Jun 28 11:59:13 2007
--- src/version.c	Thu Jun 28 12:26:52 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     14,
  /**/

-- 
Have you heard about the new Barbie doll?  It's called Divorce
Barbie.  It comes with all of Ken's stuff.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.015
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.015
Problem:    MzScheme interface: current-library-collection-paths produces no
	    list.  Interface doesn't build on a Mac.
Solution:   Use a list instead of a pair. (Bernhard Fisseni)  Use "-framework"
	    argument for MZSCHEME_LIBS in configure.
Files:	    src/configure.in, src/if_mzsch.c, src/auto/configure


*** ../vim-7.1.014/src/configure.in	Sat May 12 16:30:49 2007
--- src/configure.in	Sun Jun 10 16:47:43 2007
***************
*** 423,429 ****
    fi
  
    if test "X$vi_cv_path_mzscheme_pfx" != "X"; then
!     if test -f "${vi_cv_path_mzscheme_pfx}/lib/libmzgc.a"; then
        MZSCHEME_LIBS="${vi_cv_path_mzscheme_pfx}/lib/libmzscheme.a ${vi_cv_path_mzscheme_pfx}/lib/libmzgc.a"
      else
        MZSCHEME_LIBS="-L${vi_cv_path_mzscheme_pfx}/lib -lmzscheme -lmzgc"
--- 423,431 ----
    fi
  
    if test "X$vi_cv_path_mzscheme_pfx" != "X"; then
!     if test "x$MACOSX" = "xyes"; then
!       MZSCHEME_LIBS="-framework PLT_MzScheme"
!     elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libmzgc.a"; then
        MZSCHEME_LIBS="${vi_cv_path_mzscheme_pfx}/lib/libmzscheme.a ${vi_cv_path_mzscheme_pfx}/lib/libmzgc.a"
      else
        MZSCHEME_LIBS="-L${vi_cv_path_mzscheme_pfx}/lib -lmzscheme -lmzgc"
*** ../vim-7.1.014/src/if_mzsch.c	Sat May 12 17:29:20 2007
--- src/if_mzsch.c	Sun Jun 10 16:39:51 2007
***************
*** 773,780 ****
  #ifdef MZSCHEME_COLLECTS
      /* setup 'current-library-collection-paths' parameter */
      scheme_set_param(scheme_config, MZCONFIG_COLLECTION_PATHS,
! 	    scheme_make_pair(scheme_make_string(MZSCHEME_COLLECTS),
! 		scheme_null));
  #endif
  #ifdef HAVE_SANDBOX
      /* setup sandbox guards */
--- 773,779 ----
  #ifdef MZSCHEME_COLLECTS
      /* setup 'current-library-collection-paths' parameter */
      scheme_set_param(scheme_config, MZCONFIG_COLLECTION_PATHS,
! 	    scheme_build_list(0, scheme_make_string(MZSCHEME_COLLECTS)));
  #endif
  #ifdef HAVE_SANDBOX
      /* setup sandbox guards */
*** ../vim-7.1.014/src/auto/configure	Sat May 12 16:23:27 2007
--- src/auto/configure	Sun Jun 10 16:49:58 2007
***************
*** 3843,3849 ****
    fi
  
    if test "X$vi_cv_path_mzscheme_pfx" != "X"; then
!     if test -f "${vi_cv_path_mzscheme_pfx}/lib/libmzgc.a"; then
        MZSCHEME_LIBS="${vi_cv_path_mzscheme_pfx}/lib/libmzscheme.a ${vi_cv_path_mzscheme_pfx}/lib/libmzgc.a"
      else
        MZSCHEME_LIBS="-L${vi_cv_path_mzscheme_pfx}/lib -lmzscheme -lmzgc"
--- 3843,3851 ----
    fi
  
    if test "X$vi_cv_path_mzscheme_pfx" != "X"; then
!     if test "x$MACOSX" = "xyes"; then
!       MZSCHEME_LIBS="-framework PLT_MzScheme"
!     elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libmzgc.a"; then
        MZSCHEME_LIBS="${vi_cv_path_mzscheme_pfx}/lib/libmzscheme.a ${vi_cv_path_mzscheme_pfx}/lib/libmzgc.a"
      else
        MZSCHEME_LIBS="-L${vi_cv_path_mzscheme_pfx}/lib -lmzscheme -lmzgc"
*** ../vim-7.1.014/src/version.c	Thu Jun 28 12:44:56 2007
--- src/version.c	Thu Jun 28 13:00:52 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     15,
  /**/

-- 
You know you use Vim too much when you have this alias in your
~/.bashrc file: alias :e=/bin/vim             (Eljay Love-Jensen)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.016
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.016 (after patch 7.1.012)
Problem:    Error message about setting 'diff' to a string.
Solution:   Don't pass an empty string to set_option_value() when setting
	    'diff'.
Files:	    src/quickfix.c, src/popupmnu.c


*** ../vim-7.1.015/src/quickfix.c	Sun Feb  4 02:58:00 2007
--- src/quickfix.c	Thu Jun 28 18:56:16 2007
***************
*** 2331,2337 ****
  	    set_option_value((char_u *)"bt", 0L, (char_u *)"quickfix",
  								   OPT_LOCAL);
  	    set_option_value((char_u *)"bh", 0L, (char_u *)"wipe", OPT_LOCAL);
! 	    set_option_value((char_u *)"diff", 0L, (char_u *)"", OPT_LOCAL);
  	}
  
  	/* Only set the height when still in the same tab page and there is no
--- 2331,2337 ----
  	    set_option_value((char_u *)"bt", 0L, (char_u *)"quickfix",
  								   OPT_LOCAL);
  	    set_option_value((char_u *)"bh", 0L, (char_u *)"wipe", OPT_LOCAL);
! 	    set_option_value((char_u *)"diff", 0L, NULL, OPT_LOCAL);
  	}
  
  	/* Only set the height when still in the same tab page and there is no
*** ../vim-7.1.015/src/popupmnu.c	Tue Mar 27 12:42:05 2007
--- src/popupmnu.c	Thu Jun 28 19:00:51 2007
***************
*** 466,472 ****
  			set_option_value((char_u *)"bh", 0L,
  						 (char_u *)"wipe", OPT_LOCAL);
  			set_option_value((char_u *)"diff", 0L,
! 						     (char_u *)"", OPT_LOCAL);
  		    }
  		}
  		if (res == OK)
--- 466,472 ----
  			set_option_value((char_u *)"bh", 0L,
  						 (char_u *)"wipe", OPT_LOCAL);
  			set_option_value((char_u *)"diff", 0L,
! 							     NULL, OPT_LOCAL);
  		    }
  		}
  		if (res == OK)
*** ../vim-7.1.015/src/version.c	Thu Jun 28 13:02:22 2007
--- src/version.c	Thu Jun 28 21:20:20 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     16,
  /**/

-- 
We do not stumble over mountains, but over molehills.
				Confucius

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.017
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.017
Problem:    ":confirm w" does give a prompt when 'readonly' is set, but not
	    when the file permissions are read-only.  (Michael Schaap)
Solution:   Provide a dialog in both situations.  (Chris Lubinski)
Files:	    src/ex_cmds.c, src/fileio.c, src/proto/fileio.pro


*** ../vim-7.1.016/src/ex_cmds.c	Tue Jun 19 11:54:23 2007
--- src/ex_cmds.c	Tue Jun 19 22:37:25 2007
***************
*** 2912,2933 ****
  }
  
  /*
!  * Check if a buffer is read-only.  Ask for overruling in a dialog.
!  * Return TRUE and give an error message when the buffer is readonly.
   */
      static int
  check_readonly(forceit, buf)
      int		*forceit;
      buf_T	*buf;
  {
!     if (!*forceit && buf->b_p_ro)
      {
  #if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
  	if ((p_confirm || cmdmod.confirm) && buf->b_fname != NULL)
  	{
  	    char_u	buff[IOSIZE];
  
! 	    dialog_msg(buff, _("'readonly' option is set for \"%s\".\nDo you wish to write anyway?"),
  		    buf->b_fname);
  
  	    if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 2) == VIM_YES)
--- 2912,2946 ----
  }
  
  /*
!  * Check if a buffer is read-only (either 'readonly' option is set or file is
!  * read-only). Ask for overruling in a dialog. Return TRUE and give an error
!  * message when the buffer is readonly.
   */
      static int
  check_readonly(forceit, buf)
      int		*forceit;
      buf_T	*buf;
  {
!     struct stat	st;
! 
!     /* Handle a file being readonly when the 'readonly' option is set or when
!      * the file exists and permissions are read-only.
!      * We will send 0777 to check_file_readonly(), as the "perm" variable is
!      * important for device checks but not here. */
!     if (!*forceit && (buf->b_p_ro
! 		|| (mch_stat((char *)buf->b_ffname, &st) >= 0
! 		    && check_file_readonly(buf->b_ffname, 0777))))
      {
  #if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
  	if ((p_confirm || cmdmod.confirm) && buf->b_fname != NULL)
  	{
  	    char_u	buff[IOSIZE];
  
! 	    if (buf->b_p_ro)
! 		dialog_msg(buff, _("'readonly' option is set for \"%s\".\nDo you wish to write anyway?"),
! 		    buf->b_fname);
! 	    else
! 		dialog_msg(buff, _("File permissions of \"%s\" are read-only.\nIt may still be possible to write it.\nDo you wish to try?"),
  		    buf->b_fname);
  
  	    if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 2) == VIM_YES)
***************
*** 2941,2949 ****
--- 2954,2967 ----
  	}
  	else
  #endif
+ 	if (buf->b_p_ro)
  	    EMSG(_(e_readonly));
+ 	else
+ 	    EMSG2(_("E505: \"%s\" is read-only (add ! to override)"),
+ 		    buf->b_fname);
  	return TRUE;
      }
+ 
      return FALSE;
  }
  
*** ../vim-7.1.016/src/fileio.c	Thu May 10 19:32:17 2007
--- src/fileio.c	Thu Jun 28 21:54:18 2007
***************
*** 424,430 ****
  	 */
  	if (!p_odev && mch_nodetype(fname) == NODE_WRITABLE)
  	{
! 	    filemess(curbuf, fname, (char_u *)_("is a device (disabled with 'opendevice' option"), 0);
  	    msg_end();
  	    msg_scroll = msg_save;
  	    return FAIL;
--- 424,430 ----
  	 */
  	if (!p_odev && mch_nodetype(fname) == NODE_WRITABLE)
  	{
! 	    filemess(curbuf, fname, (char_u *)_("is a device (disabled with 'opendevice' option)"), 0);
  	    msg_end();
  	    msg_scroll = msg_save;
  	    return FAIL;
***************
*** 2734,2739 ****
--- 2734,2765 ----
  #endif
  
  /*
+  * Return TRUE if a file appears to be read-only from the file permissions.
+  */
+     int
+ check_file_readonly(fname, perm)
+     char_u	*fname;		/* full path to file */
+     int		perm;		/* known permissions on file */
+ {
+ #ifndef USE_MCH_ACCESS
+     int	    fd = 0;
+ #endif
+ 
+     return (
+ #ifdef USE_MCH_ACCESS
+ # ifdef UNIX
+ 	(perm & 0222) == 0 ||
+ # endif
+ 	mch_access((char *)fname, W_OK)
+ #else
+ 	(fd = mch_open((char *)fname, O_RDWR | O_EXTRA, 0)) < 0
+ 					? TRUE : (close(fd), FALSE)
+ #endif
+ 	);
+ }
+ 
+ 
+ /*
   * buf_write() - write to file "fname" lines "start" through "end"
   *
   * We do our own buffering here because fwrite() is so slow.
***************
*** 3219,3235 ****
  	 * Check if the file is really writable (when renaming the file to
  	 * make a backup we won't discover it later).
  	 */
! 	file_readonly = (
! # ifdef USE_MCH_ACCESS
! #  ifdef UNIX
! 		    (perm & 0222) == 0 ||
! #  endif
! 		    mch_access((char *)fname, W_OK)
! # else
! 		    (fd = mch_open((char *)fname, O_RDWR | O_EXTRA, 0)) < 0
! 						   ? TRUE : (close(fd), FALSE)
! # endif
! 		    );
  	if (!forceit && file_readonly)
  	{
  	    if (vim_strchr(p_cpo, CPO_FWRITE) != NULL)
--- 3245,3252 ----
  	 * Check if the file is really writable (when renaming the file to
  	 * make a backup we won't discover it later).
  	 */
! 	file_readonly = check_file_readonly(fname, (int)perm);
! 
  	if (!forceit && file_readonly)
  	{
  	    if (vim_strchr(p_cpo, CPO_FWRITE) != NULL)
*** ../vim-7.1.016/src/proto/fileio.pro	Sat May  5 19:59:00 2007
--- src/proto/fileio.pro	Thu Jun 28 21:09:59 2007
***************
*** 2,7 ****
--- 2,8 ----
  void filemess __ARGS((buf_T *buf, char_u *name, char_u *s, int attr));
  int readfile __ARGS((char_u *fname, char_u *sfname, linenr_T from, linenr_T lines_to_skip, linenr_T lines_to_read, exarg_T *eap, int flags));
  int prep_exarg __ARGS((exarg_T *eap, buf_T *buf));
+ int check_file_readonly __ARGS((char_u *fname, int perm));
  int buf_write __ARGS((buf_T *buf, char_u *fname, char_u *sfname, linenr_T start, linenr_T end, exarg_T *eap, int append, int forceit, int reset_changed, int filtering));
  void msg_add_fname __ARGS((buf_T *buf, char_u *fname));
  void msg_add_lines __ARGS((int insert_space, long lnum, long nchars));
*** ../vim-7.1.016/src/version.c	Thu Jun 28 21:23:52 2007
--- src/version.c	Thu Jun 28 21:49:29 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     17,
  /**/

-- 
CUSTOMER:     Well, can you hang around a couple of minutes?  He won't be
              long.
MORTICIAN:    Naaah, I got to go on to Robinson's -- they've lost nine today.
CUSTOMER:     Well, when is your next round?
MORTICIAN:    Thursday.
DEAD PERSON:  I think I'll go for a walk.
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.018
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.018
Problem:    When 'virtualedit' is set a "p" of a block just past the end of
	    the line inserts before the cursor. (Engelke)
Solution:   Check for the cursor being just after the line (Chris Lubinski)
Files:	    src/ops.c


*** ../vim-7.1.017/src/ops.c	Thu May 10 20:34:55 2007
--- src/ops.c	Tue Jun 19 22:40:45 2007
***************
*** 3404,3410 ****
  
  #ifdef FEAT_VIRTUALEDIT
  	col += curwin->w_cursor.coladd;
! 	if (ve_flags == VE_ALL && curwin->w_cursor.coladd > 0)
  	{
  	    if (dir == FORWARD && c == NUL)
  		++col;
--- 3404,3412 ----
  
  #ifdef FEAT_VIRTUALEDIT
  	col += curwin->w_cursor.coladd;
! 	if (ve_flags == VE_ALL
! 		&& (curwin->w_cursor.coladd > 0
! 		    || endcol2 == curwin->w_cursor.col))
  	{
  	    if (dir == FORWARD && c == NUL)
  		++col;
*** ../vim-7.1.017/src/version.c	Thu Jun 28 21:57:08 2007
--- src/version.c	Thu Jun 28 22:12:49 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     18,
  /**/

-- 
    [clop clop]
MORTICIAN:  Who's that then?
CUSTOMER:   I don't know.
MORTICIAN:  Must be a king.
CUSTOMER:   Why?
MORTICIAN:  He hasn't got shit all over him.
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.019
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.019
Problem:    ":py" asks for an argument, ":py asd" then gives the error that
	    ":py" isn't implemented.  Should already happen for ":py".
Solution:   Compare with ex_script_ni. (Chris Lubinski)
Files:	    src/ex_docmd.c


*** ../vim-7.1.018/src/ex_docmd.c	Thu May 10 18:53:03 2007
--- src/ex_docmd.c	Sat Jun 23 13:36:37 2007
***************
*** 2118,2124 ****
  #ifdef FEAT_USR_CMDS
  	    !USER_CMDIDX(ea.cmdidx) &&
  #endif
! 	    cmdnames[ea.cmdidx].cmd_func == ex_ni);
  
  #ifndef FEAT_EVAL
      /*
--- 2118,2125 ----
  #ifdef FEAT_USR_CMDS
  	    !USER_CMDIDX(ea.cmdidx) &&
  #endif
! 	    (cmdnames[ea.cmdidx].cmd_func == ex_ni
! 	     || cmdnames[ea.cmdidx].cmd_func == ex_script_ni));
  
  #ifndef FEAT_EVAL
      /*
*** ../vim-7.1.018/src/version.c	Thu Jun 28 22:14:28 2007
--- src/version.c	Thu Jul  5 09:48:11 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     19,
  /**/

-- 
MARTHA'S WAY: Don't throw out all that leftover wine. Freeze into ice cubes
              for future use in casseroles and sauces.
MY WAY:       What leftover wine?

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.020
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.020
Problem:    Reading from uninitialized memory when using a dialog. (Dominique
	    Pelle)
Solution:   In msg_show_console_dialog() append a NUL after every appended
	    character.
Files:	    src/message.c


*** ../vim-7.1.019/src/message.c	Thu May 10 18:49:39 2007
--- src/message.c	Sun Jul  1 12:06:52 2007
***************
*** 3456,3466 ****
  		    /* advance to next hotkey and set default hotkey */
  #ifdef FEAT_MBYTE
  		    if (has_mbyte)
! 			hotkp += (*mb_ptr2len)(hotkp);
  		    else
  #endif
  			++hotkp;
! 		    (void)copy_char(r + 1, hotkp, TRUE);
  		    if (dfltbutton)
  			--dfltbutton;
  
--- 3456,3466 ----
  		    /* advance to next hotkey and set default hotkey */
  #ifdef FEAT_MBYTE
  		    if (has_mbyte)
! 			hotkp += STRLEN(hotkp);
  		    else
  #endif
  			++hotkp;
! 		    hotkp[copy_char(r + 1, hotkp, TRUE)] = NUL;
  		    if (dfltbutton)
  			--dfltbutton;
  
***************
*** 3493,3499 ****
  			*msgp++ = (dfltbutton == 1) ? ']' : ')';
  
  			/* redefine hotkey */
! 			(void)copy_char(r, hotkp, TRUE);
  		    }
  		}
  		else
--- 3493,3499 ----
  			*msgp++ = (dfltbutton == 1) ? ']' : ')';
  
  			/* redefine hotkey */
! 			hotkp[copy_char(r, hotkp, TRUE)] = NUL;
  		    }
  		}
  		else
***************
*** 3519,3526 ****
  	    *msgp++ = ':';
  	    *msgp++ = ' ';
  	    *msgp = NUL;
- 	    mb_ptr_adv(hotkp);
- 	    *hotkp = NUL;
  	}
  	else
  	{
--- 3519,3524 ----
***************
*** 3555,3562 ****
  	    msgp = confirm_msg + 1 + STRLEN(message);
  	    hotkp = hotk;
  
! 	    /* define first default hotkey */
! 	    (void)copy_char(buttons, hotkp, TRUE);
  
  	    /* Remember where the choices start, displaying starts here when
  	     * "hotkp" typed at the more prompt. */
--- 3553,3561 ----
  	    msgp = confirm_msg + 1 + STRLEN(message);
  	    hotkp = hotk;
  
! 	    /* Define first default hotkey.  Keep the hotkey string NUL
! 	     * terminated to avoid reading past the end. */
! 	    hotkp[copy_char(buttons, hotkp, TRUE)] = NUL;
  
  	    /* Remember where the choices start, displaying starts here when
  	     * "hotkp" typed at the more prompt. */
*** ../vim-7.1.019/src/version.c	Thu Jul  5 09:53:20 2007
--- src/version.c	Thu Jul  5 10:09:34 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     20,
  /**/

-- 
BLACK KNIGHT:  Come on you pansy!
    [hah] [parry thrust]
    [ARTHUR chops the BLACK KNIGHT's right arm off]
ARTHUR:        Victory is mine!  [kneeling]
               We thank thee Lord, that in thy merc-
    [Black Knight kicks Arthur in the head while he is praying]
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.021
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.021 (after 7.1.015)
Problem:    Mzscheme interface doesn't compile on Win32.
Solution:   Fix the problem that 7.1.015 fixed in a better way. (Sergey Khorev)
Files:	    src/if_mzsch.c


*** ../vim-7.1.020/src/if_mzsch.c	Thu Jun 28 13:02:22 2007
--- src/if_mzsch.c	Sun Jul  1 18:44:49 2007
***************
*** 308,313 ****
--- 308,315 ----
  static Scheme_Config *(*dll_scheme_current_config)(void);
  static Scheme_Object *(*dll_scheme_char_string_to_byte_string)
      (Scheme_Object *s);
+ static Scheme_Object *(*dll_scheme_char_string_to_path)
+     (Scheme_Object *s);
  # endif
  
  /* arrays are imported directly */
***************
*** 398,403 ****
--- 400,407 ----
  #  define scheme_current_config dll_scheme_current_config
  #  define scheme_char_string_to_byte_string \
      dll_scheme_char_string_to_byte_string
+ #  define scheme_char_string_to_path \
+     dll_scheme_char_string_to_path
  # endif
  
  typedef struct
***************
*** 498,503 ****
--- 502,509 ----
      {"scheme_current_config", (void **)&dll_scheme_current_config},
      {"scheme_char_string_to_byte_string",
  	(void **)&dll_scheme_char_string_to_byte_string},
+     {"scheme_char_string_to_path",
+ 	(void **)&dll_scheme_char_string_to_path},
  # endif
      {NULL, NULL}};
  
***************
*** 773,779 ****
  #ifdef MZSCHEME_COLLECTS
      /* setup 'current-library-collection-paths' parameter */
      scheme_set_param(scheme_config, MZCONFIG_COLLECTION_PATHS,
! 	    scheme_build_list(0, scheme_make_string(MZSCHEME_COLLECTS)));
  #endif
  #ifdef HAVE_SANDBOX
      /* setup sandbox guards */
--- 779,793 ----
  #ifdef MZSCHEME_COLLECTS
      /* setup 'current-library-collection-paths' parameter */
      scheme_set_param(scheme_config, MZCONFIG_COLLECTION_PATHS,
! 	    scheme_make_pair(
! # if MZSCHEME_VERSION_MAJOR >= 299
! 		scheme_char_string_to_path(
! 		    scheme_byte_string_to_char_string(
! 			scheme_make_byte_string(MZSCHEME_COLLECTS))),
! # else
! 		scheme_make_string(MZSCHEME_COLLECTS),
! # endif
! 		scheme_null));
  #endif
  #ifdef HAVE_SANDBOX
      /* setup sandbox guards */
*** ../vim-7.1.020/src/version.c	Thu Jul  5 10:10:29 2007
--- src/version.c	Fri Jul  6 19:41:04 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     21,
  /**/

-- 
Advice to worms:  Sleep late.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.022
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.022
Problem:    When setting 'keymap' twice the b:keymap_name variable isn't set.
            (Milan Berta)
Solution:   Don't unlet b:keymap_name for ":loadkeymap". (Martin Toft)
Files:      src/digraph.c


*** ../vim-7.1.021/src/digraph.c	Wed May  3 00:07:11 2006
--- src/digraph.c	Mon Jul  2 21:24:30 2007
***************
*** 2349,2356 ****
  
      if (*curbuf->b_p_keymap == NUL)
      {
! 	/* Stop any active keymap and clear the table. */
  	keymap_unload();
      }
      else
      {
--- 2349,2358 ----
  
      if (*curbuf->b_p_keymap == NUL)
      {
! 	/* Stop any active keymap and clear the table.  Also remove
! 	 * b:keymap_unload, as no keymap is active now. */
  	keymap_unload();
+ 	do_cmdline_cmd((char_u *)"unlet! b:keymap_name");
      }
      else
      {
***************
*** 2500,2506 ****
  
      ga_clear(&curbuf->b_kmap_ga);
      curbuf->b_kmap_state &= ~KEYMAP_LOADED;
-     do_cmdline_cmd((char_u *)"unlet! b:keymap_name");
  #ifdef FEAT_WINDOWS
      status_redraw_curbuf();
  #endif
--- 2502,2507 ----
*** ../vim-7.1.021/src/version.c	Fri Jul  6 19:42:09 2007
--- src/version.c	Sat Jul  7 13:56:52 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     22,
  /**/

-- 
If your life is a hard drive,
Christ can be your backup.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.023
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.023
Problem:    "dw" in a line with one character deletes the line.  Vi and nvi
	    don't do this.  (Kjell Arne Rekaa)
Solution:   Check for one-character words especially.
Files:	    src/search.c


*** ../vim-7.1.022/src/search.c	Tue Jun 19 12:58:55 2007
--- src/search.c	Thu Jul  5 21:18:55 2007
***************
*** 2795,2801 ****
  	i = inc_cursor();
  	if (i == -1 || (i >= 1 && last_line)) /* started at last char in file */
  	    return FAIL;
! 	if (i == 1 && eol && count == 0)      /* started at last char in line */
  	    return OK;
  
  	/*
--- 2802,2808 ----
  	i = inc_cursor();
  	if (i == -1 || (i >= 1 && last_line)) /* started at last char in file */
  	    return FAIL;
! 	if (i >= 1 && eol && count == 0)      /* started at last char in line */
  	    return OK;
  
  	/*
*** ../vim-7.1.022/src/version.c	Sat Jul  7 13:57:39 2007
--- src/version.c	Tue Jul 10 12:35:36 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     23,
  /**/

-- 
BRIDGEKEEPER: What is your favorite editor?
GAWAIN:       Emacs ...  No, Viiiiiiiiiiimmmmmmm!
           "Monty Python and the Holy editor wars" PYTHON (MONTY) SOFTWARE LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.024
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.024
Problem:    Using a pointer that has become invalid. (Chris Monson)
Solution:   Obtain the line pointer again after we looked at another line.
Files:	    src/search.c


*** ../vim-7.1.023/src/search.c	Tue Jul 10 12:36:51 2007
--- src/search.c	Thu Jul  5 21:18:55 2007
***************
*** 2124,2129 ****
--- 2128,2136 ----
  			else if (!backwards)
  			    inquote = TRUE;
  		    }
+ 
+ 		    /* ml_get() only keeps one line, need to get linep again */
+ 		    linep = ml_get(pos.lnum);
  		}
  	    }
  	}
*** ../vim-7.1.023/src/version.c	Tue Jul 10 12:36:51 2007
--- src/version.c	Tue Jul 10 13:06:02 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     24,
  /**/

-- 
Q: Why does /dev/null accept only integers?
A: You can't sink a float.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.025
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.025
Problem:    search() and searchpos() don't use match under cursor at start of
	    line when using 'bc' flags. (Viktor Kojouharov)
Solution:   Don't go to the previous line when the 'c' flag is present.
	    Also fix that "j" doesn't move the cursor to the right column.
Files:	    src/eval.c, src/search.c


*** ../vim-7.1.024/src/eval.c	Tue Jun 19 17:23:46 2007
--- src/eval.c	Thu Jul  5 21:16:31 2007
***************
*** 13925,13930 ****
--- 13925,13932 ----
      /* If 'n' flag is used: restore cursor position. */
      if (flags & SP_NOMOVE)
  	curwin->w_cursor = save_cursor;
+     else
+ 	curwin->w_set_curswant = TRUE;
  theend:
      p_ws = save_p_ws;
  
*** ../vim-7.1.024/src/search.c	Tue Jul 10 13:07:08 2007
--- src/search.c	Thu Jul  5 21:18:55 2007
***************
*** 573,580 ****
  	/*
  	 * Start searching in current line, unless searching backwards and
  	 * we're in column 0.
  	 */
! 	if (dir == BACKWARD && start_pos.col == 0)
  	{
  	    lnum = pos->lnum - 1;
  	    at_first_line = FALSE;
--- 573,584 ----
  	/*
  	 * Start searching in current line, unless searching backwards and
  	 * we're in column 0.
+ 	 * If we are searching backwards, in column 0, and not including the
+ 	 * current position, gain some efficiency by skipping back a line.
+ 	 * Otherwise begin the search in the current line.
  	 */
! 	if (dir == BACKWARD && start_pos.col == 0
! 					     && (options & SEARCH_START) == 0)
  	{
  	    lnum = pos->lnum - 1;
  	    at_first_line = FALSE;
*** ../vim-7.1.024/src/version.c	Tue Jul 10 13:07:08 2007
--- src/version.c	Tue Jul 10 13:26:13 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     25,
  /**/

-- 
SIGFUN -- signature too funny (core dumped)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.026
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.026
Problem:    "[p" doesn't work in Visual mode. (David Brown)
Solution:   Use checkclearop() instead of checkclearopq().
Files:	    src/normal.c


*** ../vim-7.1.025/src/normal.c	Thu May 10 18:45:26 2007
--- src/normal.c	Wed Jul  4 21:16:36 2007
***************
*** 6379,6385 ****
       */
      else if (cap->nchar == 'p' || cap->nchar == 'P')
      {
! 	if (!checkclearopq(cap->oap))
  	{
  	    prep_redo_cmd(cap);
  	    do_put(cap->oap->regname,
--- 6379,6385 ----
       */
      else if (cap->nchar == 'p' || cap->nchar == 'P')
      {
! 	if (!checkclearop(cap->oap))
  	{
  	    prep_redo_cmd(cap);
  	    do_put(cap->oap->regname,
*** ../vim-7.1.025/src/version.c	Tue Jul 10 13:27:46 2007
--- src/version.c	Tue Jul 10 14:01:52 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     26,
  /**/

-- 
BRIDGEKEEPER: What is the air-speed velocity of an unladen swallow?
ARTHUR:       What do you mean?  An African or European swallow?
BRIDGEKEEPER: Er ...  I don't know that ... Aaaaarrrrrrggghhh!
   BRIDGEKEEPER is cast into the gorge.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.027
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.027
Problem:    On Sun systems opening /dev/fd/N doesn't work, and they are used
	    by process substitutions.
Solution:   Allow opening specific character special files for Sun systems.
	    (Gary Johnson)
Files:	    src/fileio.c, src/os_unix.h


*** ../vim-7.1.026/src/fileio.c	Thu Jun 28 21:57:08 2007
--- src/fileio.c	Mon Jul  9 11:19:50 2007
***************
*** 44,49 ****
--- 44,53 ----
  /* Is there any system that doesn't have access()? */
  #define USE_MCH_ACCESS
  
+ #if defined(sun) && defined(S_ISCHR)
+ # define OPEN_CHR_FILES
+ static int is_dev_fd_file(char_u *fname);
+ #endif
  #ifdef FEAT_MBYTE
  static char_u *next_fenc __ARGS((char_u **pp));
  # ifdef FEAT_EVAL
***************
*** 406,411 ****
--- 410,419 ----
  # ifdef S_ISSOCK
  		      && !S_ISSOCK(perm)	    /* ... or socket */
  # endif
+ # ifdef OPEN_CHR_FILES
+ 		      && !(S_ISCHR(perm) && is_dev_fd_file(fname))
+ 			/* ... or a character special file named /dev/fd/<n> */
+ # endif
  						)
  	{
  	    if (S_ISDIR(perm))
***************
*** 2265,2270 ****
--- 2273,2285 ----
  	    }
  #  endif
  # endif
+ # ifdef OPEN_CHR_FILES
+ 	    if (S_ISCHR(perm))			    /* or character special */
+ 	    {
+ 		STRCAT(IObuff, _("[character special]"));
+ 		c = TRUE;
+ 	    }
+ # endif
  #endif
  	    if (curbuf->b_p_ro)
  	    {
***************
*** 2463,2468 ****
--- 2478,2502 ----
  	return FAIL;
      return OK;
  }
+ 
+ #ifdef OPEN_CHR_FILES
+ /*
+  * Returns TRUE if the file name argument is of the form "/dev/fd/\d\+",
+  * which is the name of files used for process substitution output by
+  * some shells on some operating systems, e.g., bash on SunOS.
+  * Do not accept "/dev/fd/[012]", opening these may hang Vim.
+  */
+     static int
+ is_dev_fd_file(fname)
+     char_u	*fname;
+ {
+     return (STRNCMP(fname, "/dev/fd/", 8) == 0
+ 	    && VIM_ISDIGIT(fname[8])
+ 	    && *skipdigits(fname + 9) == NUL
+ 	    && (fname[9] != NUL
+ 		|| (fname[8] != '0' && fname[8] != '1' && fname[8] != '2')));
+ }
+ #endif
  
  #ifdef FEAT_MBYTE
  
*** ../vim-7.1.026/src/os_unix.h	Thu May 10 19:43:10 2007
--- src/os_unix.h	Sat Jul  7 13:08:56 2007
***************
*** 508,513 ****
--- 508,516 ----
  #if !defined(S_ISFIFO) && defined(S_IFIFO)
  # define	S_ISFIFO(m) (((m) & S_IFMT) == S_IFIFO)
  #endif
+ #if !defined(S_ISCHR) && defined(S_IFCHR)
+ # define	S_ISCHR(m) (((m) & S_IFMT) == S_IFCHR)
+ #endif
  
  /* Note: Some systems need both string.h and strings.h (Savage).  However,
   * some systems can't handle both, only use string.h in that case. */
*** ../vim-7.1.026/src/version.c	Tue Jul 10 14:02:51 2007
--- src/version.c	Tue Jul 10 17:00:43 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     27,
  /**/

-- 
Every exit is an entrance into something else.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.028
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.028
Problem:    Can't use last search pattern for ":sort". (Brian McKee)
Solution:   When the pattern is emtpy use the last search pattern. (Martin
	    Toft)
Files:	    runtime/doc/change.txt, src/ex_cmds.c


*** ../vim-7.1.027/runtime/doc/change.txt	Sat May 12 16:10:12 2007
--- runtime/doc/change.txt	Tue Jul 10 11:30:56 2007
***************
*** 1571,1576 ****
--- 1571,1580 ----
  			in their original order, right before the sorted
  			lines.
  
+ 			If {pattern} is empty (e.g. // is specified), the
+ 			last search pattern is used.  This allows trying out
+ 			a pattern first.
+ 
  Note that using ":sort" with ":global" doesn't sort the matching lines, it's
  quite useless.
  
*** ../vim-7.1.027/src/ex_cmds.c	Thu Jun 28 21:57:08 2007
--- src/ex_cmds.c	Tue Jul 10 17:25:10 2007
***************
*** 408,414 ****
  		goto sortend;
  	    }
  	    *s = NUL;
! 	    regmatch.regprog = vim_regcomp(p + 1, RE_MAGIC);
  	    if (regmatch.regprog == NULL)
  		goto sortend;
  	    p = s;		/* continue after the regexp */
--- 408,418 ----
  		goto sortend;
  	    }
  	    *s = NUL;
! 	    /* Use last search pattern if sort pattern is empty. */
! 	    if (s == p + 1 && last_search_pat() != NULL)
! 		regmatch.regprog = vim_regcomp(last_search_pat(), RE_MAGIC);
! 	    else
! 		regmatch.regprog = vim_regcomp(p + 1, RE_MAGIC);
  	    if (regmatch.regprog == NULL)
  		goto sortend;
  	    p = s;		/* continue after the regexp */
*** ../vim-7.1.027/src/version.c	Tue Jul 10 17:09:51 2007
--- src/version.c	Tue Jul 10 17:20:01 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     28,
  /**/

-- 
Every person is responsible for the choices he makes.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.029
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.029 (after 7.1.019)
Problem:    Can't compile when all interfaces are used. (Taylor Venable)
Solution:   Only check for ex_script_ni when it's defined.
Files:	    src/ex_docmd.c


*** ../vim-7.1.028/src/ex_docmd.c	Thu Jul  5 09:53:20 2007
--- src/ex_docmd.c	Sun Jul 15 17:20:09 2007
***************
*** 133,138 ****
--- 133,139 ----
  static void	get_flags __ARGS((exarg_T *eap));
  #if !defined(FEAT_PERL) || !defined(FEAT_PYTHON) || !defined(FEAT_TCL) \
  	|| !defined(FEAT_RUBY) || !defined(FEAT_MZSCHEME)
+ # define HAVE_EX_SCRIPT_NI
  static void	ex_script_ni __ARGS((exarg_T *eap));
  #endif
  static char_u	*invalid_range __ARGS((exarg_T *eap));
***************
*** 2119,2125 ****
  	    !USER_CMDIDX(ea.cmdidx) &&
  #endif
  	    (cmdnames[ea.cmdidx].cmd_func == ex_ni
! 	     || cmdnames[ea.cmdidx].cmd_func == ex_script_ni));
  
  #ifndef FEAT_EVAL
      /*
--- 2120,2129 ----
  	    !USER_CMDIDX(ea.cmdidx) &&
  #endif
  	    (cmdnames[ea.cmdidx].cmd_func == ex_ni
! #ifdef HAVE_EX_SCRIPT_NI
! 	     || cmdnames[ea.cmdidx].cmd_func == ex_script_ni
! #endif
! 	     ));
  
  #ifndef FEAT_EVAL
      /*
***************
*** 3998,4005 ****
  	eap->errmsg = (char_u *)N_("E319: Sorry, the command is not available in this version");
  }
  
! #if !defined(FEAT_PERL) || !defined(FEAT_PYTHON) || !defined(FEAT_TCL) \
! 	|| !defined(FEAT_RUBY) || !defined(FEAT_MZSCHEME)
  /*
   * Function called for script command which is Not Implemented.  NI!
   * Skips over ":perl <<EOF" constructs.
--- 3999,4005 ----
  	eap->errmsg = (char_u *)N_("E319: Sorry, the command is not available in this version");
  }
  
! #ifdef HAVE_EX_SCRIPT_NI
  /*
   * Function called for script command which is Not Implemented.  NI!
   * Skips over ":perl <<EOF" constructs.
*** ../vim-7.1.028/src/version.c	Tue Jul 10 17:25:20 2007
--- src/version.c	Mon Jul 16 20:37:48 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     29,
  /**/

-- 
I used to wonder about the meaning of life.  But I looked it
up in the dictionary under "L" and there it was - the meaning
of life.  It was less than I expected.              - Dogbert

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.030
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.030
Problem:    The "vimtutor" shell script checks for "vim6" but not for "vim7".
	    (Christian Robinson)
Solution:   Check for more versions, but prefer using "vim".
Files:	    src/vimtutor


*** ../vim-7.1.029/src/vimtutor	Sun Jun 13 20:37:33 2004
--- src/vimtutor	Sun Jul  8 17:16:29 2007
***************
*** 39,56 ****
  # remove the copy of the tutor on exit
  trap "rm -rf $TODELETE" 0 1 2 3 9 11 13 15
  
! # Vim could be called "vim" or "vi".  Also check for "vim6", for people who
! # have Vim 5.x installed as "vim" and Vim 6.0 as "vim6".
! testvim=`which vim6 2>/dev/null`
! if test -f "$testvim"; then
! 	VIM=vim6
! else
! 	testvim=`which vim`
  	if test -f "$testvim"; then
! 		VIM=vim
! 	else
! 		VIM=vi
  	fi
  fi
  
  # Use Vim to copy the tutor, it knows the value of $VIMRUNTIME
--- 39,60 ----
  # remove the copy of the tutor on exit
  trap "rm -rf $TODELETE" 0 1 2 3 9 11 13 15
  
! # Vim could be called "vim" or "vi".  Also check for "vimN", for people who
! # have Vim installed with its version number.
! # We anticipate up to a future Vim 8 version :-).
! seq="vim vim8 vim75 vim74 vim73 vim72 vim71 vim70 vim7 vim6 vi"
! for i in $seq; do
! 	testvim=`which $i 2>/dev/null`
  	if test -f "$testvim"; then
! 		VIM=$i
! 		break
  	fi
+ done
+ 
+ # When no Vim version was found fall back to "vim", you'll get an error message
+ # below.
+ if test -z "$VIM"; then
+ 	VIM=vim
  fi
  
  # Use Vim to copy the tutor, it knows the value of $VIMRUNTIME
*** ../vim-7.1.029/src/version.c	Mon Jul 16 20:38:56 2007
--- src/version.c	Tue Jul 17 14:30:51 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     30,
  /**/

-- 
BLACK KNIGHT: I'm invincible!
ARTHUR:       You're a looney.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.031
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.031
Problem:    virtcol([123, '$']) doesn't work. (Michael Schaap)
Solution:   When '$' is used for the column number get the last column.
Files:	    runtime/doc/eval.txt, src/eval.c


*** ../vim-7.1.030/runtime/doc/eval.txt	Tue Jun 19 17:23:46 2007
--- runtime/doc/eval.txt	Wed Jul 11 21:21:28 2007
***************
*** 1,4 ****
! *eval.txt*      For Vim version 7.1.  Last change: 2007 Jun 09
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
--- 1,4 ----
! *eval.txt*      For Vim version 7.1.  Last change: 2007 Jul 11
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
***************
*** 2020,2025 ****
--- 2020,2029 ----
  			    number of characters in the cursor line plus one)
  		    'x	    position of mark x (if the mark is not set, 0 is
  			    returned)
+ 		Additionally {expr} can be [lnum, col]: a |List| with the line
+ 		and column number. Most useful when the column is "$", to get
+ 		the las column of a specific line.  When "lnum" or "col" is
+ 		out of range then col() returns zero.
  		To get the line number use |line()|.  To get both use
  		|getpos()|.
  		For the screen column position use |virtcol()|.
***************
*** 5024,5037 ****
  		position, the returned Number will be the column at the end of
  		the <Tab>.  For example, for a <Tab> in column 1, with 'ts'
  		set to 8, it returns 8.
! 		For the use of {expr} see |col()|.  Additionally you can use
! 		[lnum, col]: a |List| with the line and column number.  When
! 		"lnum" or "col" is out of range then virtcol() returns zero.
! 		When 'virtualedit' is used it can be [lnum, col, off], where
  		"off" is the offset in screen columns from the start of the
  		character.  E.g., a position within a <Tab> or after the last
  		character.
- 		For the byte position use |col()|.
  		When Virtual editing is active in the current mode, a position
  		beyond the end of the line can be returned. |'virtualedit'|
  		The accepted positions are:
--- 5029,5040 ----
  		position, the returned Number will be the column at the end of
  		the <Tab>.  For example, for a <Tab> in column 1, with 'ts'
  		set to 8, it returns 8.
! 		For the byte position use |col()|.
! 		For the use of {expr} see |col()|.
! 		When 'virtualedit' is used {expr} can be [lnum, col, off], where
  		"off" is the offset in screen columns from the start of the
  		character.  E.g., a position within a <Tab> or after the last
  		character.
  		When Virtual editing is active in the current mode, a position
  		beyond the end of the line can be returned. |'virtualedit'|
  		The accepted positions are:
*** ../vim-7.1.030/src/eval.c	Tue Jul 10 13:27:46 2007
--- src/eval.c	Wed Jul 11 19:50:27 2007
***************
*** 672,678 ****
  static void f_writefile __ARGS((typval_T *argvars, typval_T *rettv));
  
  static int list2fpos __ARGS((typval_T *arg, pos_T *posp, int *fnump));
! static pos_T *var2fpos __ARGS((typval_T *varp, int lnum, int *fnum));
  static int get_env_len __ARGS((char_u **arg));
  static int get_id_len __ARGS((char_u **arg));
  static int get_name_len __ARGS((char_u **arg, char_u **alias, int evaluate, int verbose));
--- 672,678 ----
  static void f_writefile __ARGS((typval_T *argvars, typval_T *rettv));
  
  static int list2fpos __ARGS((typval_T *arg, pos_T *posp, int *fnump));
! static pos_T *var2fpos __ARGS((typval_T *varp, int dollar_lnum, int *fnum));
  static int get_env_len __ARGS((char_u **arg));
  static int get_id_len __ARGS((char_u **arg));
  static int get_name_len __ARGS((char_u **arg, char_u **alias, int evaluate, int verbose));
***************
*** 16505,16513 ****
   * Returns NULL when there is an error.
   */
      static pos_T *
! var2fpos(varp, lnum, fnum)
      typval_T	*varp;
!     int		lnum;		/* TRUE when $ is last line */
      int		*fnum;		/* set to fnum for '0, 'A, etc. */
  {
      char_u		*name;
--- 16508,16516 ----
   * Returns NULL when there is an error.
   */
      static pos_T *
! var2fpos(varp, dollar_lnum, fnum)
      typval_T	*varp;
!     int		dollar_lnum;	/* TRUE when $ is last line */
      int		*fnum;		/* set to fnum for '0, 'A, etc. */
  {
      char_u		*name;
***************
*** 16520,16525 ****
--- 16523,16529 ----
  	list_T		*l;
  	int		len;
  	int		error = FALSE;
+ 	listitem_T	*li;
  
  	l = varp->vval.v_list;
  	if (l == NULL)
***************
*** 16535,16540 ****
--- 16539,16552 ----
  	if (error)
  	    return NULL;
  	len = (long)STRLEN(ml_get(pos.lnum));
+ 
+ 	/* We accept "$" for the column number: last column. */
+ 	li = list_find(l, 1L);
+ 	if (li != NULL && li->li_tv.v_type == VAR_STRING
+ 		&& li->li_tv.vval.v_string != NULL
+ 		&& STRCMP(li->li_tv.vval.v_string, "$") == 0)
+ 	    pos.col = len + 1;
+ 
  	/* Accept a position up to the NUL after the line. */
  	if (pos.col == 0 || (int)pos.col > len + 1)
  	    return NULL;	/* invalid column number */
***************
*** 16567,16573 ****
      pos.coladd = 0;
  #endif
  
!     if (name[0] == 'w' && lnum)
      {
  	pos.col = 0;
  	if (name[1] == '0')		/* "w0": first visible line */
--- 16579,16585 ----
      pos.coladd = 0;
  #endif
  
!     if (name[0] == 'w' && dollar_lnum)
      {
  	pos.col = 0;
  	if (name[1] == '0')		/* "w0": first visible line */
***************
*** 16585,16591 ****
      }
      else if (name[0] == '$')		/* last column or line */
      {
! 	if (lnum)
  	{
  	    pos.lnum = curbuf->b_ml.ml_line_count;
  	    pos.col = 0;
--- 16597,16603 ----
      }
      else if (name[0] == '$')		/* last column or line */
      {
! 	if (dollar_lnum)
  	{
  	    pos.lnum = curbuf->b_ml.ml_line_count;
  	    pos.col = 0;
*** ../vim-7.1.030/src/version.c	Tue Jul 17 14:32:07 2007
--- src/version.c	Tue Jul 17 16:24:54 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     31,
  /**/

-- 
CRONE:  Who sent you?
ARTHUR: The Knights Who Say GNU!
CRONE:  Aaaagh!  (she looks around in rear) No!  We have no licenses here.
           "Monty Python and the Holy editor wars" PYTHON (MONTY) SOFTWARE LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.032
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.032
Problem:    Potential crash when editing a command line. (Chris Monson)
Solution:   Check the position to avoid access before the start of an array.
Files:	    src/ex_getln.c


*** ../vim-7.1.031/src/ex_getln.c	Thu May 10 20:22:29 2007
--- src/ex_getln.c	Tue Jul 17 18:05:49 2007
***************
*** 484,490 ****
  	if (xpc.xp_context == EXPAND_MENUNAMES && p_wmnu)
  	{
  	    /* Hitting <Down> after "emenu Name.": complete submenu */
! 	    if (ccline.cmdbuff[ccline.cmdpos - 1] == '.' && c == K_DOWN)
  		c = p_wc;
  	    else if (c == K_UP)
  	    {
--- 486,493 ----
  	if (xpc.xp_context == EXPAND_MENUNAMES && p_wmnu)
  	{
  	    /* Hitting <Down> after "emenu Name.": complete submenu */
! 	    if (c == K_DOWN && ccline.cmdpos > 0
! 				  && ccline.cmdbuff[ccline.cmdpos - 1] == '.')
  		c = p_wc;
  	    else if (c == K_UP)
  	    {
***************
*** 533,541 ****
  	    upseg[3] = PATHSEP;
  	    upseg[4] = NUL;
  
! 	    if (ccline.cmdbuff[ccline.cmdpos - 1] == PATHSEP
! 		    && c == K_DOWN
! 		    && (ccline.cmdbuff[ccline.cmdpos - 2] != '.'
  			|| ccline.cmdbuff[ccline.cmdpos - 3] != '.'))
  	    {
  		/* go down a directory */
--- 536,546 ----
  	    upseg[3] = PATHSEP;
  	    upseg[4] = NUL;
  
! 	    if (c == K_DOWN
! 		    && ccline.cmdpos > 0
! 		    && ccline.cmdbuff[ccline.cmdpos - 1] == PATHSEP
! 		    && (ccline.cmdpos < 3
! 			|| ccline.cmdbuff[ccline.cmdpos - 2] != '.'
  			|| ccline.cmdbuff[ccline.cmdpos - 3] != '.'))
  	    {
  		/* go down a directory */
***************
*** 730,737 ****
  	    /* In Ex mode a backslash escapes a newline. */
  	    if (exmode_active
  		    && c != ESC
- 		    && ccline.cmdpos > 0
  		    && ccline.cmdpos == ccline.cmdlen
  		    && ccline.cmdbuff[ccline.cmdpos - 1] == '\\')
  	    {
  		if (c == K_KENTER)
--- 735,742 ----
  	    /* In Ex mode a backslash escapes a newline. */
  	    if (exmode_active
  		    && c != ESC
  		    && ccline.cmdpos == ccline.cmdlen
+ 		    && ccline.cmdpos > 0
  		    && ccline.cmdbuff[ccline.cmdpos - 1] == '\\')
  	    {
  		if (c == K_KENTER)
*** ../vim-7.1.031/src/version.c	Tue Jul 17 16:31:15 2007
--- src/version.c	Tue Jul 17 18:10:37 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     32,
  /**/

-- 
ALL:   A witch!  A witch!
WITCH: It's a fair cop.
ALL:   Burn her!  Burn her!  Let's make her into a ladder.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.033
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.033
Problem:    A buffer is marked modified when it was first deleted and then
	    added again using a ":next" command. (John Mullin)
Solution:   When checking if a buffer is modified use the BF_NEVERLOADED flag.
Files:	    src/option.c


*** ../vim-7.1.032/src/option.c	Tue Jun 19 20:56:52 2007
--- src/option.c	Sun Jul 22 16:42:47 2007
***************
*** 10624,10629 ****
--- 10624,10632 ----
  file_ff_differs(buf)
      buf_T	*buf;
  {
+     /* In a buffer that was never loaded the options are not valid. */
+     if (buf->b_flags & BF_NEVERLOADED)
+ 	return FALSE;
      if ((buf->b_flags & BF_NEW)
  	    && buf->b_ml.ml_line_count == 1
  	    && *ml_get_buf(buf, (linenr_T)1, FALSE) == NUL)
*** ../vim-7.1.032/src/version.c	Tue Jul 17 18:14:14 2007
--- src/version.c	Mon Jul 23 09:45:44 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     33,
  /**/

-- 
How To Keep A Healthy Level Of Insanity:
8. Don't use any punctuation marks.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.034
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.034
Problem:    Win64: A few compiler warnings.  Problems with optimizer.
Solution:   Use int instead of size_t.  Disable the optimizer in one function.
	    (George V.  Reilly)
Files:	    src/eval.c, src/spell.c


*** ../vim-7.1.033/src/eval.c	Tue Jul 17 16:31:15 2007
--- src/eval.c	Wed Jul 11 19:50:27 2007
***************
*** 992,1011 ****
      char_u	*value;
      int		value_len;
  {
!     size_t	len;
  
      if (redir_lval == NULL)
  	return;
  
      if (value_len == -1)
! 	len = STRLEN(value);	/* Append the entire string */
      else
! 	len = value_len;	/* Append only "value_len" characters */
  
!     if (ga_grow(&redir_ga, (int)len) == OK)
      {
  	mch_memmove((char *)redir_ga.ga_data + redir_ga.ga_len, value, len);
! 	redir_ga.ga_len += (int)len;
      }
      else
  	var_redir_stop();
--- 992,1011 ----
      char_u	*value;
      int		value_len;
  {
!     int		len;
  
      if (redir_lval == NULL)
  	return;
  
      if (value_len == -1)
! 	len = (int)STRLEN(value);	/* Append the entire string */
      else
! 	len = value_len;		/* Append only "value_len" characters */
  
!     if (ga_grow(&redir_ga, len) == OK)
      {
  	mch_memmove((char *)redir_ga.ga_data + redir_ga.ga_len, value, len);
! 	redir_ga.ga_len += len;
      }
      else
  	var_redir_stop();
*** ../vim-7.1.033/src/spell.c	Thu May 10 18:45:53 2007
--- src/spell.c	Sat Jul 14 17:17:52 2007
***************
*** 7829,7835 ****
  # if (_MSC_VER <= 1200)
  /* This line is required for VC6 without the service pack.  Also see the
   * matching #pragma below. */
! /* # pragma optimize("", off) */
  # endif
  #endif
  
--- 7829,7835 ----
  # if (_MSC_VER <= 1200)
  /* This line is required for VC6 without the service pack.  Also see the
   * matching #pragma below. */
!  #  pragma optimize("", off)
  # endif
  #endif
  
***************
*** 7859,7865 ****
  
  #ifdef _MSC_VER
  # if (_MSC_VER <= 1200)
! /* # pragma optimize("", on) */
  # endif
  #endif
  
--- 7859,7865 ----
  
  #ifdef _MSC_VER
  # if (_MSC_VER <= 1200)
!  #  pragma optimize("", on)
  # endif
  #endif
  
*** ../vim-7.1.033/src/version.c	Tue Jul 24 09:50:22 2007
--- src/version.c	Tue Jul 24 09:47:17 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     34,
  /**/

-- 
How To Keep A Healthy Level Of Insanity:
17. When the money comes out the ATM, scream "I won!, I won! 3rd
    time this week!!!!!"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.035
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.035
Problem:    After ":s/./&/#" all listed lines have a line number. (Yakov
	    Lerner)
Solution:   Reset the line number flag when not using the "&" flag.
Files:	    src/ex_cmds.c


*** ../vim-7.1.034/src/ex_cmds.c	Tue Jul 10 17:25:20 2007
--- src/ex_cmds.c	Sat Jul 14 14:39:38 2007
***************
*** 4316,4321 ****
--- 4316,4322 ----
  	do_error = TRUE;
  	do_print = FALSE;
  	do_count = FALSE;
+ 	do_number = FALSE;
  	do_ic = 0;
      }
      while (*cmd)
*** ../vim-7.1.034/src/version.c	Tue Jul 24 10:44:10 2007
--- src/version.c	Tue Jul 24 11:15:09 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     35,
  /**/

-- 
The startling truth finally became apparent, and it was this: Numbers
written on restaurant checks within the confines of restaurants do not follow
the same mathematical laws as numbers written on any other pieces of paper in
any other parts of the Universe.  This single statement took the scientific
world by storm.  So many mathematical conferences got held in such good
restaurants that many of the finest minds of a generation died of obesity and
heart failure, and the science of mathematics was put back by years.
		-- Douglas Adams, "The Hitchhiker's Guide to the Galaxy"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.036
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.036
Problem:    Completing ":echohl" argument should include "None". (Ori
	    Avtalion)  ":match" should have "none" too.
Solution:   Add flags to use expand_highlight().  Also fix that when disabling
	    FEAT_CMDL_COMPL compilation fails.  (Chris Lubinski)
Files:	    src/eval.c, src/ex_docmd.c, src/ex_getln.c, src/proto/syntax.pro
	    src/syntax.c


*** ../vim-7.1.035/src/eval.c	Tue Jul 24 10:44:10 2007
--- src/eval.c	Wed Jul 11 19:50:27 2007
***************
*** 1411,1417 ****
  }
  
  
! #if (defined(FEAT_USR_CMDS) && defined(FEAT_CMDL_COMPL)) || defined(PROTO)
  /*
   * Call some vimL function and return the result in "*rettv".
   * Uses argv[argc] for the function arguments.
--- 1411,1418 ----
  }
  
  
! #if (defined(FEAT_USR_CMDS) && defined(FEAT_CMDL_COMPL)) \
! 	|| defined(FEAT_COMPL_FUNC) || defined(PROTO)
  /*
   * Call some vimL function and return the result in "*rettv".
   * Uses argv[argc] for the function arguments.
***************
*** 1484,1489 ****
--- 1485,1491 ----
      return ret;
  }
  
+ # if (defined(FEAT_USR_CMDS) && defined(FEAT_CMDL_COMPL)) || defined(PROTO)
  /*
   * Call vimL function "func" and return the result as a string.
   * Returns NULL when calling the function fails.
***************
*** 1506,1513 ****
      clear_tv(&rettv);
      return retval;
  }
  
! #if defined(FEAT_COMPL_FUNC) || defined(PROTO)
  /*
   * Call vimL function "func" and return the result as a number.
   * Returns -1 when calling the function fails.
--- 1508,1516 ----
      clear_tv(&rettv);
      return retval;
  }
+ # endif
  
! # if defined(FEAT_COMPL_FUNC) || defined(PROTO)
  /*
   * Call vimL function "func" and return the result as a number.
   * Returns -1 when calling the function fails.
***************
*** 1530,1536 ****
      clear_tv(&rettv);
      return retval;
  }
! #endif
  
  /*
   * Call vimL function "func" and return the result as a list
--- 1533,1539 ----
      clear_tv(&rettv);
      return retval;
  }
! # endif
  
  /*
   * Call vimL function "func" and return the result as a list
***************
*** 1556,1563 ****
  
      return rettv.vval.v_list;
  }
- 
  #endif
  
  /*
   * Save the current function call pointer, and set it to NULL.
--- 1559,1566 ----
  
      return rettv.vval.v_list;
  }
  #endif
+ 
  
  /*
   * Save the current function call pointer, and set it to NULL.
*** ../vim-7.1.035/src/ex_docmd.c	Mon Jul 16 20:38:56 2007
--- src/ex_docmd.c	Sun Jul 15 17:20:09 2007
***************
*** 3406,3419 ****
  	case CMD_windo:
  	    return arg;
  
! #ifdef FEAT_SEARCH_EXTRA
  	case CMD_match:
  	    if (*arg == NUL || !ends_excmd(*arg))
  	    {
! 		/* Dummy call to clear variables. */
! 		set_context_in_highlight_cmd(xp, (char_u *)"link n");
! 		xp->xp_context = EXPAND_HIGHLIGHT;
! 		xp->xp_pattern = arg;
  		arg = skipwhite(skiptowhite(arg));
  		if (*arg != NUL)
  		{
--- 3406,3418 ----
  	case CMD_windo:
  	    return arg;
  
! #ifdef FEAT_CMDL_COMPL
! # ifdef FEAT_SEARCH_EXTRA
  	case CMD_match:
  	    if (*arg == NUL || !ends_excmd(*arg))
  	    {
! 		/* also complete "None" */
! 		set_context_in_echohl_cmd(xp, arg);
  		arg = skipwhite(skiptowhite(arg));
  		if (*arg != NUL)
  		{
***************
*** 3422,3430 ****
  		}
  	    }
  	    return find_nextcmd(arg);
! #endif
  
- #ifdef FEAT_CMDL_COMPL
  /*
   * All completion for the +cmdline_compl feature goes here.
   */
--- 3421,3428 ----
  		}
  	    }
  	    return find_nextcmd(arg);
! # endif
  
  /*
   * All completion for the +cmdline_compl feature goes here.
   */
***************
*** 3622,3629 ****
  	    break;
  
  	case CMD_echohl:
! 	    xp->xp_context = EXPAND_HIGHLIGHT;
! 	    xp->xp_pattern = arg;
  	    break;
  #endif
  	case CMD_highlight:
--- 3620,3626 ----
  	    break;
  
  	case CMD_echohl:
! 	    set_context_in_echohl_cmd(xp, arg);
  	    break;
  #endif
  	case CMD_highlight:
*** ../vim-7.1.035/src/ex_getln.c	Tue Jul 17 18:14:14 2007
--- src/ex_getln.c	Tue Jul 17 18:05:49 2007
***************
*** 268,274 ****
--- 268,276 ----
      {
  	xpc.xp_context = ccline.xp_context;
  	xpc.xp_pattern = ccline.cmdbuff;
+ # if defined(FEAT_USR_CMDS) && defined(FEAT_CMDL_COMPL)
  	xpc.xp_arg = ccline.xp_arg;
+ # endif
      }
  #endif
  
***************
*** 4151,4163 ****
--- 4153,4171 ----
  
  #ifdef FEAT_EVAL
      if (ccline.cmdfirstc == '=')
+     {
+ # ifdef FEAT_CMDL_COMPL
  	/* pass CMD_SIZE because there is no real command */
  	set_context_for_expression(xp, str, CMD_SIZE);
+ # endif
+     }
      else if (ccline.input_fn)
      {
  	xp->xp_context = ccline.xp_context;
  	xp->xp_pattern = ccline.cmdbuff;
+ # if defined(FEAT_USR_CMDS) && defined(FEAT_CMDL_COMPL)
  	xp->xp_arg = ccline.xp_arg;
+ # endif
      }
      else
  #endif
***************
*** 4504,4509 ****
--- 4512,4523 ----
      /* Sort the results.  Keep menu's in the specified order. */
      if (xp->xp_context != EXPAND_MENUNAMES && xp->xp_context != EXPAND_MENUS)
  	sort_strings(*file, *num_file);
+ 
+ #ifdef FEAT_CMDL_COMPL
+     /* Reset the variables used for special highlight names expansion, so that
+      * they don't show up when getting normal highlight names by ID. */
+     reset_expand_highlight();
+ #endif
  
      return OK;
  }
*** ../vim-7.1.035/src/proto/syntax.pro	Sat May  5 19:23:52 2007
--- src/proto/syntax.pro	Fri Jul 13 19:51:43 2007
***************
*** 8,13 ****
--- 8,15 ----
  void syntax_clear __ARGS((buf_T *buf));
  void ex_syntax __ARGS((exarg_T *eap));
  int syntax_present __ARGS((buf_T *buf));
+ void reset_expand_highlight __ARGS((void));
+ void set_context_in_echohl_cmd __ARGS((expand_T *xp, char_u *arg));
  void set_context_in_syntax_cmd __ARGS((expand_T *xp, char_u *arg));
  char_u *get_syntax_name __ARGS((expand_T *xp, int idx));
  int syn_get_id __ARGS((win_T *wp, long lnum, colnr_T col, int trans, int *spellp));
*** ../vim-7.1.035/src/syntax.c	Thu Jun 28 11:59:13 2007
--- src/syntax.c	Fri Jul 13 19:51:39 2007
***************
*** 66,73 ****
  #define HL_TABLE() ((struct hl_group *)((highlight_ga.ga_data)))
  
  #ifdef FEAT_CMDL_COMPL
! static int include_default = FALSE;	/* include "default" for expansion */
! static int include_link = FALSE;	/* include "link" for expansion */
  #endif
  
  /*
--- 66,75 ----
  #define HL_TABLE() ((struct hl_group *)((highlight_ga.ga_data)))
  
  #ifdef FEAT_CMDL_COMPL
! /* Flags to indicate an additional string for highlight name completion. */
! static int include_none = 0;	/* when 1 include "None" */
! static int include_default = 0;	/* when 1 include "default" */
! static int include_link = 0;	/* when 2 include "link" and "clear" */
  #endif
  
  /*
***************
*** 5968,5973 ****
--- 5970,5998 ----
      EXP_CASE	    /* expand ":syn case" arguments */
  } expand_what;
  
+ /*
+  * Reset include_link, include_default, include_none to 0.
+  * Called when we are done expanding.
+  */
+     void
+ reset_expand_highlight()
+ {
+     include_link = include_default = include_none = 0;
+ }
+ 
+ /*
+  * Handle command line completion for :match and :echohl command: Add "None"
+  * as highlight group.
+  */
+     void
+ set_context_in_echohl_cmd(xp, arg)
+     expand_T	*xp;
+     char_u	*arg;
+ {
+     xp->xp_context = EXPAND_HIGHLIGHT;
+     xp->xp_pattern = arg;
+     include_none = 1;
+ }
  
  /*
   * Handle command line completion for :syntax command.
***************
*** 5983,5990 ****
      xp->xp_context = EXPAND_SYNTAX;
      expand_what = EXP_SUBCMD;
      xp->xp_pattern = arg;
!     include_link = FALSE;
!     include_default = FALSE;
  
      /* (part of) subcommand already typed */
      if (*arg != NUL)
--- 6008,6015 ----
      xp->xp_context = EXPAND_SYNTAX;
      expand_what = EXP_SUBCMD;
      xp->xp_pattern = arg;
!     include_link = 0;
!     include_default = 0;
  
      /* (part of) subcommand already typed */
      if (*arg != NUL)
***************
*** 8949,8955 ****
      return OK;
  }
  
! #ifdef FEAT_CMDL_COMPL
  
  static void highlight_list __ARGS((void));
  static void highlight_list_two __ARGS((int cnt, int attr));
--- 8974,8980 ----
      return OK;
  }
  
! #if defined(FEAT_CMDL_COMPL) || defined(PROTO)
  
  static void highlight_list __ARGS((void));
  static void highlight_list_two __ARGS((int cnt, int attr));
***************
*** 8967,8974 ****
      /* Default: expand group names */
      xp->xp_context = EXPAND_HIGHLIGHT;
      xp->xp_pattern = arg;
!     include_link = TRUE;
!     include_default = TRUE;
  
      /* (part of) subcommand already typed */
      if (*arg != NUL)
--- 8992,8999 ----
      /* Default: expand group names */
      xp->xp_context = EXPAND_HIGHLIGHT;
      xp->xp_pattern = arg;
!     include_link = 2;
!     include_default = 1;
  
      /* (part of) subcommand already typed */
      if (*arg != NUL)
***************
*** 8976,8982 ****
  	p = skiptowhite(arg);
  	if (*p != NUL)			/* past "default" or group name */
  	{
! 	    include_default = FALSE;
  	    if (STRNCMP("default", arg, p - arg) == 0)
  	    {
  		arg = skipwhite(p);
--- 9001,9007 ----
  	p = skiptowhite(arg);
  	if (*p != NUL)			/* past "default" or group name */
  	{
! 	    include_default = 0;
  	    if (STRNCMP("default", arg, p - arg) == 0)
  	    {
  		arg = skipwhite(p);
***************
*** 8985,8991 ****
  	    }
  	    if (*p != NUL)			/* past group name */
  	    {
! 		include_link = FALSE;
  		if (arg[1] == 'i' && arg[0] == 'N')
  		    highlight_list();
  		if (STRNCMP("link", arg, p - arg) == 0
--- 9010,9016 ----
  	    }
  	    if (*p != NUL)			/* past group name */
  	    {
! 		include_link = 0;
  		if (arg[1] == 'i' && arg[0] == 'N')
  		    highlight_list();
  		if (STRNCMP("link", arg, p - arg) == 0
***************
*** 9045,9075 ****
      expand_T	*xp;
      int		idx;
  {
-     if (idx == highlight_ga.ga_len
  #ifdef FEAT_CMDL_COMPL
! 	    && include_link
! #endif
! 	    )
  	return (char_u *)"link";
!     if (idx == highlight_ga.ga_len + 1
! #ifdef FEAT_CMDL_COMPL
! 	    && include_link
! #endif
! 	    )
  	return (char_u *)"clear";
-     if (idx == highlight_ga.ga_len + 2
- #ifdef FEAT_CMDL_COMPL
- 	    && include_default
  #endif
- 	    )
- 	return (char_u *)"default";
      if (idx < 0 || idx >= highlight_ga.ga_len)
  	return NULL;
      return HL_TABLE()[idx].sg_name;
  }
  #endif
  
! #ifdef FEAT_GUI
  /*
   * Free all the highlight group fonts.
   * Used when quitting for systems which need it.
--- 9070,9094 ----
      expand_T	*xp;
      int		idx;
  {
  #ifdef FEAT_CMDL_COMPL
!     if (idx == highlight_ga.ga_len && include_none != 0)
! 	return (char_u *)"none";
!     if (idx == highlight_ga.ga_len + include_none && include_default != 0)
! 	return (char_u *)"default";
!     if (idx == highlight_ga.ga_len + include_none + include_default
! 							 && include_link != 0)
  	return (char_u *)"link";
!     if (idx == highlight_ga.ga_len + include_none + include_default + 1
! 							 && include_link != 0)
  	return (char_u *)"clear";
  #endif
      if (idx < 0 || idx >= highlight_ga.ga_len)
  	return NULL;
      return HL_TABLE()[idx].sg_name;
  }
  #endif
  
! #if defined(FEAT_GUI) || defined(PROTO)
  /*
   * Free all the highlight group fonts.
   * Used when quitting for systems which need it.
*** ../vim-7.1.035/src/version.c	Tue Jul 24 11:15:46 2007
--- src/version.c	Tue Jul 24 14:30:18 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     36,
  /**/

-- 
Apparently, 1 in 5 people in the world are Chinese.  And there are 5
people in my family, so it must be one of them.  It's either my mum
or my dad.  Or my older brother Colin.  Or my younger brother
Ho-Cha-Chu.  But I think it's Colin.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.037
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.037
Problem:    strcpy() used for overlapping strings. (Chris Monson)
Solution:   Use mch_memmove() instead.
Files:	    src/option.c


*** ../vim-7.1.036/src/option.c	Tue Jul 24 09:50:22 2007
--- src/option.c	Sun Jul 22 16:42:47 2007
***************
*** 4628,4634 ****
  				    if ((!(flags & P_COMMA) || *s != ',')
  					    && vim_strchr(s + 1, *s) != NULL)
  				    {
! 					STRCPY(s, s + 1);
  					--s;
  				    }
  			    }
--- 4628,4634 ----
  				    if ((!(flags & P_COMMA) || *s != ',')
  					    && vim_strchr(s + 1, *s) != NULL)
  				    {
! 					mch_memmove(s, s + 1, STRLEN(s));
  					--s;
  				    }
  			    }
*** ../vim-7.1.036/src/version.c	Tue Jul 24 14:32:44 2007
--- src/version.c	Tue Jul 24 14:56:03 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     37,
  /**/

-- 
This planet has -- or rather had -- a problem, which was this: most
of the people living on it were unhappy for pretty much of the time.
Many solutions were suggested for this problem, but most of these
were largely concerned with the movements of small green pieces of
paper, which is odd because on the whole it wasn't the small green
pieces of paper that were unhappy.
		-- Douglas Adams, "The Hitchhiker's Guide to the Galaxy"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.038
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.038
Problem:    When 'expandtab' is set then a Tab copied for 'copyindent' is
	    expanded to spaces, even when 'preserveindent' is set. (Alexei
	    Alexandrov)
Solution:   Remove the check for 'expandtab'.  Also fix that ">>" doesn't obey
	    'preserveindent'. (Chris Lubinski)
Files:	    src/misc1.c


*** ../vim-7.1.037/src/misc1.c	Thu May 10 21:03:33 2007
--- src/misc1.c	Tue Jul 24 15:24:50 2007
***************
*** 90,96 ****
   */
      int
  set_indent(size, flags)
!     int		size;
      int		flags;
  {
      char_u	*p;
--- 90,96 ----
   */
      int
  set_indent(size, flags)
!     int		size;		    /* measured in spaces */
      int		flags;
  {
      char_u	*p;
***************
*** 98,109 ****
      char_u	*oldline;
      char_u	*s;
      int		todo;
!     int		ind_len;
      int		line_len;
      int		doit = FALSE;
!     int		ind_done;
      int		tab_pad;
      int		retval = FALSE;
  
      /*
       * First check if there is anything to do and compute the number of
--- 98,111 ----
      char_u	*oldline;
      char_u	*s;
      int		todo;
!     int		ind_len;	    /* measured in characters */
      int		line_len;
      int		doit = FALSE;
!     int		ind_done = 0;	    /* measured in spaces */
      int		tab_pad;
      int		retval = FALSE;
+     int		orig_char_len = 0;  /* number of initial whitespace chars when
+ 				       'et' and 'pi' are both set */
  
      /*
       * First check if there is anything to do and compute the number of
***************
*** 116,123 ****
      /* Calculate the buffer size for the new indent, and check to see if it
       * isn't already set */
  
!     /* if 'expandtab' isn't set: use TABs */
!     if (!curbuf->b_p_et)
      {
  	/* If 'preserveindent' is set then reuse as much as possible of
  	 * the existing indent structure for the new indent */
--- 118,127 ----
      /* Calculate the buffer size for the new indent, and check to see if it
       * isn't already set */
  
!     /* if 'expandtab' isn't set: use TABs; if both 'expandtab' and
!      * 'preserveindent' are set count the number of characters at the
!      * beginning of the line to be copied */
!     if (!curbuf->b_p_et || (!(flags & SIN_INSERT) && curbuf->b_p_pi))
      {
  	/* If 'preserveindent' is set then reuse as much as possible of
  	 * the existing indent structure for the new indent */
***************
*** 148,156 ****
  		++p;
  	    }
  
  	    /* Fill to next tabstop with a tab, if possible */
  	    tab_pad = (int)curbuf->b_p_ts - (ind_done % (int)curbuf->b_p_ts);
! 	    if (todo >= tab_pad)
  	    {
  		doit = TRUE;
  		todo -= tab_pad;
--- 152,165 ----
  		++p;
  	    }
  
+ 	    /* Set initial number of whitespace chars to copy if we are
+ 	     * preserving indent but expandtab is set */
+ 	    if (curbuf->b_p_et)
+ 		orig_char_len = ind_len;
+ 
  	    /* Fill to next tabstop with a tab, if possible */
  	    tab_pad = (int)curbuf->b_p_ts - (ind_done % (int)curbuf->b_p_ts);
! 	    if (todo >= tab_pad && orig_char_len == 0)
  	    {
  		doit = TRUE;
  		todo -= tab_pad;
***************
*** 193,205 ****
      else
  	p = skipwhite(p);
      line_len = (int)STRLEN(p) + 1;
!     newline = alloc(ind_len + line_len);
!     if (newline == NULL)
! 	return FALSE;
  
      /* Put the characters in the new line. */
-     s = newline;
-     todo = size;
      /* if 'expandtab' isn't set: use TABs */
      if (!curbuf->b_p_et)
      {
--- 202,239 ----
      else
  	p = skipwhite(p);
      line_len = (int)STRLEN(p) + 1;
! 
!     /* If 'preserveindent' and 'expandtab' are both set keep the original
!      * characters and allocate accordingly.  We will fill the rest with spaces
!      * after the if (!curbuf->b_p_et) below. */
!     if (orig_char_len != 0)
!     {
! 	newline = alloc(orig_char_len + size - ind_done + line_len);
! 	if (newline == NULL)
! 	    return FALSE;
! 	p = oldline;
! 	s = newline;
! 	while (orig_char_len > 0)
! 	{
! 	    *s++ = *p++;
! 	    orig_char_len--;
! 	}
! 	/* Skip over any additional white space (useful when newindent is less
! 	 * than old) */
! 	while (vim_iswhite(*p))
! 	    (void)*p++;
! 	todo = size-ind_done;
!     }
!     else
!     {
! 	todo = size;
! 	newline = alloc(ind_len + line_len);
! 	if (newline == NULL)
! 	    return FALSE;
! 	s = newline;
!     }
  
      /* Put the characters in the new line. */
      /* if 'expandtab' isn't set: use TABs */
      if (!curbuf->b_p_et)
      {
***************
*** 1320,1327 ****
  	    newindent += (int)curbuf->b_p_sw;
  	}
  #endif
! 	/* Copy the indent only if expand tab is disabled */
! 	if (curbuf->b_p_ci && !curbuf->b_p_et)
  	{
  	    (void)copy_indent(newindent, saved_line);
  
--- 1354,1361 ----
  	    newindent += (int)curbuf->b_p_sw;
  	}
  #endif
! 	/* Copy the indent */
! 	if (curbuf->b_p_ci)
  	{
  	    (void)copy_indent(newindent, saved_line);
  
*** ../vim-7.1.037/src/version.c	Tue Jul 24 14:57:16 2007
--- src/version.c	Tue Jul 24 15:22:44 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     38,
  /**/

-- 
Time is an illusion.  Lunchtime doubly so.
		-- Ford Prefect, in Douglas Adams'
		   "The Hitchhiker's Guide to the Galaxy"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.039
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.039
Problem:    A tag in a help file that starts with "help-tags" and contains a
	    percent sign may make Vim crash. (Ulf Harnhammar)
Solution:   Use puts() instead of fprintf().
Files:	    src/ex_cmds.c


*** ../vim-7.1.038/src/ex_cmds.c	Tue Jul 24 11:15:46 2007
--- src/ex_cmds.c	Wed Jul 25 20:06:20 2007
***************
*** 6374,6382 ****
  	for (i = 0; i < ga.ga_len; ++i)
  	{
  	    s = ((char_u **)ga.ga_data)[i];
! 	    if (STRNCMP(s, "help-tags", 9) == 0)
  		/* help-tags entry was added in formatted form */
! 		fprintf(fd_tags, (char *)s);
  	    else
  	    {
  		fprintf(fd_tags, "%s\t/*", s);
--- 6374,6382 ----
  	for (i = 0; i < ga.ga_len; ++i)
  	{
  	    s = ((char_u **)ga.ga_data)[i];
! 	    if (STRNCMP(s, "help-tags\t", 10) == 0)
  		/* help-tags entry was added in formatted form */
! 		fputs((char *)s, fd_tags);
  	    else
  	    {
  		fprintf(fd_tags, "%s\t/*", s);
*** ../vim-7.1.038/src/version.c	Tue Jul 24 15:25:27 2007
--- src/version.c	Wed Jul 25 22:41:18 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     39,
  /**/

-- 
On the other hand, you have different fingers.
                                      -- Steven Wright

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.040
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.040
Problem:    ":match" only supports three matches.
Solution:   Add functions clearmatches(), getmatches(), matchadd(),
	    matchdelete() and setmatches().  Changed the data structures for
	    this.  A small bug in syntax.c is fixed, so newly created
	    highlight groups can have their name resolved correctly from their
	    ID.  (Martin Toft)
Files:	    runtime/doc/eval.txt, runtime/doc/pattern.txt,
	    runtime/doc/usr_41.txt, src/eval.c, src/ex_docmd.c,
	    src/proto/window.pro, src/screen.c, src/structs.h, src/syntax.c,
	    src/testdir/Makefile, src/testdir/test63.in,
	    src/testdir/test63.ok, src/window.c


*** ../vim-7.1.039/runtime/doc/eval.txt	Tue Jul 17 16:31:15 2007
--- runtime/doc/eval.txt	Wed Jul 25 21:05:56 2007
***************
*** 1,4 ****
! *eval.txt*      For Vim version 7.1.  Last change: 2007 Jul 11
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
--- 1,4 ----
! *eval.txt*      For Vim version 7.1.  Last change: 2007 Jul 25
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
***************
*** 1557,1562 ****
--- 1557,1563 ----
  changenr()			Number  current change number
  char2nr( {expr})		Number	ASCII value of first char in {expr}
  cindent( {lnum})		Number	C indent for line {lnum}
+ clearmatches()			None	clear all matches
  col( {expr})			Number	column nr of cursor or mark
  complete({startcol}, {matches})	String  set Insert mode completion
  complete_add( {expr})		Number	add completion match
***************
*** 1622,1627 ****
--- 1623,1629 ----
  getline( {lnum})		String	line {lnum} of current buffer
  getline( {lnum}, {end})		List	lines {lnum} to {end} of current buffer
  getloclist({nr})		List	list of location list items
+ getmatches()			List	list of current matches
  getpos( {expr})			List	position of cursor, mark, etc.
  getqflist()			List	list of quickfix items
  getreg( [{regname} [, 1]])	String	contents of register
***************
*** 1676,1682 ****
--- 1678,1687 ----
  				String	check for mappings matching {name}
  match( {expr}, {pat}[, {start}[, {count}]])
  				Number	position where {pat} matches in {expr}
+ matchadd( {group}, {pattern}[, {priority}[, {id}]])
+ 				Number	highlight {pattern} with {group}
  matcharg( {nr})			List	arguments of |:match|
+ matchdelete( {id})		Number	delete match identified by {id}
  matchend( {expr}, {pat}[, {start}[, {count}]])
  				Number	position where {pat} ends in {expr}
  matchlist( {expr}, {pat}[, {start}[, {count}]])
***************
*** 1731,1736 ****
--- 1736,1742 ----
  setline( {lnum}, {line})	Number	set line {lnum} to {line}
  setloclist( {nr}, {list}[, {action}])
  				Number	modify location list using {list}
+ setmatches( {list})		Number	restore a list of matches
  setpos( {expr}, {list})		none	set the {expr} position to {list}
  setqflist( {list}[, {action}])	Number	modify quickfix list using {list}
  setreg( {n}, {v}[, {opt}])	Number	set register to value and type
***************
*** 2012,2017 ****
--- 2018,2027 ----
  		feature, -1 is returned.
  		See |C-indenting|.
  
+ clearmatches()						*clearmatches()*
+ 		Clears all matches previously defined by |matchadd()| and the
+ 		|:match| commands.
+ 
  							*col()*
  col({expr})	The result is a Number, which is the byte index of the column
  		position given with {expr}.  The accepted positions are:
***************
*** 2918,2923 ****
--- 2928,2955 ----
  		returned.  For an invalid window number {nr}, an empty list is
  		returned. Otherwise, same as getqflist().
  
+ getmatches()						*getmatches()*
+ 		Returns a |List| with all matches previously defined by
+ 		|matchadd()| and the |:match| commands.  |getmatches()| is
+ 		useful in combination with |setmatches()|, as |setmatches()|
+ 		can restore a list of matches saved by |getmatches()|.
+ 		Example: >
+ 			:echo getmatches()
+ <			[{'group': 'MyGroup1', 'pattern': 'TODO',
+ 			'priority': 10, 'id': 1}, {'group': 'MyGroup2',
+ 			'pattern': 'FIXME', 'priority': 10, 'id': 2}] >
+ 			:let m = getmatches()
+ 			:call clearmatches()
+ 			:echo getmatches()
+ <			[] >
+ 			:call setmatches(m)
+ 			:echo getmatches()
+ <			[{'group': 'MyGroup1', 'pattern': 'TODO',
+ 			'priority': 10, 'id': 1}, {'group': 'MyGroup2',
+ 			'pattern': 'FIXME', 'priority': 10, 'id': 2}] >
+ 			:unlet m
+ <
+ 
  getqflist()						*getqflist()*
  		Returns a list with all the current quickfix errors.  Each
  		list item is a dictionary with these entries:
***************
*** 3622,3627 ****
--- 3654,3697 ----
  		the pattern.  'smartcase' is NOT used.  The matching is always
  		done like 'magic' is set and 'cpoptions' is empty.
  
+ 					*matchadd()* *E798* *E799* *E801*
+ matchadd({group}, {pattern}[, {priority}[, {id}]])
+ 		Defines a pattern to be highlighted in the current window (a
+ 		"match").  It will be highlighted with {group}.  Returns an
+ 		identification number (ID), which can be used to delete the
+ 		match using |matchdelete()|.
+ 
+ 		The optional {priority} argument assigns a priority to the
+ 		match.  A match with a high priority will have its
+ 		highlighting overrule that of a match with a lower priority.
+ 		A priority is specified as an integer (negative numbers are no
+ 		exception).  If the {priority} argument is not specified, the
+ 		default priority is 10.  The priority of 'hlsearch' is zero,
+ 		hence all matches with a priority greater than zero will
+ 		overrule it.  Syntax highlighting (see 'syntax') is a separate
+ 		mechanism, and regardless of the chosen priority a match will
+ 		always overrule syntax highlighting.
+ 
+ 		The optional {id} argument allows the request for a specific
+ 		match ID.  If a specified ID is already taken, an error
+ 		message will appear and the match will not be added.  An ID
+ 		is specified as a positive integer (zero excluded).  IDs 1, 2
+ 		and 3 are reserved for |:match|, |:2match| and |:3match|,
+ 		respectively.  If the {id} argument is not specified,
+ 		|matchadd()| automatically chooses a free ID.
+ 
+ 		The number of matches is not limited, as it is the case with
+ 		the |:match| commands.
+ 
+ 		Example: >
+ 			:highlight MyGroup ctermbg=green guibg=green
+ 			:let m = matchadd("MyGroup", "TODO")
+ <		Deletion of the pattern: >
+ 			:call matchdelete(m)
+ 
+ <		A list of matches defined by |matchadd()| and |:match| are
+ 		available from |getmatches()|.  All matches can be deleted in
+ 		one operation by |clearmatches()|.
  
  matcharg({nr})							*matcharg()*
  		Selects the {nr} match item, as set with a |:match|,
***************
*** 3631,3638 ****
  			The pattern used.
  		When {nr} is not 1, 2 or 3 returns an empty |List|.
  		When there is no match item set returns ['', ''].
! 		This is usef to save and restore a |:match|.
! 
  
  matchend({expr}, {pat}[, {start}[, {count}]])			*matchend()*
  		Same as match(), but return the index of first character after
--- 3701,3715 ----
  			The pattern used.
  		When {nr} is not 1, 2 or 3 returns an empty |List|.
  		When there is no match item set returns ['', ''].
! 		This is useful to save and restore a |:match|.
! 		Highlighting matches using the |:match| commands are limited
! 		to three matches. |matchadd()| does not have this limitation.
! 
! matchdelete({id})			       *matchdelete()* *E802* *E803*
! 		Deletes a match with ID {id} previously defined by |matchadd()|
! 		or one of the |:match| commands.  Returns 0 if succesfull,
! 		otherwise -1.  See example for |matchadd()|.  All matches can
! 		be deleted in one operation by |clearmatches()|.
  
  matchend({expr}, {pat}[, {start}[, {count}]])			*matchend()*
  		Same as match(), but return the index of first character after
***************
*** 4385,4391 ****
  		When {nr} is zero the current window is used. For a location
  		list window, the displayed location list is modified.  For an
  		invalid window number {nr}, -1 is returned.
! 		Otherwise, same as setqflist().
  
  							*setpos()*
  setpos({expr}, {list})
--- 4462,4474 ----
  		When {nr} is zero the current window is used. For a location
  		list window, the displayed location list is modified.  For an
  		invalid window number {nr}, -1 is returned.
! 		Otherwise, same as |setqflist()|.
! 		Also see |location-list|.
! 
! setmatches({list})					*setmatches()*
! 		Restores a list of matches saved by |getmatches()|.  Returns 0
! 		if succesfull, otherwise -1.  All current matches are cleared
! 		before the list is restored.  See example for |getmatches()|.
  
  							*setpos()*
  setpos({expr}, {list})
*** ../vim-7.1.039/runtime/doc/pattern.txt	Sat May 12 16:57:31 2007
--- runtime/doc/pattern.txt	Tue Jul 24 15:47:01 2007
***************
*** 1212,1218 ****
  		{group} must exist at the moment this command is executed.
  
  		The {group} highlighting still applies when a character is
! 		to be highlighted for 'hlsearch'.
  
  		Note that highlighting the last used search pattern with
  		'hlsearch' is used in all windows, while the pattern defined
--- 1212,1221 ----
  		{group} must exist at the moment this command is executed.
  
  		The {group} highlighting still applies when a character is
! 		to be highlighted for 'hlsearch', as the highlighting for
! 		matches is given higher priority than that of 'hlsearch'.
! 		Syntax highlighting (see 'syntax') is also overruled by
! 		matches.
  
  		Note that highlighting the last used search pattern with
  		'hlsearch' is used in all windows, while the pattern defined
***************
*** 1226,1233 ****
  		display you may get unexpected results.  That is because Vim
  		looks for a match in the line where redrawing starts.
  
! 		Also see |matcharg()|, it returns the highlight group and
! 		pattern of a previous :match command.
  
  		Another example, which highlights all characters in virtual
  		column 72 and more: >
--- 1229,1243 ----
  		display you may get unexpected results.  That is because Vim
  		looks for a match in the line where redrawing starts.
  
! 		Also see |matcharg()|and |getmatches()|. The former returns
! 		the highlight group and pattern of a previous |:match|
! 		command.  The latter returns a list with highlight groups and
! 		patterns defined by both |matchadd()| and |:match|.
! 
! 		Highlighting matches using |:match| are limited to three
! 		matches (aside from |:match|, |:2match| and |:3match|are
! 		available). |matchadd()| does not have this limitation and in
! 		addition makes it possible to prioritize matches.
  
  		Another example, which highlights all characters in virtual
  		column 72 and more: >
*** ../vim-7.1.039/runtime/doc/usr_41.txt	Sat May 12 15:54:55 2007
--- runtime/doc/usr_41.txt	Tue Jul 24 15:47:01 2007
***************
*** 763,775 ****
--- 763,784 ----
  	foldtextresult()	get the text displayed for a closed fold
  
  Syntax and highlighting:
+ 	clearmatches()		clear all matches defined by |matchadd()| and
+ 				the |:match| commands
+ 	getmatches()		get all matches defined by |matchadd()| and
+ 				the |:match| commands
  	hlexists()		check if a highlight group exists
  	hlID()			get ID of a highlight group
  	synID()			get syntax ID at a specific position
  	synIDattr()		get a specific attribute of a syntax ID
  	synIDtrans()		get translated syntax ID
  	diff_hlID()		get highlight ID for diff mode at a position
+ 	matchadd()		define a pattern to highlight (a "match")
  	matcharg()		get info about |:match| arguments
+ 	matchdelete()		delete a match defined by |matchadd()| or a
+ 				|:match| command
+ 	setmatches()		restore a list of matches saved by
+ 				|getmatches()|
  
  Spelling:
  	spellbadword()		locate badly spelled word at or after cursor
*** ../vim-7.1.039/src/eval.c	Tue Jul 24 14:32:44 2007
--- src/eval.c	Tue Jul 24 20:40:52 2007
***************
*** 475,480 ****
--- 475,481 ----
  static void f_changenr __ARGS((typval_T *argvars, typval_T *rettv));
  static void f_char2nr __ARGS((typval_T *argvars, typval_T *rettv));
  static void f_cindent __ARGS((typval_T *argvars, typval_T *rettv));
+ static void f_clearmatches __ARGS((typval_T *argvars, typval_T *rettv));
  static void f_col __ARGS((typval_T *argvars, typval_T *rettv));
  #if defined(FEAT_INS_EXPAND)
  static void f_complete __ARGS((typval_T *argvars, typval_T *rettv));
***************
*** 529,534 ****
--- 530,536 ----
  static void f_getftime __ARGS((typval_T *argvars, typval_T *rettv));
  static void f_getftype __ARGS((typval_T *argvars, typval_T *rettv));
  static void f_getline __ARGS((typval_T *argvars, typval_T *rettv));
+ static void f_getmatches __ARGS((typval_T *argvars, typval_T *rettv));
  static void f_getpos __ARGS((typval_T *argvars, typval_T *rettv));
  static void f_getqflist __ARGS((typval_T *argvars, typval_T *rettv));
  static void f_getreg __ARGS((typval_T *argvars, typval_T *rettv));
***************
*** 577,583 ****
--- 579,587 ----
  static void f_maparg __ARGS((typval_T *argvars, typval_T *rettv));
  static void f_mapcheck __ARGS((typval_T *argvars, typval_T *rettv));
  static void f_match __ARGS((typval_T *argvars, typval_T *rettv));
+ static void f_matchadd __ARGS((typval_T *argvars, typval_T *rettv));
  static void f_matcharg __ARGS((typval_T *argvars, typval_T *rettv));
+ static void f_matchdelete __ARGS((typval_T *argvars, typval_T *rettv));
  static void f_matchend __ARGS((typval_T *argvars, typval_T *rettv));
  static void f_matchlist __ARGS((typval_T *argvars, typval_T *rettv));
  static void f_matchstr __ARGS((typval_T *argvars, typval_T *rettv));
***************
*** 618,623 ****
--- 622,628 ----
  static void f_setcmdpos __ARGS((typval_T *argvars, typval_T *rettv));
  static void f_setline __ARGS((typval_T *argvars, typval_T *rettv));
  static void f_setloclist __ARGS((typval_T *argvars, typval_T *rettv));
+ static void f_setmatches __ARGS((typval_T *argvars, typval_T *rettv));
  static void f_setpos __ARGS((typval_T *argvars, typval_T *rettv));
  static void f_setqflist __ARGS((typval_T *argvars, typval_T *rettv));
  static void f_setreg __ARGS((typval_T *argvars, typval_T *rettv));
***************
*** 7046,7051 ****
--- 7051,7057 ----
      {"changenr",	0, 0, f_changenr},
      {"char2nr",		1, 1, f_char2nr},
      {"cindent",		1, 1, f_cindent},
+     {"clearmatches",	0, 0, f_clearmatches},
      {"col",		1, 1, f_col},
  #if defined(FEAT_INS_EXPAND)
      {"complete",	2, 2, f_complete},
***************
*** 7102,7107 ****
--- 7108,7114 ----
      {"getftype",	1, 1, f_getftype},
      {"getline",		1, 2, f_getline},
      {"getloclist",	1, 1, f_getqflist},
+     {"getmatches",  	0, 0, f_getmatches},
      {"getpos",		1, 1, f_getpos},
      {"getqflist",	0, 0, f_getqflist},
      {"getreg",		0, 2, f_getreg},
***************
*** 7152,7158 ****
--- 7159,7167 ----
      {"maparg",		1, 3, f_maparg},
      {"mapcheck",	1, 3, f_mapcheck},
      {"match",		2, 4, f_match},
+     {"matchadd",	2, 4, f_matchadd},
      {"matcharg",	1, 1, f_matcharg},
+     {"matchdelete",	1, 1, f_matchdelete},
      {"matchend",	2, 4, f_matchend},
      {"matchlist",	2, 4, f_matchlist},
      {"matchstr",	2, 4, f_matchstr},
***************
*** 7193,7198 ****
--- 7202,7208 ----
      {"setcmdpos",	1, 1, f_setcmdpos},
      {"setline",		2, 2, f_setline},
      {"setloclist",	2, 3, f_setloclist},
+     {"setmatches",	1, 1, f_setmatches},
      {"setpos",		2, 2, f_setpos},
      {"setqflist",	1, 2, f_setqflist},
      {"setreg",		2, 3, f_setreg},
***************
*** 8243,8248 ****
--- 8253,8272 ----
  }
  
  /*
+  * "clearmatches()" function
+  */
+ /*ARGSUSED*/
+     static void
+ f_clearmatches(argvars, rettv)
+     typval_T	*argvars;
+     typval_T	*rettv;
+ {
+ #ifdef FEAT_SEARCH_EXTRA
+     clear_matches(curwin);
+ #endif
+ }
+ 
+ /*
   * "col(string)" function
   */
      static void
***************
*** 10278,10283 ****
--- 10302,10341 ----
  }
  
  /*
+  * "getmatches()" function
+  */
+ /*ARGSUSED*/
+     static void
+ f_getmatches(argvars, rettv)
+     typval_T	*argvars;
+     typval_T	*rettv;
+ {
+ #ifdef FEAT_SEARCH_EXTRA
+     dict_T	*dict;
+     matchitem_T	*cur = curwin->w_match_head;
+ 
+     rettv->vval.v_number = 0;
+ 
+     if (rettv_list_alloc(rettv) == OK)
+     {
+ 	while (cur != NULL)
+ 	{
+ 	    dict = dict_alloc();
+ 	    if (dict == NULL)
+ 		return;
+ 	    ++dict->dv_refcount;
+ 	    dict_add_nr_str(dict, "group", 0L, syn_id2name(cur->hlg_id));
+ 	    dict_add_nr_str(dict, "pattern", 0L, cur->pattern);
+ 	    dict_add_nr_str(dict, "priority", (long)cur->priority, NULL);
+ 	    dict_add_nr_str(dict, "id", (long)cur->id, NULL);
+ 	    list_append_dict(rettv->vval.v_list, dict);
+ 	    cur = cur->next;
+ 	}
+     }
+ #endif
+ }
+ 
+ /*
   * "getpos(string)" function
   */
      static void
***************
*** 12448,12453 ****
--- 12506,12547 ----
  }
  
  /*
+  * "matchadd()" function
+  */
+     static void
+ f_matchadd(argvars, rettv)
+     typval_T	*argvars;
+     typval_T	*rettv;
+ {
+ #ifdef FEAT_SEARCH_EXTRA
+     char_u	buf[NUMBUFLEN];
+     char_u	*grp = get_tv_string_buf_chk(&argvars[0], buf);	/* group */
+     char_u	*pat = get_tv_string_buf_chk(&argvars[1], buf);	/* pattern */
+     int		prio = 10;	/* default priority */
+     int		id = -1;
+     int		error = FALSE;
+ 
+     rettv->vval.v_number = -1;
+ 
+     if (grp == NULL || pat == NULL)
+ 	return;
+     if (argvars[2].v_type != VAR_UNKNOWN)
+ 	prio = get_tv_number_chk(&argvars[2], &error);
+     if (argvars[3].v_type != VAR_UNKNOWN)
+ 	id = get_tv_number_chk(&argvars[3], &error);
+     if (error == TRUE)
+ 	return;
+     if (id >= 1 && id <= 3)
+     {
+ 	EMSGN("E798: ID is reserved for \":match\": %ld", id);
+ 	return;
+     }
+ 
+     rettv->vval.v_number = match_add(curwin, grp, pat, prio, id);
+ #endif
+ }
+ 
+ /*
   * "matcharg()" function
   */
      static void
***************
*** 12458,12477 ****
      if (rettv_list_alloc(rettv) == OK)
      {
  #ifdef FEAT_SEARCH_EXTRA
! 	int	mi = get_tv_number(&argvars[0]);
  
! 	if (mi >= 1 && mi <= 3)
  	{
! 	    list_append_string(rettv->vval.v_list,
! 				 syn_id2name(curwin->w_match_id[mi - 1]), -1);
! 	    list_append_string(rettv->vval.v_list,
! 					     curwin->w_match_pat[mi - 1], -1);
  	}
  #endif
      }
  }
  
  /*
   * "matchend()" function
   */
      static void
--- 12552,12593 ----
      if (rettv_list_alloc(rettv) == OK)
      {
  #ifdef FEAT_SEARCH_EXTRA
! 	int	    id = get_tv_number(&argvars[0]);
! 	matchitem_T *m;
  
! 	if (id >= 1 && id <= 3)
  	{
! 	    if ((m = (matchitem_T *)get_match(curwin, id)) != NULL)
! 	    {
! 		list_append_string(rettv->vval.v_list,
! 						syn_id2name(m->hlg_id), -1);
! 		list_append_string(rettv->vval.v_list, m->pattern, -1);
! 	    }
! 	    else
! 	    {
! 		list_append_string(rettv->vval.v_list, NUL, -1);
! 		list_append_string(rettv->vval.v_list, NUL, -1);
! 	    }
  	}
  #endif
      }
  }
  
  /*
+  * "matchdelete()" function
+  */
+     static void
+ f_matchdelete(argvars, rettv)
+     typval_T	*argvars;
+     typval_T	*rettv;
+ {
+ #ifdef FEAT_SEARCH_EXTRA
+     rettv->vval.v_number = match_delete(curwin,
+ 				       (int)get_tv_number(&argvars[0]), TRUE);
+ #endif
+ }
+ 
+ /*
   * "matchend()" function
   */
      static void
***************
*** 14506,14511 ****
--- 14622,14687 ----
      win = find_win_by_nr(&argvars[0], NULL);
      if (win != NULL)
  	set_qf_ll_list(win, &argvars[1], &argvars[2], rettv);
+ }
+ 
+ /*
+  * "setmatches()" function
+  */
+     static void
+ f_setmatches(argvars, rettv)
+     typval_T	*argvars;
+     typval_T	*rettv;
+ {
+ #ifdef FEAT_SEARCH_EXTRA
+     list_T	*l;
+     listitem_T	*li;
+     dict_T	*d;
+ 
+     rettv->vval.v_number = -1;
+     if (argvars[0].v_type != VAR_LIST)
+     {
+ 	EMSG(_(e_listreq));
+ 	return;
+     }
+     if ((l = argvars[0].vval.v_list) != NULL)
+     {
+ 
+ 	/* To some extent make sure that we are dealing with a list from
+ 	 * "getmatches()". */
+ 	li = l->lv_first;
+ 	while (li != NULL)
+ 	{
+ 	    if (li->li_tv.v_type != VAR_DICT
+ 		    || (d = li->li_tv.vval.v_dict) == NULL)
+ 	    {
+ 		EMSG(_(e_invarg));
+ 		return;
+ 	    }
+ 	    if (!(dict_find(d, (char_u *)"group", -1) != NULL
+ 			&& dict_find(d, (char_u *)"pattern", -1) != NULL
+ 			&& dict_find(d, (char_u *)"priority", -1) != NULL
+ 			&& dict_find(d, (char_u *)"id", -1) != NULL))
+ 	    {
+ 		EMSG(_(e_invarg));
+ 		return;
+ 	    }
+ 	    li = li->li_next;
+ 	}
+ 
+ 	clear_matches(curwin);
+ 	li = l->lv_first;
+ 	while (li != NULL)
+ 	{
+ 	    d = li->li_tv.vval.v_dict;
+ 	    match_add(curwin, get_dict_string(d, (char_u *)"group", FALSE),
+ 		    get_dict_string(d, (char_u *)"pattern", FALSE),
+ 		    (int)get_dict_number(d, (char_u *)"priority"),
+ 		    (int)get_dict_number(d, (char_u *)"id"));
+ 	    li = li->li_next;
+ 	}
+ 	rettv->vval.v_number = 0;
+     }
+ #endif
  }
  
  /*
*** ../vim-7.1.039/src/ex_docmd.c	Tue Jul 24 14:32:44 2007
--- src/ex_docmd.c	Tue Jul 24 15:47:01 2007
***************
*** 10817,10828 ****
      exarg_T	*eap;
  {
      char_u	*p;
      char_u	*end;
      int		c;
!     int		mi;
  
      if (eap->line2 <= 3)
! 	mi = eap->line2 - 1;
      else
      {
  	EMSG(e_invcmd);
--- 10817,10829 ----
      exarg_T	*eap;
  {
      char_u	*p;
+     char_u	*g;
      char_u	*end;
      int		c;
!     int		id;
  
      if (eap->line2 <= 3)
! 	id = eap->line2;
      else
      {
  	EMSG(e_invcmd);
***************
*** 10831,10843 ****
  
      /* First clear any old pattern. */
      if (!eap->skip)
!     {
! 	vim_free(curwin->w_match[mi].regprog);
! 	curwin->w_match[mi].regprog = NULL;
! 	vim_free(curwin->w_match_pat[mi]);
! 	curwin->w_match_pat[mi] = NULL;
! 	redraw_later(SOME_VALID);	/* always need a redraw */
!     }
  
      if (ends_excmd(*eap->arg))
  	end = eap->arg;
--- 10832,10838 ----
  
      /* First clear any old pattern. */
      if (!eap->skip)
! 	match_delete(curwin, id, FALSE);
  
      if (ends_excmd(*eap->arg))
  	end = eap->arg;
***************
*** 10848,10862 ****
      {
  	p = skiptowhite(eap->arg);
  	if (!eap->skip)
! 	{
! 	    curwin->w_match_id[mi] = syn_namen2id(eap->arg,
! 							 (int)(p - eap->arg));
! 	    if (curwin->w_match_id[mi] == 0)
! 	    {
! 		EMSG2(_(e_nogroup), eap->arg);
! 		return;
! 	    }
! 	}
  	p = skipwhite(p);
  	if (*p == NUL)
  	{
--- 10843,10849 ----
      {
  	p = skiptowhite(eap->arg);
  	if (!eap->skip)
! 	    g = vim_strnsave(eap->arg, (int)(p - eap->arg));
  	p = skipwhite(p);
  	if (*p == NUL)
  	{
***************
*** 10880,10893 ****
  
  	    c = *end;
  	    *end = NUL;
! 	    curwin->w_match[mi].regprog = vim_regcomp(p + 1, RE_MAGIC);
! 	    if (curwin->w_match[mi].regprog == NULL)
! 	    {
! 		EMSG2(_(e_invarg2), p);
! 		*end = c;
! 		return;
! 	    }
! 	    curwin->w_match_pat[mi] = vim_strsave(p + 1);
  	    *end = c;
  	}
      }
--- 10867,10874 ----
  
  	    c = *end;
  	    *end = NUL;
! 	    match_add(curwin, g, p + 1, 10, id);
! 	    vim_free(g);
  	    *end = c;
  	}
      }
*** ../vim-7.1.039/src/proto/window.pro	Sat May  5 19:52:36 2007
--- src/proto/window.pro	Tue Jul 24 16:38:19 2007
***************
*** 59,62 ****
--- 59,66 ----
  int only_one_window __ARGS((void));
  void check_lnums __ARGS((int do_curwin));
  int win_hasvertsplit __ARGS((void));
+ int match_add __ARGS((win_T *wp, char_u *grp, char_u *pat, int prio, int id));
+ int match_delete __ARGS((win_T *wp, int id, int perr));
+ void clear_matches __ARGS((win_T *wp));
+ matchitem_T *get_match __ARGS((win_T *wp, int id));
  /* vim: set ft=c : */
*** ../vim-7.1.039/src/screen.c	Tue Jun 19 17:49:12 2007
--- src/screen.c	Thu Jul 26 21:55:40 2007
***************
*** 100,126 ****
  static int	screen_cur_row, screen_cur_col;	/* last known cursor position */
  
  #ifdef FEAT_SEARCH_EXTRA
- /*
-  * Struct used for highlighting 'hlsearch' matches for the last use search
-  * pattern or a ":match" item.
-  * For 'hlsearch' there is one pattern for all windows.  For ":match" there is
-  * a different pattern for each window.
-  */
- typedef struct
- {
-     regmmatch_T	rm;	/* points to the regexp program; contains last found
- 			   match (may continue in next line) */
-     buf_T	*buf;	/* the buffer to search for a match */
-     linenr_T	lnum;	/* the line to search for a match */
-     int		attr;	/* attributes to be used for a match */
-     int		attr_cur; /* attributes currently active in win_line() */
-     linenr_T	first_lnum;	/* first lnum to search for multi-line pat */
-     colnr_T	startcol; /* in win_line() points to char where HL starts */
-     colnr_T	endcol;	 /* in win_line() points to char where HL ends */
- } match_T;
- 
  static match_T search_hl;	/* used for 'hlsearch' highlight matching */
- static match_T match_hl[3];	/* used for ":match" highlight matching */
  #endif
  
  #ifdef FEAT_FOLDING
--- 100,106 ----
***************
*** 155,160 ****
--- 135,141 ----
  static void redraw_custum_statusline __ARGS((win_T *wp));
  #endif
  #ifdef FEAT_SEARCH_EXTRA
+ #define SEARCH_HL_PRIORITY 0
  static void start_search_hl __ARGS((void));
  static void end_search_hl __ARGS((void));
  static void prepare_search_hl __ARGS((win_T *wp, linenr_T lnum));
***************
*** 787,792 ****
--- 768,774 ----
  					   w_topline got smaller a bit */
  #endif
  #ifdef FEAT_SEARCH_EXTRA
+     matchitem_T *cur;		/* points to the match list */
      int		top_to_mod = FALSE;    /* redraw above mod_top */
  #endif
  
***************
*** 848,865 ****
  #endif
  
  #ifdef FEAT_SEARCH_EXTRA
!     /* Setup for ":match" and 'hlsearch' highlighting.  Disable any previous
       * match */
!     for (i = 0; i < 3; ++i)
      {
! 	match_hl[i].rm = wp->w_match[i];
! 	if (wp->w_match_id[i] == 0)
! 	    match_hl[i].attr = 0;
  	else
! 	    match_hl[i].attr = syn_id2attr(wp->w_match_id[i]);
! 	match_hl[i].buf = buf;
! 	match_hl[i].lnum = 0;
! 	match_hl[i].first_lnum = 0;
      }
      search_hl.buf = buf;
      search_hl.lnum = 0;
--- 830,849 ----
  #endif
  
  #ifdef FEAT_SEARCH_EXTRA
!     /* Setup for match and 'hlsearch' highlighting.  Disable any previous
       * match */
!     cur = wp->w_match_head;
!     while (cur != NULL)
      {
! 	cur->hl.rm = cur->match;
! 	if (cur->hlg_id == 0)
! 	    cur->hl.attr = 0;
  	else
! 	    cur->hl.attr = syn_id2attr(cur->hlg_id);
! 	cur->hl.buf = buf;
! 	cur->hl.lnum = 0;
! 	cur->hl.first_lnum = 0;
! 	cur = cur->next;
      }
      search_hl.buf = buf;
      search_hl.lnum = 0;
***************
*** 923,941 ****
  	     * change in one line may make the Search highlighting in a
  	     * previous line invalid.  Simple solution: redraw all visible
  	     * lines above the change.
! 	     * Same for a ":match" pattern.
  	     */
  	    if (search_hl.rm.regprog != NULL
  					&& re_multiline(search_hl.rm.regprog))
  		top_to_mod = TRUE;
  	    else
! 		for (i = 0; i < 3; ++i)
! 		    if (match_hl[i].rm.regprog != NULL
! 				      && re_multiline(match_hl[i].rm.regprog))
  		    {
  			top_to_mod = TRUE;
  			break;
  		    }
  #endif
  	}
  #ifdef FEAT_FOLDING
--- 907,931 ----
  	     * change in one line may make the Search highlighting in a
  	     * previous line invalid.  Simple solution: redraw all visible
  	     * lines above the change.
! 	     * Same for a match pattern.
  	     */
  	    if (search_hl.rm.regprog != NULL
  					&& re_multiline(search_hl.rm.regprog))
  		top_to_mod = TRUE;
  	    else
! 	    {
! 		cur = wp->w_match_head;
! 		while (cur != NULL)
! 		{
! 		    if (cur->match.regprog != NULL
! 					   && re_multiline(cur->match.regprog))
  		    {
  			top_to_mod = TRUE;
  			break;
  		    }
+ 		    cur = cur->next;
+ 		}
+ 	    }
  #endif
  	}
  #ifdef FEAT_FOLDING
***************
*** 2626,2635 ****
      int		line_attr = 0;		/* atrribute for the whole line */
  #endif
  #ifdef FEAT_SEARCH_EXTRA
!     match_T	*shl;			/* points to search_hl or match_hl */
! #endif
! #if defined(FEAT_SEARCH_EXTRA) || defined(FEAT_MBYTE)
!     int		i;
  #endif
  #ifdef FEAT_ARABIC
      int		prev_c = 0;		/* previous Arabic character */
--- 2634,2646 ----
      int		line_attr = 0;		/* atrribute for the whole line */
  #endif
  #ifdef FEAT_SEARCH_EXTRA
!     matchitem_T *cur;			/* points to the match list */
!     match_T	*shl;			/* points to search_hl or a match */
!     int		shl_flag;		/* flag to indicate whether search_hl
! 					   has been processed or not */
!     int		prevcol_hl_flag;	/* flag to indicate whether prevcol
! 					   equals startcol of search_hl or one
! 					   of the matches */
  #endif
  #ifdef FEAT_ARABIC
      int		prev_c = 0;		/* previous Arabic character */
***************
*** 3074,3085 ****
  
  #ifdef FEAT_SEARCH_EXTRA
      /*
!      * Handle highlighting the last used search pattern and ":match".
!      * Do this for both search_hl and match_hl[3].
       */
!     for (i = 3; i >= 0; --i)
      {
! 	shl = (i == 3) ? &search_hl : &match_hl[i];
  	shl->startcol = MAXCOL;
  	shl->endcol = MAXCOL;
  	shl->attr_cur = 0;
--- 3085,3104 ----
  
  #ifdef FEAT_SEARCH_EXTRA
      /*
!      * Handle highlighting the last used search pattern and matches.
!      * Do this for both search_hl and the match list.
       */
!     cur = wp->w_match_head;
!     shl_flag = FALSE;
!     while (cur != NULL || shl_flag == FALSE)
      {
! 	if (shl_flag == FALSE)
! 	{
! 	    shl = &search_hl;
! 	    shl_flag = TRUE;
! 	}
! 	else
! 	    shl = &cur->hl;
  	shl->startcol = MAXCOL;
  	shl->endcol = MAXCOL;
  	shl->attr_cur = 0;
***************
*** 3122,3127 ****
--- 3141,3148 ----
  		area_highlighting = TRUE;
  	    }
  	}
+ 	if (shl != &search_hl && cur != NULL)
+ 	    cur = cur->next;
      }
  #endif
  
***************
*** 3388,3400 ****
  		 * After end, check for start/end of next match.
  		 * When another match, have to check for start again.
  		 * Watch out for matching an empty string!
! 		 * Do this first for search_hl, then for match_hl, so that
! 		 * ":match" overrules 'hlsearch'.
  		 */
  		v = (long)(ptr - line);
! 		for (i = 3; i >= 0; --i)
! 		{
! 		    shl = (i == 3) ? &search_hl : &match_hl[i];
  		    while (shl->rm.regprog != NULL)
  		    {
  			if (shl->startcol != MAXCOL
--- 3409,3432 ----
  		 * After end, check for start/end of next match.
  		 * When another match, have to check for start again.
  		 * Watch out for matching an empty string!
! 		 * Do this for 'search_hl' and the match list (ordered by
! 		 * priority).
  		 */
  		v = (long)(ptr - line);
! 		cur = wp->w_match_head;
! 		shl_flag = FALSE;
! 		while (cur != NULL || shl_flag == FALSE)
! 		{
! 		    if (shl_flag == FALSE
! 			    && ((cur != NULL
! 				    && cur->priority > SEARCH_HL_PRIORITY)
! 				|| cur == NULL))
! 		    {
! 			shl = &search_hl;
! 			shl_flag = TRUE;
! 		    }
! 		    else
! 			shl = &cur->hl;
  		    while (shl->rm.regprog != NULL)
  		    {
  			if (shl->startcol != MAXCOL
***************
*** 3442,3458 ****
  			}
  			break;
  		    }
  		}
  
! 		/* ":match" highlighting overrules 'hlsearch' */
! 		for (i = 0; i <= 3; ++i)
! 		    if (i == 3)
! 			search_attr = search_hl.attr_cur;
! 		    else if (match_hl[i].attr_cur != 0)
  		    {
! 			search_attr = match_hl[i].attr_cur;
! 			break;
  		    }
  	    }
  #endif
  
--- 3474,3505 ----
  			}
  			break;
  		    }
+ 		    if (shl != &search_hl && cur != NULL)
+ 			cur = cur->next;
  		}
  
! 		/* Use attributes from match with highest priority among
! 		 * 'search_hl' and the match list. */
! 		search_attr = search_hl.attr_cur;
! 		cur = wp->w_match_head;
! 		shl_flag = FALSE;
! 		while (cur != NULL || shl_flag == FALSE)
! 		{
! 		    if (shl_flag == FALSE
! 			    && ((cur != NULL
! 				    && cur->priority > SEARCH_HL_PRIORITY)
! 				|| cur == NULL))
  		    {
! 			shl = &search_hl;
! 			shl_flag = TRUE;
  		    }
+ 		    else
+ 			shl = &cur->hl;
+ 		    if (shl->attr_cur != 0)
+ 			search_attr = shl->attr_cur;
+ 		    if (shl != &search_hl && cur != NULL)
+ 			cur = cur->next;
+ 		}
  	    }
  #endif
  
***************
*** 3613,3618 ****
--- 3660,3667 ----
  			 * Draw it as a space with a composing char. */
  			if (utf_iscomposing(mb_c))
  			{
+ 			    int i;
+ 
  			    for (i = Screen_mco - 1; i > 0; --i)
  				u8cc[i] = u8cc[i - 1];
  			    u8cc[0] = mb_c;
***************
*** 4256,4269 ****
  	     * highlight match at end of line. If it's beyond the last
  	     * char on the screen, just overwrite that one (tricky!)  Not
  	     * needed when a '$' was displayed for 'list'. */
  	    if (lcs_eol == lcs_eol_one
  		    && ((area_attr != 0 && vcol == fromcol && c == NUL)
  #ifdef FEAT_SEARCH_EXTRA
  			/* highlight 'hlsearch' match at end of line */
! 			|| ((prevcol == (long)search_hl.startcol
! 				|| prevcol == (long)match_hl[0].startcol
! 				|| prevcol == (long)match_hl[1].startcol
! 				|| prevcol == (long)match_hl[2].startcol)
  # if defined(LINE_ATTR)
  			    && did_line_attr <= 1
  # endif
--- 4305,4333 ----
  	     * highlight match at end of line. If it's beyond the last
  	     * char on the screen, just overwrite that one (tricky!)  Not
  	     * needed when a '$' was displayed for 'list'. */
+ #ifdef FEAT_SEARCH_EXTRA
+ 	    prevcol_hl_flag = FALSE;
+ 	    if (prevcol == (long)search_hl.startcol)
+ 		prevcol_hl_flag = TRUE;
+ 	    else
+ 	    {
+ 		cur = wp->w_match_head;
+ 		while (cur != NULL)
+ 		{
+ 		    if (prevcol == (long)cur->hl.startcol)
+ 		    {
+ 			prevcol_hl_flag = TRUE;
+ 			break;
+ 		    }
+ 		    cur = cur->next;
+ 		}
+ 	    }
+ #endif
  	    if (lcs_eol == lcs_eol_one
  		    && ((area_attr != 0 && vcol == fromcol && c == NUL)
  #ifdef FEAT_SEARCH_EXTRA
  			/* highlight 'hlsearch' match at end of line */
! 			|| (prevcol_hl_flag == TRUE
  # if defined(LINE_ATTR)
  			    && did_line_attr <= 1
  # endif
***************
*** 4304,4318 ****
  #ifdef FEAT_SEARCH_EXTRA
  		if (area_attr == 0)
  		{
! 		    for (i = 0; i <= 3; ++i)
! 		    {
! 			if (i == 3)
! 			    char_attr = search_hl.attr;
! 			else if ((ptr - line) - 1 == (long)match_hl[i].startcol)
  			{
! 			    char_attr = match_hl[i].attr;
! 			    break;
  			}
  		    }
  		}
  #endif
--- 4368,4394 ----
  #ifdef FEAT_SEARCH_EXTRA
  		if (area_attr == 0)
  		{
! 		    /* Use attributes from match with highest priority among
! 		     * 'search_hl' and the match list. */
! 		    char_attr = search_hl.attr;
! 		    cur = wp->w_match_head;
! 		    shl_flag = FALSE;
! 		    while (cur != NULL || shl_flag == FALSE)
! 		    {
! 			if (shl_flag == FALSE
! 				&& ((cur != NULL
! 					&& cur->priority > SEARCH_HL_PRIORITY)
! 				    || cur == NULL))
  			{
! 			    shl = &search_hl;
! 			    shl_flag = TRUE;
  			}
+ 			else
+ 			    shl = &cur->hl;
+ 			if ((ptr - line) - 1 == (long)shl->startcol)
+ 			    char_attr = shl->attr;
+ 			if (shl != &search_hl && cur != NULL)
+ 			    cur = cur->next;
  		    }
  		}
  #endif
***************
*** 4462,4467 ****
--- 4538,4545 ----
  	    {
  		if (mb_utf8)
  		{
+ 		    int i;
+ 
  		    ScreenLinesUC[off] = mb_c;
  		    if ((c & 0xff) == 0)
  			ScreenLines[off] = 0x80;   /* avoid storing zero */
***************
*** 6320,6326 ****
  
  #ifdef FEAT_SEARCH_EXTRA
  /*
!  * Prepare for 'searchhl' highlighting.
   */
      static void
  start_search_hl()
--- 6398,6404 ----
  
  #ifdef FEAT_SEARCH_EXTRA
  /*
!  * Prepare for 'hlsearch' highlighting.
   */
      static void
  start_search_hl()
***************
*** 6333,6339 ****
  }
  
  /*
!  * Clean up for 'searchhl' highlighting.
   */
      static void
  end_search_hl()
--- 6411,6417 ----
  }
  
  /*
!  * Clean up for 'hlsearch' highlighting.
   */
      static void
  end_search_hl()
***************
*** 6353,6370 ****
      win_T	*wp;
      linenr_T	lnum;
  {
!     match_T	*shl;		/* points to search_hl or match_hl */
      int		n;
-     int		i;
  
      /*
       * When using a multi-line pattern, start searching at the top
       * of the window or just after a closed fold.
!      * Do this both for search_hl and match_hl[3].
       */
!     for (i = 3; i >= 0; --i)
      {
! 	shl = (i == 3) ? &search_hl : &match_hl[i];
  	if (shl->rm.regprog != NULL
  		&& shl->lnum == 0
  		&& re_multiline(shl->rm.regprog))
--- 6431,6458 ----
      win_T	*wp;
      linenr_T	lnum;
  {
!     matchitem_T *cur;		/* points to the match list */
!     match_T	*shl;		/* points to search_hl or a match */
!     int		shl_flag;	/* flag to indicate whether search_hl
! 				   has been processed or not */
      int		n;
  
      /*
       * When using a multi-line pattern, start searching at the top
       * of the window or just after a closed fold.
!      * Do this both for search_hl and the match list.
       */
!     cur = wp->w_match_head;
!     shl_flag = FALSE;
!     while (cur != NULL || shl_flag == FALSE)
      {
! 	if (shl_flag == FALSE)
! 	{
! 	    shl = &search_hl;
! 	    shl_flag = TRUE;
! 	}
! 	else
! 	    shl = &cur->hl;
  	if (shl->rm.regprog != NULL
  		&& shl->lnum == 0
  		&& re_multiline(shl->rm.regprog))
***************
*** 6399,6409 ****
  		}
  	    }
  	}
      }
  }
  
  /*
!  * Search for a next 'searchl' or ":match" match.
   * Uses shl->buf.
   * Sets shl->lnum and shl->rm contents.
   * Note: Assumes a previous match is always before "lnum", unless
--- 6487,6499 ----
  		}
  	    }
  	}
+ 	if (shl != &search_hl && cur != NULL)
+ 	    cur = cur->next;
      }
  }
  
  /*
!  * Search for a next 'hlsearch' or match.
   * Uses shl->buf.
   * Sets shl->lnum and shl->rm contents.
   * Note: Assumes a previous match is always before "lnum", unless
***************
*** 6413,6419 ****
      static void
  next_search_hl(win, shl, lnum, mincol)
      win_T	*win;
!     match_T	*shl;		/* points to search_hl or match_hl */
      linenr_T	lnum;
      colnr_T	mincol;		/* minimal column for a match */
  {
--- 6503,6509 ----
      static void
  next_search_hl(win, shl, lnum, mincol)
      win_T	*win;
!     match_T	*shl;		/* points to search_hl or a match */
      linenr_T	lnum;
      colnr_T	mincol;		/* minimal column for a match */
  {
***************
*** 6481,6487 ****
  	    /* Error while handling regexp: stop using this regexp. */
  	    if (shl == &search_hl)
  	    {
! 		/* don't free the regprog in match_hl[], it's a copy */
  		vim_free(shl->rm.regprog);
  		no_hlsearch = TRUE;
  	    }
--- 6571,6577 ----
  	    /* Error while handling regexp: stop using this regexp. */
  	    if (shl == &search_hl)
  	    {
! 		/* don't free regprog in the match list, it's a copy */
  		vim_free(shl->rm.regprog);
  		no_hlsearch = TRUE;
  	    }
*** ../vim-7.1.039/src/structs.h	Thu May 10 20:32:30 2007
--- src/structs.h	Wed Jul 25 21:08:46 2007
***************
*** 1694,1699 ****
--- 1694,1734 ----
  #define FR_COL	2	/* frame with a column of windows */
  
  /*
+  * Struct used for highlighting 'hlsearch' matches, matches defined by
+  * ":match" and matches defined by match functions.
+  * For 'hlsearch' there is one pattern for all windows.  For ":match" and the
+  * match functions there is a different pattern for each window.
+  */
+ typedef struct
+ {
+     regmmatch_T	rm;	/* points to the regexp program; contains last found
+ 			   match (may continue in next line) */
+     buf_T	*buf;	/* the buffer to search for a match */
+     linenr_T	lnum;	/* the line to search for a match */
+     int		attr;	/* attributes to be used for a match */
+     int		attr_cur; /* attributes currently active in win_line() */
+     linenr_T	first_lnum;	/* first lnum to search for multi-line pat */
+     colnr_T	startcol; /* in win_line() points to char where HL starts */
+     colnr_T	endcol;	 /* in win_line() points to char where HL ends */
+ } match_T;
+ 
+ /*
+  * matchitem_T provides a linked list for storing match items for ":match" and
+  * the match functions.
+  */
+ typedef struct matchitem matchitem_T;
+ struct matchitem
+ {
+     matchitem_T	*next;
+     int		id;	    /* match ID */
+     int		priority;   /* match priority */
+     char_u	*pattern;   /* pattern to highlight */
+     int		hlg_id;	    /* highlight group ID */
+     regmmatch_T	match;	    /* regexp program for pattern */
+     match_T	hl;	    /* struct for doing the actual highlighting */
+ };
+ 
+ /*
   * Structure which contains all information that belongs to a window
   *
   * All row numbers are relative to the start of the window, except w_winrow.
***************
*** 1934,1942 ****
  #endif
  
  #ifdef FEAT_SEARCH_EXTRA
!     regmmatch_T	w_match[3];	    /* regexp programs for ":match" */
!     char_u	*(w_match_pat[3]);  /* patterns for ":match" */
!     int		w_match_id[3];	    /* highlight IDs for ":match" */
  #endif
  
      /*
--- 1969,1976 ----
  #endif
  
  #ifdef FEAT_SEARCH_EXTRA
!     matchitem_T	*w_match_head;		/* head of match list */
!     int		w_next_match_id;	/* next match ID */
  #endif
  
      /*
*** ../vim-7.1.039/src/syntax.c	Tue Jul 24 14:32:44 2007
--- src/syntax.c	Tue Jul 24 15:47:01 2007
***************
*** 8504,8510 ****
  syn_id2name(id)
      int		id;
  {
!     if (id <= 0 || id >= highlight_ga.ga_len)
  	return (char_u *)"";
      return HL_TABLE()[id - 1].sg_name;
  }
--- 8504,8510 ----
  syn_id2name(id)
      int		id;
  {
!     if (id <= 0 || id > highlight_ga.ga_len)
  	return (char_u *)"";
      return HL_TABLE()[id - 1].sg_name;
  }
*** ../vim-7.1.039/src/testdir/Makefile	Sun Apr 30 20:48:47 2006
--- src/testdir/Makefile	Tue Jul 24 15:34:33 2007
***************
*** 1,5 ****
  #
! # Makefile to run al tests for Vim
  #
  
  VIMPROG = ../vim
--- 1,5 ----
  #
! # Makefile to run all tests for Vim
  #
  
  VIMPROG = ../vim
***************
*** 15,21 ****
  		test43.out test44.out test45.out test46.out test47.out \
  		test48.out test49.out test51.out test52.out test53.out \
  		test54.out test55.out test56.out test57.out test58.out \
! 		test59.out test60.out test61.out test62.out
  
  SCRIPTS_GUI = test16.out
  
--- 15,21 ----
  		test43.out test44.out test45.out test46.out test47.out \
  		test48.out test49.out test51.out test52.out test53.out \
  		test54.out test55.out test56.out test57.out test58.out \
! 		test59.out test60.out test61.out test62.out test63.out
  
  SCRIPTS_GUI = test16.out
  
*** ../vim-7.1.039/src/testdir/test63.in	Tue Jul 24 16:45:02 2007
--- src/testdir/test63.in	Tue Jul 24 15:32:30 2007
***************
*** 0 ****
--- 1,157 ----
+ Test for ":match", ":2match", ":3match", "clearmatches()", "getmatches()",
+ "matchadd()", "matcharg()", "matchdelete()", and "setmatches()".
+ 
+ STARTTEST
+ :so small.vim
+ :" --- Check that "matcharg()" returns the correct group and pattern if a match
+ :" --- is defined.
+ :let @r = "*** Test 1: "
+ :highlight MyGroup1 ctermbg=red
+ :highlight MyGroup2 ctermbg=green
+ :highlight MyGroup3 ctermbg=blue
+ :match MyGroup1 /TODO/
+ :2match MyGroup2 /FIXME/
+ :3match MyGroup3 /XXX/
+ :if matcharg(1) == ['MyGroup1', 'TODO'] && matcharg(2) == ['MyGroup2', 'FIXME'] && matcharg(3) == ['MyGroup3', 'XXX']
+ :  let @r .= "OK\n"
+ :else
+ :  let @r .= "FAILED\n"
+ :endif
+ :" --- Check that "matcharg()" returns an empty list if the argument is not 1,
+ :" --- 2 or 3 (only 0 and 4 are tested).
+ :let @r .= "*** Test 2: "
+ :if matcharg(0) == [] && matcharg(4) == []
+ :  let @r .= "OK\n"
+ :else
+ :  let @r .= "FAILED\n"
+ :endif
+ :" --- Check that "matcharg()" returns ['', ''] if a match is not defined.
+ :let @r .= "*** Test 3: "
+ :match
+ :2match
+ :3match
+ :if matcharg(1) == ['', ''] && matcharg(2) == ['', ''] && matcharg(3) == ['', '']
+ :  let @r .= "OK\n"
+ :else
+ :  let @r .= "FAILED\n"
+ :endif
+ :" --- Check that "matchadd()" and "getmatches()" agree on added matches and
+ :" --- that default values apply.
+ :let @r .= "*** Test 4: "
+ :let m1 = matchadd("MyGroup1", "TODO")
+ :let m2 = matchadd("MyGroup2", "FIXME", 42)
+ :let m3 = matchadd("MyGroup3", "XXX", 60, 17)
+ :if getmatches() == [{'group': 'MyGroup1', 'pattern': 'TODO', 'priority': 10, 'id': 4}, {'group': 'MyGroup2', 'pattern': 'FIXME', 'priority': 42, 'id': 5}, {'group': 'MyGroup3', 'pattern': 'XXX', 'priority': 60, 'id': 17}]
+ :  let @r .= "OK\n"
+ :else
+ :  let @r .= "FAILED\n"
+ :endif
+ :" --- Check that "matchdelete()" deletes the matches defined in the previous
+ :" --- test correctly.
+ :let @r .= "*** Test 5: "
+ :call matchdelete(m1)
+ :call matchdelete(m2)
+ :call matchdelete(m3)
+ :unlet m1
+ :unlet m2
+ :unlet m3
+ :if getmatches() == []
+ :  let @r .= "OK\n"
+ :else
+ :  let @r .= "FAILED\n"
+ :endif
+ :" --- Check that "matchdelete()" returns 0 if succesfull and otherwise -1.
+ :let @r .= "*** Test 6: "
+ :let m = matchadd("MyGroup1", "TODO")
+ :let r1 = matchdelete(m)
+ :let r2 = matchdelete(42)
+ :if r1 == 0 && r2 == -1
+ :  let @r .= "OK\n"
+ :else
+ :  let @r .= "FAILED\n"
+ :endif
+ :unlet m
+ :unlet r1
+ :unlet r2
+ :" --- Check that "clearmatches()" clears all matches defined by ":match" and
+ :" --- "matchadd()".
+ :let @r .= "*** Test 7: "
+ :let m1 = matchadd("MyGroup1", "TODO")
+ :let m2 = matchadd("MyGroup2", "FIXME", 42)
+ :let m3 = matchadd("MyGroup3", "XXX", 60, 17)
+ :match MyGroup1 /COFFEE/
+ :2match MyGroup2 /HUMPPA/
+ :3match MyGroup3 /VIM/
+ :call clearmatches()
+ :if getmatches() == []
+ :  let @r .= "OK\n"
+ :else
+ :  let @r .= "FAILED\n"
+ :endif
+ :unlet m1
+ :unlet m2
+ :unlet m3
+ :" --- Check that "setmatches()" restores a list of matches saved by
+ :" --- "getmatches()" without changes. (Matches with equal priority must also
+ :" --- remain in the same order.)
+ :let @r .= "*** Test 8: "
+ :let m1 = matchadd("MyGroup1", "TODO")
+ :let m2 = matchadd("MyGroup2", "FIXME", 42)
+ :let m3 = matchadd("MyGroup3", "XXX", 60, 17)
+ :match MyGroup1 /COFFEE/
+ :2match MyGroup2 /HUMPPA/
+ :3match MyGroup3 /VIM/
+ :let ml = getmatches()
+ :call clearmatches()
+ :call setmatches(ml)
+ :if getmatches() == ml
+ :  let @r .= "OK\n"
+ :else
+ :  let @r .= "FAILED\n"
+ :endif
+ :call clearmatches()
+ :unlet m1
+ :unlet m2
+ :unlet m3
+ :unlet ml
+ :" --- Check that "setmatches()" will not add two matches with the same ID. The
+ :" --- expected behaviour (for now) is to add the first match but not the
+ :" --- second and to return 0 (even though it is a matter of debate whether
+ :" --- this can be considered succesfull behaviour).
+ :let @r .= "*** Test 9: "
+ :let r1 = setmatches([{'group': 'MyGroup1', 'pattern': 'TODO', 'priority': 10, 'id': 1}, {'group': 'MyGroup2', 'pattern': 'FIXME', 'priority': 10, 'id': 1}])
+ :if getmatches() == [{'group': 'MyGroup1', 'pattern': 'TODO', 'priority': 10, 'id': 1}] && r1 == 0
+ :  let @r .= "OK\n"
+ :else
+ :  let @r .= "FAILED\n"
+ :endif
+ :call clearmatches()
+ :unlet r1
+ :" --- Check that "setmatches()" returns 0 if succesfull and otherwise -1.
+ :" --- (A range of valid and invalid input values are tried out to generate the
+ :" --- return values.)
+ :let @r .= "*** Test 10: "
+ :let rs1 = setmatches([])
+ :let rs2 = setmatches([{'group': 'MyGroup1', 'pattern': 'TODO', 'priority': 10, 'id': 1}])
+ :call clearmatches()
+ :let rf1 = setmatches(0)
+ :let rf2 = setmatches([0])
+ :let rf3 = setmatches([{'wrong key': 'wrong value'}])
+ :if rs1 == 0 && rs2 == 0 && rf1 == -1 && rf2 == -1 && rf3 == -1
+ :  let @r .= "OK\n"
+ :else
+ :  let @r .= "FAILED\n"
+ :endif
+ :unlet rs1
+ :unlet rs2
+ :unlet rf1
+ :unlet rf2
+ :unlet rf3
+ :highlight clear MyGroup1
+ :highlight clear MyGroup2
+ :highlight clear MyGroup3
+ G"rp
+ :/^Results/,$wq! test.out
+ ENDTEST
+ 
+ Results of test63:
*** ../vim-7.1.039/src/testdir/test63.ok	Tue Jul 24 16:45:02 2007
--- src/testdir/test63.ok	Tue Jul 24 15:32:30 2007
***************
*** 0 ****
--- 1,11 ----
+ Results of test63:
+ *** Test 1: OK
+ *** Test 2: OK
+ *** Test 3: OK
+ *** Test 4: OK
+ *** Test 5: OK
+ *** Test 6: OK
+ *** Test 7: OK
+ *** Test 8: OK
+ *** Test 9: OK
+ *** Test 10: OK
*** ../vim-7.1.039/src/window.c	Thu May 10 18:42:26 2007
--- src/window.c	Tue Jul 24 20:38:58 2007
***************
*** 75,80 ****
--- 75,81 ----
  static win_T *restore_snapshot_rec __ARGS((frame_T *sn, frame_T *fr));
  
  #endif /* FEAT_WINDOWS */
+ 
  static win_T *win_alloc __ARGS((win_T *after));
  static void win_new_height __ARGS((win_T *, int));
  
***************
*** 4128,4133 ****
--- 4129,4138 ----
  #ifdef FEAT_AUTOCMD
  	--autocmd_block;
  #endif
+ #ifdef FEAT_SEARCH_EXTRA
+ 	newwin->w_match_head = NULL;
+ 	newwin->w_next_match_id = 4;
+ #endif
      }
      return newwin;
  }
***************
*** 4185,4195 ****
  	vim_free(wp->w_tagstack[i].tagname);
  
      vim_free(wp->w_localdir);
  #ifdef FEAT_SEARCH_EXTRA
!     vim_free(wp->w_match[0].regprog);
!     vim_free(wp->w_match[1].regprog);
!     vim_free(wp->w_match[2].regprog);
  #endif
  #ifdef FEAT_JUMPLIST
      free_jumplist(wp);
  #endif
--- 4190,4200 ----
  	vim_free(wp->w_tagstack[i].tagname);
  
      vim_free(wp->w_localdir);
+ 
  #ifdef FEAT_SEARCH_EXTRA
!     clear_matches(wp);
  #endif
+ 
  #ifdef FEAT_JUMPLIST
      free_jumplist(wp);
  #endif
***************
*** 6172,6176 ****
--- 6177,6351 ----
  		return TRUE;
  
      return FALSE;
+ }
+ #endif
+ 
+ #if defined(FEAT_SEARCH_EXTRA) || defined(PROTO)
+ /*
+  * Add match to the match list of window 'wp'.  The pattern 'pat' will be
+  * highligted with the group 'grp' with priority 'prio'.
+  * Optionally, a desired ID 'id' can be specified (greater than or equal to 1).
+  * If no particular ID is desired, -1 must be specified for 'id'.
+  * Return ID of added match, -1 on failure.
+  */
+     int
+ match_add(wp, grp, pat, prio, id)
+     win_T	*wp;
+     char_u	*grp;
+     char_u	*pat;
+     int		prio;
+     int		id;
+ {
+     matchitem_T *cur;
+     matchitem_T *prev;
+     matchitem_T *m;
+     int		hlg_id;
+     regmmatch_T match;
+ 
+     if (*grp == NUL || *pat == NUL)
+ 	return -1;
+     if (id < -1 || id == 0)
+     {
+ 	EMSGN("E799: Invalid ID: %ld (must be greater than or equal to 1)", id);
+ 	return -1;
+     }
+     if (id != -1)
+     {
+ 	cur = wp->w_match_head;
+ 	while (cur != NULL)
+ 	{
+ 	    if (cur->id == id)
+ 	    {
+ 		EMSGN("E801: ID already taken: %ld", id);
+ 		return -1;
+ 	    }
+ 	    cur = cur->next;
+ 	}
+     }
+     if ((hlg_id = syn_namen2id(grp, STRLEN(grp))) == 0)
+     {
+ 	EMSG2(_(e_nogroup), grp);
+ 	return -1;
+     }
+     if ((match.regprog = vim_regcomp(pat, RE_MAGIC)) == NULL)
+     {
+ 	EMSG2(_(e_invarg2), pat);
+ 	return -1;
+     }
+ 
+     /* Find available match ID. */
+     while (id == -1)
+     {
+ 	cur = wp->w_match_head;
+ 	while (cur != NULL && cur->id != wp->w_next_match_id)
+ 	    cur = cur->next;
+ 	if (cur == NULL)
+ 	    id = wp->w_next_match_id;
+ 	wp->w_next_match_id++;
+     }
+ 
+     /* Build new match. */
+     m = (matchitem_T *)alloc(sizeof(matchitem_T));
+     m->id = id;
+     m->priority = prio;
+     m->pattern = vim_strsave(pat);
+     m->hlg_id = hlg_id;
+     m->match.regprog = match.regprog;
+ 
+     /* Insert new match.  The match list is in ascending order with regard to
+      * the match priorities. */
+     cur = wp->w_match_head;
+     prev = cur;
+     while (cur != NULL && prio >= cur->priority)
+     {
+ 	prev = cur;
+ 	cur = cur->next;
+     }
+     if (cur == prev)
+ 	wp->w_match_head = m;
+     else
+ 	prev->next = m;
+     m->next = cur;
+ 
+     redraw_later(SOME_VALID);
+     return id;
+ }
+ 
+ /*
+  * Delete match with ID 'id' in the match list of window 'wp'.
+  * Print error messages if 'perr' is TRUE.
+  */
+     int
+ match_delete(wp, id, perr)
+     win_T	*wp;
+     int		id;
+     int		perr;
+ {
+     matchitem_T *cur = wp->w_match_head;
+     matchitem_T *prev = cur;
+ 
+     if (id < 1)
+     {
+ 	if (perr == TRUE)
+ 	    EMSGN("E802: Invalid ID: %ld (must be greater than or equal to 1)",
+ 									  id);
+ 	return -1;
+     }
+     while (cur != NULL && cur->id != id)
+     {
+ 	prev = cur;
+ 	cur = cur->next;
+     }
+     if (cur == NULL)
+     {
+ 	if (perr == TRUE)
+ 	    EMSGN("E803: ID not found: %ld", id);
+ 	return -1;
+     }
+     if (cur == prev)
+ 	wp->w_match_head = cur->next;
+     else
+ 	prev->next = cur->next;
+     vim_free(cur->match.regprog);
+     vim_free(cur->pattern);
+     vim_free(cur);
+     redraw_later(SOME_VALID);
+     return 0;
+ }
+ 
+ /*
+  * Delete all matches in the match list of window 'wp'.
+  */
+     void
+ clear_matches(wp)
+     win_T	*wp;
+ {
+     matchitem_T *m;
+ 
+     while (wp->w_match_head != NULL)
+     {
+ 	m = wp->w_match_head->next;
+ 	vim_free(wp->w_match_head->match.regprog);
+ 	vim_free(wp->w_match_head->pattern);
+ 	vim_free(wp->w_match_head);
+ 	wp->w_match_head = m;
+     }
+     redraw_later(SOME_VALID);
+ }
+ 
+ /*
+  * Get match from ID 'id' in window 'wp'.
+  * Return NULL if match not found.
+  */
+     matchitem_T *
+ get_match(wp, id)
+     win_T	*wp;
+     int		id;
+ {
+     matchitem_T *cur = wp->w_match_head;
+ 
+     while (cur != NULL && cur->id != id)
+ 	cur = cur->next;
+     return cur;
  }
  #endif
*** ../vim-7.1.039/src/version.c	Wed Jul 25 22:55:22 2007
--- src/version.c	Thu Jul 26 22:50:54 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     40,
  /**/

-- 
It is hard to understand how a cemetery raised its burial
cost and blamed it on the cost of living.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.041 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.041 (extra, after 7.1.040)
Problem:    Some changes for patch 7.1.0 are in extra files.
Solution:   Update the extra files.
Files:	    src/testdir/Make_amiga.mak, src/testdir/Make_dos.mak,
	    src/testdir/Make_os2.mak, src/testdir/Make_vms.mms


*** ../vim-7.1.040/src/testdir/Make_amiga.mak	Sun Apr 30 20:42:49 2006
--- src/testdir/Make_amiga.mak	Tue Jul 24 15:36:00 2007
***************
*** 25,31 ****
  		test43.out test44.out test45.out test46.out test47.out \
  		test48.out test51.out test53.out test54.out test55.out \
  		test56.out test57.out test58.out test59.out test60.out \
! 		test61.out test62.out
  
  .SUFFIXES: .in .out
  
--- 25,31 ----
  		test43.out test44.out test45.out test46.out test47.out \
  		test48.out test51.out test53.out test54.out test55.out \
  		test56.out test57.out test58.out test59.out test60.out \
! 		test61.out test62.out test63.out
  
  .SUFFIXES: .in .out
  
***************
*** 107,109 ****
--- 107,110 ----
  test60.out: test60.in
  test61.out: test61.in
  test62.out: test62.in
+ test63.out: test63.in
*** ../vim-7.1.040/src/testdir/Make_dos.mak	Sun Apr 30 20:41:13 2006
--- src/testdir/Make_dos.mak	Tue Jul 24 15:37:47 2007
***************
*** 19,25 ****
  		test44.out test45.out test46.out test47.out \
  		test48.out test51.out test53.out test54.out \
  		test55.out test56.out test57.out test58.out test59.out \
! 		test60.out test61.out test62.out
  
  SCRIPTS =	test3.out test4.out test5.out test6.out test7.out \
  		test8.out test9.out test11.out test13.out test14.out \
--- 19,25 ----
  		test44.out test45.out test46.out test47.out \
  		test48.out test51.out test53.out test54.out \
  		test55.out test56.out test57.out test58.out test59.out \
! 		test60.out test61.out test62.out test63.out
  
  SCRIPTS =	test3.out test4.out test5.out test6.out test7.out \
  		test8.out test9.out test11.out test13.out test14.out \
*** ../vim-7.1.040/src/testdir/Make_os2.mak	Sun Apr 30 20:29:29 2006
--- src/testdir/Make_os2.mak	Tue Jul 24 15:39:15 2007
***************
*** 25,31 ****
  		test43.out test44.out test45.out test46.out test47.out \
  		test48.out test51.out test53.out test54.out test55.out \
  		test56.out test57.out test58.out test59.out test60.out \
! 		test61.out test62.out
  
  .SUFFIXES: .in .out
  
--- 25,31 ----
  		test43.out test44.out test45.out test46.out test47.out \
  		test48.out test51.out test53.out test54.out test55.out \
  		test56.out test57.out test58.out test59.out test60.out \
! 		test61.out test62.out test63.out
  
  .SUFFIXES: .in .out
  
*** ../vim-7.1.040/src/testdir/Make_vms.mms	Sun Apr 30 20:51:12 2006
--- src/testdir/Make_vms.mms	Tue Jul 24 15:39:23 2007
***************
*** 4,10 ****
  # Authors:	Zoltan Arpadffy, <arpadffy@polarhome.com>
  #		Sandor Kopanyi,  <sandor.kopanyi@mailbox.hu>
  #
! # Last change:  2006 Apr 30
  #
  # This has been tested on VMS 6.2 to 7.2 on DEC Alpha and VAX.
  # Edit the lines in the Configuration section below to select.
--- 4,10 ----
  # Authors:	Zoltan Arpadffy, <arpadffy@polarhome.com>
  #		Sandor Kopanyi,  <sandor.kopanyi@mailbox.hu>
  #
! # Last change:  2007 Jul 24
  #
  # This has been tested on VMS 6.2 to 7.2 on DEC Alpha and VAX.
  # Edit the lines in the Configuration section below to select.
***************
*** 59,65 ****
  	 test43.out test44.out test45.out test46.out \
  	 test48.out test51.out test53.out test54.out test55.out \
  	 test56.out test57.out test58.out test59.out test60.out \
! 	 test61.out test62.out
  
  .IFDEF WANT_GUI
  SCRIPT_GUI = test16.out
--- 59,65 ----
  	 test43.out test44.out test45.out test46.out \
  	 test48.out test51.out test53.out test54.out test55.out \
  	 test56.out test57.out test58.out test59.out test60.out \
! 	 test61.out test62.out test63.out
  
  .IFDEF WANT_GUI
  SCRIPT_GUI = test16.out
*** ../vim-7.1.040/src/version.c	Thu Jul 26 22:55:11 2007
--- src/version.c	Thu Jul 26 22:58:57 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     41,
  /**/

-- 
Just remember...if the world didn't suck, we'd all fall off.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.042
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.042 (after 7.1.040)
Problem:    Internal error when using matchadd(). (David Larson)
Solution:   Check the third argument to be present before using the fourth
	    argument. (Martin Toft)
Files:	    src/eval.c


*** ../vim-7.1.041/src/eval.c	Thu Jul 26 22:55:11 2007
--- src/eval.c	Fri Jul 27 21:29:39 2007
***************
*** 7108,7114 ****
      {"getftype",	1, 1, f_getftype},
      {"getline",		1, 2, f_getline},
      {"getloclist",	1, 1, f_getqflist},
!     {"getmatches",  	0, 0, f_getmatches},
      {"getpos",		1, 1, f_getpos},
      {"getqflist",	0, 0, f_getqflist},
      {"getreg",		0, 2, f_getreg},
--- 7108,7114 ----
      {"getftype",	1, 1, f_getftype},
      {"getline",		1, 2, f_getline},
      {"getloclist",	1, 1, f_getqflist},
!     {"getmatches",	0, 0, f_getmatches},
      {"getpos",		1, 1, f_getpos},
      {"getqflist",	0, 0, f_getqflist},
      {"getreg",		0, 2, f_getreg},
***************
*** 12526,12534 ****
      if (grp == NULL || pat == NULL)
  	return;
      if (argvars[2].v_type != VAR_UNKNOWN)
  	prio = get_tv_number_chk(&argvars[2], &error);
!     if (argvars[3].v_type != VAR_UNKNOWN)
! 	id = get_tv_number_chk(&argvars[3], &error);
      if (error == TRUE)
  	return;
      if (id >= 1 && id <= 3)
--- 12526,12536 ----
      if (grp == NULL || pat == NULL)
  	return;
      if (argvars[2].v_type != VAR_UNKNOWN)
+     {
  	prio = get_tv_number_chk(&argvars[2], &error);
! 	if (argvars[3].v_type != VAR_UNKNOWN)
! 	    id = get_tv_number_chk(&argvars[3], &error);
!     }
      if (error == TRUE)
  	return;
      if (id >= 1 && id <= 3)
*** ../vim-7.1.041/src/version.c	Thu Jul 26 23:10:50 2007
--- src/version.c	Fri Jul 27 21:31:13 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     42,
  /**/

-- 
The future isn't what it used to be.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.043
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.043
Problem:    In Ex mode using CTRL-D twice may cause a crash.  Cursor isn't
	    positioned properly after CTRL-D.
Solution:   Set prev_char properly.  Position the cursor correctly. (Antony
	    Scriven)
Files:	    src/ex_getln.c


*** ../vim-7.1.042/src/ex_getln.c	Tue Jul 24 14:32:44 2007
--- src/ex_getln.c	Wed Jul 25 20:57:05 2007
***************
*** 2095,2105 ****
      garray_T	line_ga;
      char_u	*pend;
      int		startcol = 0;
!     int		c1;
      int		escaped = FALSE;	/* CTRL-V typed */
      int		vcol = 0;
      char_u	*p;
!     int		prev_char = 0;
  
      /* Switch cursor on now.  This avoids that it happens after the "\n", which
       * confuses the system function that computes tabstops. */
--- 2095,2105 ----
      garray_T	line_ga;
      char_u	*pend;
      int		startcol = 0;
!     int		c1 = 0;
      int		escaped = FALSE;	/* CTRL-V typed */
      int		vcol = 0;
      char_u	*p;
!     int		prev_char;
  
      /* Switch cursor on now.  This avoids that it happens after the "\n", which
       * confuses the system function that computes tabstops. */
***************
*** 2152,2157 ****
--- 2152,2158 ----
  
  	/* Get one character at a time.  Don't use inchar(), it can't handle
  	 * special characters. */
+ 	prev_char = c1;
  	c1 = vgetc();
  
  	/*
***************
*** 2209,2215 ****
  redraw:
  		/* redraw the line */
  		msg_col = startcol;
- 		windgoto(msg_row, msg_col);
  		vcol = 0;
  		for (p = (char_u *)line_ga.ga_data;
  			  p < (char_u *)line_ga.ga_data + line_ga.ga_len; ++p)
--- 2210,2215 ----
***************
*** 2228,2233 ****
--- 2228,2234 ----
  		    }
  		}
  		msg_clr_eos();
+ 		windgoto(msg_row, msg_col);
  		continue;
  	    }
  
***************
*** 2273,2279 ****
  	if (IS_SPECIAL(c1))
  	    c1 = '?';
  	((char_u *)line_ga.ga_data)[line_ga.ga_len] = c1;
- 	prev_char = c1;
  	if (c1 == '\n')
  	    msg_putchar('\n');
  	else if (c1 == TAB)
--- 2274,2279 ----
*** ../vim-7.1.042/src/version.c	Fri Jul 27 21:32:13 2007
--- src/version.c	Sat Jul 28 14:19:37 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     43,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
48. You get a tatoo that says "This body best viewed with Netscape 3.1 or
    higher."

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.044
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.044
Problem:    In Insert mode 0 CTRL-T deletes all indent, it should add indent.
	    (Gautam Iyer)
Solution:   Check for CTRL-D typed.
Files:	    src/edit.c


*** ../vim-7.1.043/src/edit.c	Thu Jun 28 12:44:56 2007
--- src/edit.c	Wed Jul 25 22:50:28 2007
***************
*** 8000,8006 ****
      /*
       * 0^D and ^^D: remove all indent.
       */
!     if ((lastc == '0' || lastc == '^') && curwin->w_cursor.col)
      {
  	--curwin->w_cursor.col;
  	(void)del_char(FALSE);		/* delete the '^' or '0' */
--- 8000,8007 ----
      /*
       * 0^D and ^^D: remove all indent.
       */
!     if (c == Ctrl_D && (lastc == '0' || lastc == '^')
! 						  && curwin->w_cursor.col > 0)
      {
  	--curwin->w_cursor.col;
  	(void)del_char(FALSE);		/* delete the '^' or '0' */
*** ../vim-7.1.043/src/version.c	Sat Jul 28 14:21:04 2007
--- src/version.c	Sun Jul 29 14:14:36 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     44,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
54. You start tilting your head sideways to smile. :-)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.045
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.045
Problem:    Unnecessary screen redrawing. (Jjgod Jiang)
Solution:   Reset "must_redraw" after clearing the screen.
Files:	    src/screen.c


*** ../vim-7.1.044/src/screen.c	Thu Jul 26 22:55:11 2007
--- src/screen.c	Mon Jul 30 21:39:32 2007
***************
*** 331,336 ****
--- 331,341 ----
      {
  	if (type < must_redraw)	    /* use maximal type */
  	    type = must_redraw;
+ 
+ 	/* must_redraw is reset here, so that when we run into some weird
+ 	 * reason to redraw while busy redrawing (e.g., asynchronous
+ 	 * scrolling), or update_topline() in win_update() will cause a
+ 	 * scroll, the screen will be redrawn later or in win_update(). */
  	must_redraw = 0;
      }
  
***************
*** 1019,1024 ****
--- 1024,1036 ----
  	    type = VALID;
      }
  
+     /* Trick: we want to avoid clearning the screen twice.  screenclear() will
+      * set "screen_cleared" to TRUE.  The special value MAYBE (which is still
+      * non-zero and thus not FALSE) will indicate that screenclear() was not
+      * called. */
+     if (screen_cleared)
+ 	screen_cleared = MAYBE;
+ 
      /*
       * If there are no changes on the screen that require a complete redraw,
       * handle three cases:
***************
*** 1220,1226 ****
  	    mid_end = wp->w_height;
  	    if (lastwin == firstwin)
  	    {
! 		screenclear();
  #ifdef FEAT_WINDOWS
  		/* The screen was cleared, redraw the tab pages line. */
  		if (redraw_tabline)
--- 1232,1242 ----
  	    mid_end = wp->w_height;
  	    if (lastwin == firstwin)
  	    {
! 		/* Clear the screen when it was not done by win_del_lines() or
! 		 * win_ins_lines() above, "screen_cleared" is FALSE or MAYBE
! 		 * then. */
! 		if (screen_cleared != TRUE)
! 		    screenclear();
  #ifdef FEAT_WINDOWS
  		/* The screen was cleared, redraw the tab pages line. */
  		if (redraw_tabline)
***************
*** 1228,1233 ****
--- 1244,1256 ----
  #endif
  	    }
  	}
+ 
+ 	/* When win_del_lines() or win_ins_lines() caused the screen to be
+ 	 * cleared (only happens for the first window) or when screenclear()
+ 	 * was called directly above, "must_redraw" will have been set to
+ 	 * NOT_VALID, need to reset it here to avoid redrawing twice. */
+ 	if (screen_cleared == TRUE)
+ 	    must_redraw = 0;
      }
      else
      {
*** ../vim-7.1.044/src/version.c	Sun Jul 29 15:02:34 2007
--- src/version.c	Mon Jul 30 21:58:06 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     45,
  /**/

-- 
Be thankful to be in a traffic jam, because it means you own a car.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.046
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.046
Problem:    ":s" command removes combining characters. (Ron Aaron)
Solution:   Copy composing characters individually. (Chris Lubinski)
Files:	    src/regexp.c


*** ../vim-7.1.045/src/regexp.c	Thu May 10 19:58:01 2007
--- src/regexp.c	Fri Jul 27 21:17:47 2007
***************
*** 7014,7020 ****
  #ifdef FEAT_MBYTE
  			    if (has_mbyte)
  			    {
! 				int l = mb_ptr2len(s) - 1;
  
  				s += l;
  				len -= l;
--- 7014,7027 ----
  #ifdef FEAT_MBYTE
  			    if (has_mbyte)
  			    {
! 				int l;
! 
! 				/* Copy composing characters separately, one
! 				 * at a time. */
! 				if (enc_utf8)
! 				    l = utf_ptr2len(s) - 1;
! 				else
! 				    l = mb_ptr2len(s) - 1;
  
  				s += l;
  				len -= l;
*** ../vim-7.1.045/src/version.c	Mon Jul 30 21:59:50 2007
--- src/version.c	Mon Jul 30 22:30:02 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     46,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
57. You begin to wonder how on earth your service provider is allowed to call
    200 hours per month "unlimited."

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.047
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.047
Problem:    vim_regcomp() called with invalid argument. (Xiaozhou Liu)
Solution:   Change TRUE to RE_MAGIC + RE_STRING.
Files:	    src/ex_eval.c


*** ../vim-7.1.046/src/ex_eval.c	Thu May 10 20:23:50 2007
--- src/ex_eval.c	Sat Jul 28 13:09:00 2007
***************
*** 1551,1557 ****
  		}
  		save_cpo  = p_cpo;
  		p_cpo = (char_u *)"";
! 		regmatch.regprog = vim_regcomp(pat, TRUE);
  		regmatch.rm_ic = FALSE;
  		if (end != NULL)
  		    *end = save_char;
--- 1551,1557 ----
  		}
  		save_cpo  = p_cpo;
  		p_cpo = (char_u *)"";
! 		regmatch.regprog = vim_regcomp(pat, RE_MAGIC + RE_STRING);
  		regmatch.rm_ic = FALSE;
  		if (end != NULL)
  		    *end = save_char;
*** ../vim-7.1.046/src/version.c	Mon Jul 30 22:32:11 2007
--- src/version.c	Wed Aug  1 15:46:28 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     47,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
80. At parties, you introduce your spouse as your "service provider."

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.048
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.048
Problem:    The matchparen plugin doesn't update the match when scrolling with
	    the mouse wheel. (Ilya Bobir)
Solution:   Set the match highlighting for text that can be scrolled into the
	    viewable area without moving the cursor. (Chris Lubinski)
Files:	    runtime/plugin/matchparen.vim


*** ../vim-7.1.047/runtime/plugin/matchparen.vim	Sun May  6 14:26:16 2007
--- runtime/plugin/matchparen.vim	Mon Jul 30 21:14:06 2007
***************
*** 1,6 ****
  " Vim plugin for showing matching parens
  " Maintainer:  Bram Moolenaar <Bram@vim.org>
! " Last Change: 2006 Oct 12
  
  " Exit quickly when:
  " - this plugin was already loaded (or disabled)
--- 1,6 ----
  " Vim plugin for showing matching parens
  " Maintainer:  Bram Moolenaar <Bram@vim.org>
! " Last Change: 2007 Jul 30
  
  " Exit quickly when:
  " - this plugin was already loaded (or disabled)
***************
*** 62,86 ****
    " Figure out the arguments for searchpairpos().
    " Restrict the search to visible lines with "stopline".
    " And avoid searching very far (e.g., for closed folds and long lines)
    if i % 2 == 0
      let s_flags = 'nW'
      let c2 = plist[i + 1]
      if has("byte_offset") && has("syntax_items") && &smc > 0
        let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
!       let stopline = min([line('w$'), byte2line(stopbyte)])
      else
!       let stopline = min([line('w$'), c_lnum + 100])
      endif
    else
      let s_flags = 'nbW'
      let c2 = c
      let c = plist[i - 1]
      if has("byte_offset") && has("syntax_items") && &smc > 0
        let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
!       let stopline = max([line('w0'), byte2line(stopbyte)])
      else
!       let stopline = max([line('w0'), c_lnum - 100])
      endif
    endif
    if c == '['
      let c = '\['
--- 62,98 ----
    " Figure out the arguments for searchpairpos().
    " Restrict the search to visible lines with "stopline".
    " And avoid searching very far (e.g., for closed folds and long lines)
+   " The "viewable" variables give a range in which we can scroll while keeping
+   " the cursor at the same position
+   " adjustedScrolloff accounts for very large numbers of scrolloff
+   let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
+   let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
+   let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
+   " one of these stoplines will be adjusted below, but the current values are
+   " minimal boundaries within the current window
+   let stoplinebottom = line('w$')
+   let stoplinetop = line('w0')
    if i % 2 == 0
      let s_flags = 'nW'
      let c2 = plist[i + 1]
      if has("byte_offset") && has("syntax_items") && &smc > 0
        let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
!       let stopline = min([bottom_viewable, byte2line(stopbyte)])
      else
!       let stopline = min([bottom_viewable, c_lnum + 100])
      endif
+     let stoplinebottom = stopline
    else
      let s_flags = 'nbW'
      let c2 = c
      let c = plist[i - 1]
      if has("byte_offset") && has("syntax_items") && &smc > 0
        let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
!       let stopline = max([top_viewable, byte2line(stopbyte)])
      else
!       let stopline = max([top_viewable, c_lnum - 100])
      endif
+     let stoplinetop = stopline
    endif
    if c == '['
      let c = '\['
***************
*** 106,112 ****
    endif
  
    " If a match is found setup match highlighting.
!   if m_lnum > 0 && m_lnum >= line('w0') && m_lnum <= line('w$')
      exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) .
  	  \ 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
      let w:paren_hl_on = 1
--- 118,124 ----
    endif
  
    " If a match is found setup match highlighting.
!   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
      exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) .
  	  \ 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
      let w:paren_hl_on = 1
*** ../vim-7.1.047/src/version.c	Wed Aug  1 15:47:06 2007
--- src/version.c	Thu Aug  2 22:59:07 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     48,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
91. It's Saturday afternoon in the middle of May and you
    are on computer.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.049
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.049
Problem:    Cannot compile GTK2 version with Hangul input feature.
Solution:   Don't define FEAT_XFONTSET when using GTK2.
Files:	    src/feature.h


*** ../vim-7.1.048/src/feature.h	Thu May 10 19:43:24 2007
--- src/feature.h	Fri Aug  3 19:32:56 2007
***************
*** 673,679 ****
  # define ESC_CHG_TO_ENG_MODE		/* if defined, when ESC pressed,
  					 * turn to english mode
  					 */
! # if !defined(FEAT_XFONTSET) && defined(HAVE_X11)
  #  define FEAT_XFONTSET			/* Hangul input requires xfontset */
  # endif
  # if defined(FEAT_XIM) && !defined(LINT)
--- 673,679 ----
  # define ESC_CHG_TO_ENG_MODE		/* if defined, when ESC pressed,
  					 * turn to english mode
  					 */
! # if !defined(FEAT_XFONTSET) && defined(HAVE_X11) && !defined(HAVE_GTK2)
  #  define FEAT_XFONTSET			/* Hangul input requires xfontset */
  # endif
  # if defined(FEAT_XIM) && !defined(LINT)
*** ../vim-7.1.048/src/version.c	Thu Aug  2 23:00:06 2007
--- src/version.c	Fri Aug  3 21:58:23 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     49,
  /**/

-- 
From "know your smileys":
 :-O>-o   Smiley American tourist (note big mouth and camera)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.050
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.050
Problem:    Possible crash when using C++ indenting. (Chris Monson)
Solution:   Keep the line pointer to the line to compare with.  Avoid going
	    past the end of line.
Files:	    src/misc1.c


*** ../vim-7.1.049/src/misc1.c	Tue Jul 24 15:25:27 2007
--- src/misc1.c	Fri Aug  3 21:07:17 2007
***************
*** 4820,4826 ****
  static int	cin_iswhileofdo __ARGS((char_u *, linenr_T, int));
  static int	cin_iswhileofdo_end __ARGS((int terminated, int	ind_maxparen, int ind_maxcomment));
  static int	cin_isbreak __ARGS((char_u *));
! static int	cin_is_cpp_baseclass __ARGS((char_u *line, colnr_T *col));
  static int	get_baseclass_amount __ARGS((int col, int ind_maxparen, int ind_maxcomment, int ind_cpp_baseclass));
  static int	cin_ends_in __ARGS((char_u *, char_u *, char_u *));
  static int	cin_skip2pos __ARGS((pos_T *trypos));
--- 4820,4826 ----
  static int	cin_iswhileofdo __ARGS((char_u *, linenr_T, int));
  static int	cin_iswhileofdo_end __ARGS((int terminated, int	ind_maxparen, int ind_maxcomment));
  static int	cin_isbreak __ARGS((char_u *));
! static int	cin_is_cpp_baseclass __ARGS((colnr_T *col));
  static int	get_baseclass_amount __ARGS((int col, int ind_maxparen, int ind_maxcomment, int ind_cpp_baseclass));
  static int	cin_ends_in __ARGS((char_u *, char_u *, char_u *));
  static int	cin_skip2pos __ARGS((pos_T *trypos));
***************
*** 5585,5597 ****
   * This is a lot of guessing.  Watch out for "cond ? func() : foo".
   */
      static int
! cin_is_cpp_baseclass(line, col)
!     char_u	*line;
      colnr_T	*col;	    /* return: column to align with */
  {
      char_u	*s;
      int		class_or_struct, lookfor_ctor_init, cpp_base_class;
      linenr_T	lnum = curwin->w_cursor.lnum;
  
      *col = 0;
  
--- 5585,5597 ----
   * This is a lot of guessing.  Watch out for "cond ? func() : foo".
   */
      static int
! cin_is_cpp_baseclass(col)
      colnr_T	*col;	    /* return: column to align with */
  {
      char_u	*s;
      int		class_or_struct, lookfor_ctor_init, cpp_base_class;
      linenr_T	lnum = curwin->w_cursor.lnum;
+     char_u	*line = ml_get_curline();
  
      *col = 0;
  
***************
*** 5619,5625 ****
       */
      while (lnum > 1)
      {
! 	s = skipwhite(ml_get(lnum - 1));
  	if (*s == '#' || *s == NUL)
  	    break;
  	while (*s != NUL)
--- 5619,5626 ----
       */
      while (lnum > 1)
      {
! 	line = ml_get(lnum - 1);
! 	s = skipwhite(line);
  	if (*s == '#' || *s == NUL)
  	    break;
  	while (*s != NUL)
***************
*** 5636,5642 ****
  	--lnum;
      }
  
!     s = cin_skipcomment(ml_get(lnum));
      for (;;)
      {
  	if (*s == NUL)
--- 5637,5644 ----
  	--lnum;
      }
  
!     line = ml_get(lnum);
!     s = cin_skipcomment(line);
      for (;;)
      {
  	if (*s == NUL)
***************
*** 5644,5650 ****
  	    if (lnum == curwin->w_cursor.lnum)
  		break;
  	    /* Continue in the cursor line. */
! 	    s = cin_skipcomment(ml_get(++lnum));
  	}
  
  	if (s[0] == ':')
--- 5646,5655 ----
  	    if (lnum == curwin->w_cursor.lnum)
  		break;
  	    /* Continue in the cursor line. */
! 	    line = ml_get(++lnum);
! 	    s = cin_skipcomment(line);
! 	    if (*s == NUL)
! 		continue;
  	}
  
  	if (s[0] == ':')
***************
*** 7113,7119 ****
  		n = FALSE;
  		if (lookfor != LOOKFOR_TERM && ind_cpp_baseclass > 0)
  		{
! 		    n = cin_is_cpp_baseclass(l, &col);
  		    l = ml_get_curline();
  		}
  		if (n)
--- 7118,7124 ----
  		n = FALSE;
  		if (lookfor != LOOKFOR_TERM && ind_cpp_baseclass > 0)
  		{
! 		    n = cin_is_cpp_baseclass(&col);
  		    l = ml_get_curline();
  		}
  		if (n)
***************
*** 7704,7710 ****
  		n = FALSE;
  		if (ind_cpp_baseclass != 0 && theline[0] != '{')
  		{
! 		    n = cin_is_cpp_baseclass(l, &col);
  		    l = ml_get_curline();
  		}
  		if (n)
--- 7709,7715 ----
  		n = FALSE;
  		if (ind_cpp_baseclass != 0 && theline[0] != '{')
  		{
! 		    n = cin_is_cpp_baseclass(&col);
  		    l = ml_get_curline();
  		}
  		if (n)
*** ../vim-7.1.049/src/version.c	Fri Aug  3 22:01:35 2007
--- src/version.c	Sat Aug  4 12:11:51 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     50,
  /**/

-- 
From "know your smileys":
 |-P	Reaction to unusually ugly C code

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.051
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.051
Problem:    Accessing uninitialized memory when finding spell suggestions.
Solution:   Don't try swapping characters at the end of a word.
Files:	    src/spell.c


*** ../vim-7.1.050/src/spell.c	Tue Jul 24 10:44:10 2007
--- src/spell.c	Sun Aug  5 16:59:48 2007
***************
*** 12182,12188 ****
  	    {
  		n = mb_cptr2len(p);
  		c = mb_ptr2char(p);
! 		if (!soundfold && !spell_iswordp(p + n, curbuf))
  		    c2 = c; /* don't swap non-word char */
  		else
  		    c2 = mb_ptr2char(p + n);
--- 12182,12190 ----
  	    {
  		n = mb_cptr2len(p);
  		c = mb_ptr2char(p);
! 		if (p[n] == NUL)
! 		    c2 = NUL;
! 		else if (!soundfold && !spell_iswordp(p + n, curbuf))
  		    c2 = c; /* don't swap non-word char */
  		else
  		    c2 = mb_ptr2char(p + n);
***************
*** 12190,12199 ****
  	    else
  #endif
  	    {
! 		if (!soundfold && !spell_iswordp(p + 1, curbuf))
  		    c2 = c; /* don't swap non-word char */
  		else
  		    c2 = p[1];
  	    }
  
  	    /* When characters are identical, swap won't do anything.
--- 12192,12210 ----
  	    else
  #endif
  	    {
! 		if (p[1] == NUL)
! 		    c2 = NUL;
! 		else if (!soundfold && !spell_iswordp(p + 1, curbuf))
  		    c2 = c; /* don't swap non-word char */
  		else
  		    c2 = p[1];
+ 	    }
+ 
+ 	    /* When the second character is NUL we can't swap. */
+ 	    if (c2 == NUL)
+ 	    {
+ 		sp->ts_state = STATE_REP_INI;
+ 		break;
  	    }
  
  	    /* When characters are identical, swap won't do anything.
*** ../vim-7.1.050/src/version.c	Sat Aug  4 12:14:04 2007
--- src/version.c	Sun Aug  5 18:31:09 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     51,
  /**/

-- 
From "know your smileys":
 8<}}	Glasses, big nose, beard

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.052
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.052
Problem:    When creating a new match not all fields are initialized, which
	    may lead to unpredictable results.
Solution:   Initialise rmm_ic and rmm_maxcol.
Files:	    src/window.c


*** ../vim-7.1.051/src/window.c	Thu Jul 26 22:55:11 2007
--- src/window.c	Sun Aug  5 17:17:51 2007
***************
*** 6200,6206 ****
      matchitem_T *prev;
      matchitem_T *m;
      int		hlg_id;
!     regmmatch_T match;
  
      if (*grp == NUL || *pat == NUL)
  	return -1;
--- 6243,6249 ----
      matchitem_T *prev;
      matchitem_T *m;
      int		hlg_id;
!     regprog_T	*regprog;
  
      if (*grp == NUL || *pat == NUL)
  	return -1;
***************
*** 6227,6233 ****
  	EMSG2(_(e_nogroup), grp);
  	return -1;
      }
!     if ((match.regprog = vim_regcomp(pat, RE_MAGIC)) == NULL)
      {
  	EMSG2(_(e_invarg2), pat);
  	return -1;
--- 6270,6276 ----
  	EMSG2(_(e_nogroup), grp);
  	return -1;
      }
!     if ((regprog = vim_regcomp(pat, RE_MAGIC)) == NULL)
      {
  	EMSG2(_(e_invarg2), pat);
  	return -1;
***************
*** 6250,6256 ****
      m->priority = prio;
      m->pattern = vim_strsave(pat);
      m->hlg_id = hlg_id;
!     m->match.regprog = match.regprog;
  
      /* Insert new match.  The match list is in ascending order with regard to
       * the match priorities. */
--- 6293,6301 ----
      m->priority = prio;
      m->pattern = vim_strsave(pat);
      m->hlg_id = hlg_id;
!     m->match.regprog = regprog;
!     m->match.rmm_ic = FALSE;
!     m->match.rmm_maxcol = 0;
  
      /* Insert new match.  The match list is in ascending order with regard to
       * the match priorities. */
*** ../vim-7.1.051/src/version.c	Sun Aug  5 18:32:21 2007
--- src/version.c	Sun Aug  5 18:47:55 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     52,
  /**/

-- 
From "know your smileys":
 8-O 	"Omigod!!" (done "rm -rf *" ?)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.053
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.053
Problem:    Accessing uninitialized memory when giving a message.
Solution:   Check going the length before checking for a NUL byte.
Files:	    src/message.c


*** ../vim-7.1.052/src/message.c	Thu Jul  5 10:10:29 2007
--- src/message.c	Sat Aug  4 23:13:58 2007
***************
*** 1842,1848 ****
      int		wrap;
  
      did_wait_return = FALSE;
!     while (*s != NUL && (maxlen < 0 || (int)(s - str) < maxlen))
      {
  	/*
  	 * We are at the end of the screen line when:
--- 1842,1848 ----
      int		wrap;
  
      did_wait_return = FALSE;
!     while ((maxlen < 0 || (int)(s - str) < maxlen) && *s != NUL)
      {
  	/*
  	 * We are at the end of the screen line when:
*** ../vim-7.1.052/src/version.c	Sun Aug  5 18:49:07 2007
--- src/version.c	Sun Aug  5 19:18:46 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     53,
  /**/

-- 
From "know your smileys":
 <>:-)	Bishop

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.054
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.054
Problem:    Accessing uninitialized memory when displaying the fold column.
Solution:   Add a NUL to the extra array. (Dominique Pelle).  Also do this in
	    a couple of other situations.
Files:	    src/screen.c


*** ../vim-7.1.053/src/screen.c	Mon Jul 30 21:59:50 2007
--- src/screen.c	Sun Aug  5 16:10:53 2007
***************
*** 2555,2561 ****
  
      char_u	extra[18];		/* "%ld" and 'fdc' must fit in here */
      int		n_extra = 0;		/* number of extra chars */
!     char_u	*p_extra = NULL;	/* string of extra chars */
      int		c_extra = NUL;		/* extra chars, all the same */
      int		extra_attr = 0;		/* attributes when n_extra != 0 */
      static char_u *at_end_str = (char_u *)""; /* used for p_extra when
--- 2555,2561 ----
  
      char_u	extra[18];		/* "%ld" and 'fdc' must fit in here */
      int		n_extra = 0;		/* number of extra chars */
!     char_u	*p_extra = NULL;	/* string of extra chars, plus NUL */
      int		c_extra = NUL;		/* extra chars, all the same */
      int		extra_attr = 0;		/* attributes when n_extra != 0 */
      static char_u *at_end_str = (char_u *)""; /* used for p_extra when
***************
*** 3189,3198 ****
  		if (cmdwin_type != 0 && wp == curwin)
  		{
  		    /* Draw the cmdline character. */
- 		    *extra = cmdwin_type;
  		    n_extra = 1;
! 		    p_extra = extra;
! 		    c_extra = NUL;
  		    char_attr = hl_attr(HLF_AT);
  		}
  	    }
--- 3189,3196 ----
  		if (cmdwin_type != 0 && wp == curwin)
  		{
  		    /* Draw the cmdline character. */
  		    n_extra = 1;
! 		    c_extra = cmdwin_type;
  		    char_attr = hl_attr(HLF_AT);
  		}
  	    }
***************
*** 3208,3213 ****
--- 3206,3212 ----
  		    fill_foldcolumn(extra, wp, FALSE, lnum);
  		    n_extra = wp->w_p_fdc;
  		    p_extra = extra;
+ 		    p_extra[n_extra] = NUL;
  		    c_extra = NUL;
  		    char_attr = hl_attr(HLF_FC);
  		}
***************
*** 3550,3558 ****
  	 * Get the next character to put on the screen.
  	 */
  	/*
! 	 * The 'extra' array contains the extra stuff that is inserted to
! 	 * represent special characters (non-printable stuff).  When all
! 	 * characters are the same, c_extra is used.
  	 * For the '$' of the 'list' option, n_extra == 1, p_extra == "".
  	 */
  	if (n_extra > 0)
--- 3549,3559 ----
  	 * Get the next character to put on the screen.
  	 */
  	/*
! 	 * The "p_extra" points to the extra stuff that is inserted to
! 	 * represent special characters (non-printable stuff) and other
! 	 * things.  When all characters are the same, c_extra is used.
! 	 * "p_extra" must end in a NUL to avoid mb_ptr2len() reads past
! 	 * "p_extra[n_extra]".
  	 * For the '$' of the 'list' option, n_extra == 1, p_extra == "".
  	 */
  	if (n_extra > 0)
***************
*** 3808,3817 ****
  		 * a '<' in the first column. */
  		if (n_skip > 0 && mb_l > 1)
  		{
- 		    extra[0] = '<';
- 		    p_extra = extra;
  		    n_extra = 1;
! 		    c_extra = NUL;
  		    c = ' ';
  		    if (area_attr == 0 && search_attr == 0)
  		    {
--- 3809,3816 ----
  		 * a '<' in the first column. */
  		if (n_skip > 0 && mb_l > 1)
  		{
  		    n_extra = 1;
! 		    c_extra = '<';
  		    c = ' ';
  		    if (area_attr == 0 && search_attr == 0)
  		    {
***************
*** 6204,6211 ****
  	return;
  
      off = LineOffset[row] + col;
!     while (*ptr != NUL && col < screen_Columns
! 				      && (len < 0 || (int)(ptr - text) < len))
      {
  	c = *ptr;
  #ifdef FEAT_MBYTE
--- 6203,6211 ----
  	return;
  
      off = LineOffset[row] + col;
!     while (col < screen_Columns
! 	    && (len < 0 || (int)(ptr - text) < len)
! 	    && *ptr != NUL)
      {
  	c = *ptr;
  #ifdef FEAT_MBYTE
*** ../vim-7.1.053/src/version.c	Sun Aug  5 19:20:04 2007
--- src/version.c	Sun Aug  5 20:07:47 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     54,
  /**/

-- 
From "know your smileys":
 +<(:-) The Pope

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.055
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.055
Problem:    Using strcpy() with arguments that overlap.
Solution:   Use mch_memmove() instead.
Files:	    src/buffer.c, src/charset.c, src/eval.c, src/ex_getln.c,
	    src/misc1.c, src/regexp.c, src/termlib.c


*** ../vim-7.1.054/src/buffer.c	Tue Jun 19 15:40:51 2007
--- src/buffer.c	Sun Aug  5 16:14:03 2007
***************
*** 4860,4866 ****
  	     */
  	    for (e = s; *e != ':' && *e != NUL; ++e)
  		if (e[0] == '\\' && e[1] == ':')
! 		    STRCPY(e, e + 1);
  	    if (*e == NUL)
  		end = TRUE;
  
--- 4860,4866 ----
  	     */
  	    for (e = s; *e != ':' && *e != NUL; ++e)
  		if (e[0] == '\\' && e[1] == ':')
! 		    mch_memmove(e, e + 1, STRLEN(e));
  	    if (*e == NUL)
  		end = TRUE;
  
*** ../vim-7.1.054/src/charset.c	Tue Mar 27 12:41:45 2007
--- src/charset.c	Sun Aug  5 21:53:44 2007
***************
*** 1898,1904 ****
  {
      for ( ; *p; ++p)
  	if (rem_backslash(p))
! 	    STRCPY(p, p + 1);
  }
  
  /*
--- 1898,1904 ----
  {
      for ( ; *p; ++p)
  	if (rem_backslash(p))
! 	    mch_memmove(p, p + 1, STRLEN(p));
  }
  
  /*
*** ../vim-7.1.054/src/eval.c	Fri Jul 27 21:32:13 2007
--- src/eval.c	Sun Aug  5 16:25:03 2007
***************
*** 13807,13813 ****
  	    }
  	    /* Shorten "remain". */
  	    if (*q != NUL)
! 		STRCPY(remain, q - 1);
  	    else
  	    {
  		vim_free(remain);
--- 13807,13813 ----
  	    }
  	    /* Shorten "remain". */
  	    if (*q != NUL)
! 		mch_memmove(remain, q - 1, STRLEN(q - 1) + 1);
  	    else
  	    {
  		vim_free(remain);
*** ../vim-7.1.054/src/ex_getln.c	Sat Jul 28 14:21:04 2007
--- src/ex_getln.c	Sun Aug  5 21:55:56 2007
***************
*** 4306,4315 ****
  			    && pat[i + 1] == '\\'
  			    && pat[i + 2] == '\\'
  			    && pat[i + 3] == ' ')
! 			STRCPY(pat + i, pat + i + 3);
  		    if (xp->xp_backslash == XP_BS_ONE
  			    && pat[i + 1] == ' ')
! 			STRCPY(pat + i, pat + i + 1);
  		}
  	}
  
--- 4306,4316 ----
  			    && pat[i + 1] == '\\'
  			    && pat[i + 2] == '\\'
  			    && pat[i + 3] == ' ')
! 			mch_memmove(pat + i, pat + i + 3,
! 						     STRLEN(pat + i + 3) + 1);
  		    if (xp->xp_backslash == XP_BS_ONE
  			    && pat[i + 1] == ' ')
! 			mch_memmove(pat + i, pat + i + 1, STRLEN(pat + i));
  		}
  	}
  
***************
*** 4552,4558 ****
      pat = vim_strsave(filepat);
      for (i = 0; pat[i]; ++i)
  	if (pat[i] == '\\' && pat[i + 1] == ' ')
! 	    STRCPY(pat + i, pat + i + 1);
  
      flags |= EW_FILE | EW_EXEC;
  
--- 4553,4559 ----
      pat = vim_strsave(filepat);
      for (i = 0; pat[i]; ++i)
  	if (pat[i] == '\\' && pat[i + 1] == ' ')
! 	    mch_memmove(pat + i, pat + i + 1, STRLEN(pat + i));
  
      flags |= EW_FILE | EW_EXEC;
  
*** ../vim-7.1.054/src/misc1.c	Sat Aug  4 12:14:04 2007
--- src/misc1.c	Sun Aug  5 21:57:15 2007
***************
*** 8635,8641 ****
      for (p = buf + wildoff; p < s; ++p)
  	if (rem_backslash(p))
  	{
! 	    STRCPY(p, p + 1);
  	    --e;
  	    --s;
  	}
--- 8635,8641 ----
      for (p = buf + wildoff; p < s; ++p)
  	if (rem_backslash(p))
  	{
! 	    mch_memmove(p, p + 1, STRLEN(p));
  	    --e;
  	    --s;
  	}
***************
*** 8936,8942 ****
      for (p = buf + wildoff; p < s; ++p)
  	if (rem_backslash(p))
  	{
! 	    STRCPY(p, p + 1);
  	    --e;
  	    --s;
  	}
--- 8936,8942 ----
      for (p = buf + wildoff; p < s; ++p)
  	if (rem_backslash(p))
  	{
! 	    mch_memmove(p, p + 1, STRLEN(p));
  	    --e;
  	    --s;
  	}
*** ../vim-7.1.054/src/regexp.c	Mon Jul 30 22:32:11 2007
--- src/regexp.c	Sun Aug  5 15:43:27 2007
***************
*** 6637,6645 ****
  		}
  	    }
  	    else if (magic)
! 		STRCPY(p, p + 1);		/* remove '~' */
  	    else
! 		STRCPY(p, p + 2);		/* remove '\~' */
  	    --p;
  	}
  	else
--- 6638,6646 ----
  		}
  	    }
  	    else if (magic)
! 		mch_memmove(p, p + 1, STRLEN(p));	/* remove '~' */
  	    else
! 		mch_memmove(p, p + 2, STRLEN(p) - 1);	/* remove '\~' */
  	    --p;
  	}
  	else
*** ../vim-7.1.054/src/termlib.c	Thu May 10 20:20:59 2007
--- src/termlib.c	Sun Aug  5 21:52:41 2007
***************
*** 191,197 ****
  	    lbuf[0] == '\t' &&
  	    lbuf[1] == ':')
  	{
! 	    strcpy(lbuf, lbuf+2);
  	    llen -= 2;
  	}
  	if (lbuf[llen-2] == '\\')		/* and continuations */
--- 191,197 ----
  	    lbuf[0] == '\t' &&
  	    lbuf[1] == ':')
  	{
! 	    mch_memmove(lbuf, lbuf + 2, strlen(lbuf + 2) + 1);
  	    llen -= 2;
  	}
  	if (lbuf[llen-2] == '\\')		/* and continuations */
*** ../vim-7.1.054/src/version.c	Sun Aug  5 20:10:16 2007
--- src/version.c	Mon Aug  6 21:34:54 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     55,
  /**/

-- 
From "know your smileys":
 %	Bike accident.  A bit far-fetched, I suppose; although...
             o      _     _         _
     _o     /\_   _ \\o  (_)\__/o  (_)
   _< \_   _>(_) (_)/<_    \_| \   _|/' \/
  (_)>(_) (_)        (_)   (_)    (_)'  _\o_

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.056
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.056
Problem:    More prompt does not behave correctly after scrolling back.
	    (Randall W. Morris)
Solution:   Avoid lines_left becomes negative. (Chris Lubinski)  Don't check
	    mp_last when deciding to show the more prompt. (Martin Toft)
Files:	    src/message.c


*** ../vim-7.1.055/src/message.c	Sun Aug  5 19:20:04 2007
--- src/message.c	Tue Aug  7 21:52:10 2007
***************
*** 1878,1884 ****
  		/* output postponed text */
  		t_puts(&t_col, t_s, s, attr);
  
! 	    /* When no more prompt an no more room, truncate here */
  	    if (msg_no_more && lines_left == 0)
  		break;
  
--- 1878,1884 ----
  		/* output postponed text */
  		t_puts(&t_col, t_s, s, attr);
  
! 	    /* When no more prompt and no more room, truncate here */
  	    if (msg_no_more && lines_left == 0)
  		break;
  
***************
*** 1927,1933 ****
  	     * If screen is completely filled and 'more' is set then wait
  	     * for a character.
  	     */
! 	    --lines_left;
  	    if (p_more && lines_left == 0 && State != HITRETURN
  					    && !msg_no_more && !exmode_active)
  	    {
--- 1927,1934 ----
  	     * If screen is completely filled and 'more' is set then wait
  	     * for a character.
  	     */
! 	    if (lines_left > 0)
! 		--lines_left;
  	    if (p_more && lines_left == 0 && State != HITRETURN
  					    && !msg_no_more && !exmode_active)
  	    {
***************
*** 2234,2240 ****
  {
      msgchunk_T	*mp;
  
!     /* Only show somethign if there is more than one line, otherwise it looks
       * weird, typing a command without output results in one line. */
      mp = msg_sb_start(last_msgchunk);
      if (mp == NULL || mp->sb_prev == NULL)
--- 2235,2241 ----
  {
      msgchunk_T	*mp;
  
!     /* Only show something if there is more than one line, otherwise it looks
       * weird, typing a command without output results in one line. */
      mp = msg_sb_start(last_msgchunk);
      if (mp == NULL || mp->sb_prev == NULL)
***************
*** 2622,2628 ****
  		}
  	    }
  
! 	    if (scroll < 0 || (scroll == 0 && mp_last != NULL))
  	    {
  		/* displayed the requested text, more prompt again */
  		screen_fill((int)Rows - 1, (int)Rows, 0,
--- 2623,2629 ----
  		}
  	    }
  
! 	    if (scroll <= 0)
  	    {
  		/* displayed the requested text, more prompt again */
  		screen_fill((int)Rows - 1, (int)Rows, 0,
*** ../vim-7.1.055/src/version.c	Mon Aug  6 22:27:13 2007
--- src/version.c	Tue Aug  7 21:57:02 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     56,
  /**/

-- 
From "know your smileys":
 :-| :-|   Deja' vu!

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.057
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.057
Problem:    Problem with CursorHoldI when using "r" in Visual mode (Max
            Dyckhoff)
Solution:   Ignore CursorHold(I) when getting a second character for a Normal
            mode command.  Also abort the "r" command in Visual when a special
            key is typed.
Files:      src/normal.c


*** ../vim-7.1.056/src/normal.c	Tue Jul 10 14:02:51 2007
--- src/normal.c	Sun Aug  5 21:57:43 2007
***************
*** 889,894 ****
--- 889,899 ----
  
  	++no_mapping;
  	++allow_keys;		/* no mapping for nchar, but allow key codes */
+ #ifdef FEAT_AUTOCMD
+ 	/* Don't generate a CursorHold event here, most commands can't handle
+ 	 * it, e.g., nv_replace(), nv_csearch(). */
+ 	did_cursorhold = TRUE;
+ #endif
  	if (ca.cmdchar == 'g')
  	{
  	    /*
***************
*** 6662,6667 ****
--- 6668,6680 ----
      else
  	had_ctrl_v = NUL;
  
+     /* Abort if the character is a special key. */
+     if (IS_SPECIAL(cap->nchar))
+     {
+ 	clearopbeep(cap->oap);
+ 	return;
+     }
+ 
  #ifdef FEAT_VISUAL
      /* Visual mode "r" */
      if (VIsual_active)
***************
*** 6688,6698 ****
      }
  #endif
  
!     /*
!      * Check for a special key or not enough characters to replace.
!      */
      ptr = ml_get_cursor();
!     if (IS_SPECIAL(cap->nchar) || STRLEN(ptr) < (unsigned)cap->count1
  #ifdef FEAT_MBYTE
  	    || (has_mbyte && mb_charlen(ptr) < cap->count1)
  #endif
--- 6701,6709 ----
      }
  #endif
  
!     /* Abort if not enough characters to replace. */
      ptr = ml_get_cursor();
!     if (STRLEN(ptr) < (unsigned)cap->count1
  #ifdef FEAT_MBYTE
  	    || (has_mbyte && mb_charlen(ptr) < cap->count1)
  #endif
*** ../vim-7.1.056/src/version.c	Tue Aug  7 21:59:26 2007
--- src/version.c	Wed Aug  8 21:39:43 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     57,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
95. Only communication in your household is through email.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.058
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.058
Problem:    When 'rightleft' is set the completion menu is positioned wrong.
	    (Baha-Eddine MOKADEM)
Solution:   Fix the completion menu. (Martin Toft)
Files:	    src/popupmnu.c, src/proto/search.pro, src/search.c


*** ../vim-7.1.057/src/popupmnu.c	Thu Jun 28 21:23:52 2007
--- src/popupmnu.c	Wed Aug  1 15:43:06 2007
***************
*** 75,81 ****
  
      row = curwin->w_cline_row + W_WINROW(curwin);
      height = curwin->w_cline_height;
-     col = curwin->w_wcol + W_WINCOL(curwin) - curwin->w_leftcol;
  
      if (firstwin->w_p_pvw)
  	top_clear = firstwin->w_height;
--- 75,80 ----
***************
*** 167,172 ****
--- 166,180 ----
      pum_base_width = max_width;
      pum_kind_width = kind_width;
  
+     /* Calculate column */
+ #ifdef FEAT_RIGHTLEFT
+     if (curwin->w_p_rl)
+ 	col = W_WINCOL(curwin) + W_WIDTH(curwin) - curwin->w_wcol -
+ 							curwin->w_leftcol - 1;
+     else
+ #endif
+ 	col = W_WINCOL(curwin) + curwin->w_wcol - curwin->w_leftcol;
+ 
      /* if there are more items than room we need a scrollbar */
      if (pum_height < size)
      {
***************
*** 179,189 ****
      if (def_width < max_width)
  	def_width = max_width;
  
!     if (col < Columns - PUM_DEF_WIDTH || col < Columns - max_width)
      {
  	/* align pum column with "col" */
  	pum_col = col;
! 	pum_width = Columns - pum_col - pum_scrollbar;
  	if (pum_width > max_width + kind_width + extra_width + 1
  						 && pum_width > PUM_DEF_WIDTH)
  	{
--- 187,209 ----
      if (def_width < max_width)
  	def_width = max_width;
  
!     if (((col < Columns - PUM_DEF_WIDTH || col < Columns - max_width)
! #ifdef FEAT_RIGHTLEFT
! 		&& !curwin->w_p_rl)
! 	    || (curwin->w_p_rl && (col > PUM_DEF_WIDTH || col > max_width)
! #endif
!        ))
      {
  	/* align pum column with "col" */
  	pum_col = col;
! 
! #ifdef FEAT_RIGHTLEFT
! 	if (curwin->w_p_rl)
! 	    pum_width = pum_col - pum_scrollbar + 1;
! 	else
! #endif
! 	    pum_width = Columns - pum_col - pum_scrollbar;
! 
  	if (pum_width > max_width + kind_width + extra_width + 1
  						 && pum_width > PUM_DEF_WIDTH)
  	{
***************
*** 195,208 ****
      else if (Columns < def_width)
      {
  	/* not enough room, will use what we have */
! 	pum_col = 0;
  	pum_width = Columns - 1;
      }
      else
      {
  	if (max_width > PUM_DEF_WIDTH)
  	    max_width = PUM_DEF_WIDTH;	/* truncate */
! 	pum_col = Columns - max_width;
  	pum_width = max_width - pum_scrollbar;
      }
  
--- 215,238 ----
      else if (Columns < def_width)
      {
  	/* not enough room, will use what we have */
! #ifdef FEAT_RIGHTLEFT
! 	if (curwin->w_p_rl)
! 	    pum_col = Columns - 1;
! 	else
! #endif
! 	    pum_col = 0;
  	pum_width = Columns - 1;
      }
      else
      {
  	if (max_width > PUM_DEF_WIDTH)
  	    max_width = PUM_DEF_WIDTH;	/* truncate */
! #ifdef FEAT_RIGHTLEFT
! 	if (curwin->w_p_rl)
! 	    pum_col = max_width - 1;
! 	else
! #endif
! 	    pum_col = Columns - max_width;
  	pum_width = max_width - pum_scrollbar;
      }
  
***************
*** 255,262 ****
  	attr = (idx == pum_selected) ? attr_select : attr_norm;
  
  	/* prepend a space if there is room */
! 	if (pum_col > 0)
! 	    screen_putchar(' ', row, pum_col - 1, attr);
  
  	/* Display each entry, use two spaces for a Tab.
  	 * Do this 3 times: For the main text, kind and extra info */
--- 285,300 ----
  	attr = (idx == pum_selected) ? attr_select : attr_norm;
  
  	/* prepend a space if there is room */
! #ifdef FEAT_RIGHTLEFT
! 	if (curwin->w_p_rl)
! 	{
! 	    if (pum_col < W_WINCOL(curwin) + W_WIDTH(curwin) - 1)
! 		screen_putchar(' ', row, pum_col + 1, attr);
! 	}
! 	else
! #endif
! 	    if (pum_col > 0)
! 		screen_putchar(' ', row, pum_col - 1, attr);
  
  	/* Display each entry, use two spaces for a Tab.
  	 * Do this 3 times: For the main text, kind and extra info */
***************
*** 282,307 ****
  		    {
  			/* Display the text that fits or comes before a Tab.
  			 * First convert it to printable characters. */
! 			char_u *st;
! 			int  saved = *p;
  
  			*p = NUL;
  			st = transstr(s);
  			*p = saved;
! 			if (st != NULL)
  			{
! 			    screen_puts_len(st, (int)STRLEN(st), row, col,
  									attr);
! 			    vim_free(st);
  			}
- 			col += width;
  
  			if (*p != TAB)
  			    break;
  
  			/* Display two spaces for a Tab. */
! 			screen_puts_len((char_u *)"  ", 2, row, col, attr);
! 			col += 2;
  			totwidth += 2;
  			s = NULL;	    /* start text at next char */
  			width = 0;
--- 320,386 ----
  		    {
  			/* Display the text that fits or comes before a Tab.
  			 * First convert it to printable characters. */
! 			char_u	*st;
! 			int	saved = *p;
  
  			*p = NUL;
  			st = transstr(s);
  			*p = saved;
! #ifdef FEAT_RIGHTLEFT
! 			if (curwin->w_p_rl)
  			{
! 			    if (st != NULL)
! 			    {
! 				char_u	*rt = reverse_text(st);
! 				char_u	*rt_saved = rt;
! 				int	len, j;
! 
! 				if (rt != NULL)
! 				{
! 				    len = STRLEN(rt);
! 				    if (len > pum_width)
! 				    {
! 					for (j = pum_width; j < len; ++j)
! 					    mb_ptr_adv(rt);
! 					len = pum_width;
! 				    }
! 				    screen_puts_len(rt, len, row,
! 							col - len + 1, attr);
! 				    vim_free(rt_saved);
! 				}
! 				vim_free(st);
! 			    }
! 			    col -= width;
! 			}
! 			else
! #endif
! 			{
! 			    if (st != NULL)
! 			    {
! 				screen_puts_len(st, (int)STRLEN(st), row, col,
  									attr);
! 				vim_free(st);
! 			    }
! 			    col += width;
  			}
  
  			if (*p != TAB)
  			    break;
  
  			/* Display two spaces for a Tab. */
! #ifdef FEAT_RIGHTLEFT
! 			if (curwin->w_p_rl)
! 			{
! 			    screen_puts_len((char_u *)"  ", 2, row, col - 1,
! 									attr);
! 			    col -= 2;
! 			}
! 			else
! #endif
! 			{
! 			    screen_puts_len((char_u *)"  ", 2, row, col, attr);
! 			    col += 2;
! 			}
  			totwidth += 2;
  			s = NULL;	    /* start text at next char */
  			width = 0;
***************
*** 322,338 ****
  					  && pum_array[idx].pum_extra == NULL)
  		    || pum_base_width + n >= pum_width)
  		break;
! 	    screen_fill(row, row + 1, col, pum_col + pum_base_width + n,
  							      ' ', ' ', attr);
! 	    col = pum_col + pum_base_width + n;
  	    totwidth = pum_base_width + n;
  	}
  
! 	screen_fill(row, row + 1, col, pum_col + pum_width, ' ', ' ', attr);
  	if (pum_scrollbar > 0)
! 	    screen_putchar(' ', row, pum_col + pum_width,
! 		    i >= thumb_pos && i < thumb_pos + thumb_heigth
  						  ? attr_thumb : attr_scroll);
  
  	++row;
      }
--- 401,444 ----
  					  && pum_array[idx].pum_extra == NULL)
  		    || pum_base_width + n >= pum_width)
  		break;
! #ifdef FEAT_RIGHTLEFT
! 	    if (curwin->w_p_rl)
! 	    {
! 		screen_fill(row, row + 1, pum_col - pum_base_width - n + 1,
! 						    col + 1, ' ', ' ', attr);
! 		col = pum_col - pum_base_width - n + 1;
! 	    }
! 	    else
! #endif
! 	    {
! 		screen_fill(row, row + 1, col, pum_col + pum_base_width + n,
  							      ' ', ' ', attr);
! 		col = pum_col + pum_base_width + n;
! 	    }
  	    totwidth = pum_base_width + n;
  	}
  
! #ifdef FEAT_RIGHTLEFT
! 	if (curwin->w_p_rl)
! 	    screen_fill(row, row + 1, pum_col - pum_width + 1, col + 1, ' ',
! 								    ' ', attr);
! 	else
! #endif
! 	    screen_fill(row, row + 1, col, pum_col + pum_width, ' ', ' ',
! 									attr);
  	if (pum_scrollbar > 0)
! 	{
! #ifdef FEAT_RIGHTLEFT
! 	    if (curwin->w_p_rl)
! 		screen_putchar(' ', row, pum_col - pum_width,
! 			i >= thumb_pos && i < thumb_pos + thumb_heigth
  						  ? attr_thumb : attr_scroll);
+ 	    else
+ #endif
+ 		screen_putchar(' ', row, pum_col + pum_width,
+ 			i >= thumb_pos && i < thumb_pos + thumb_heigth
+ 						  ? attr_thumb : attr_scroll);
+ 	}
  
  	++row;
      }
*** ../vim-7.1.057/src/proto/search.pro	Sat May  5 20:20:36 2007
--- src/proto/search.pro	Wed Aug  1 12:41:25 2007
***************
*** 1,6 ****
--- 1,7 ----
  /* search.c */
  int search_regcomp __ARGS((char_u *pat, int pat_save, int pat_use, int options, regmmatch_T *regmatch));
  char_u *get_search_pat __ARGS((void));
+ char_u *reverse_text __ARGS((char_u *s));
  void save_search_patterns __ARGS((void));
  void restore_search_patterns __ARGS((void));
  void free_search_patterns __ARGS((void));
*** ../vim-7.1.057/src/search.c	Tue Jul 10 13:27:46 2007
--- src/search.c	Wed Aug  1 12:39:22 2007
***************
*** 101,107 ****
  static char_u	    *mr_pattern = NULL;	/* pattern used by search_regcomp() */
  #ifdef FEAT_RIGHTLEFT
  static int	    mr_pattern_alloced = FALSE; /* mr_pattern was allocated */
- static char_u	    *reverse_text __ARGS((char_u *s));
  #endif
  
  #ifdef FEAT_FIND_ID
--- 101,106 ----
***************
*** 228,239 ****
      return mr_pattern;
  }
  
! #ifdef FEAT_RIGHTLEFT
  /*
   * Reverse text into allocated memory.
   * Returns the allocated string, NULL when out of memory.
   */
!     static char_u *
  reverse_text(s)
      char_u *s;
  {
--- 227,238 ----
      return mr_pattern;
  }
  
! #if defined(FEAT_RIGHTLEFT) || defined(PROTO)
  /*
   * Reverse text into allocated memory.
   * Returns the allocated string, NULL when out of memory.
   */
!     char_u *
  reverse_text(s)
      char_u *s;
  {
***************
*** 1898,1904 ****
      }
  
  #ifdef FEAT_RIGHTLEFT
!     /* This is just guessing: when 'rightleft' is set, search for a maching
       * paren/brace in the other direction. */
      if (curwin->w_p_rl && vim_strchr((char_u *)"()[]{}<>", initc) != NULL)
  	backwards = !backwards;
--- 1897,1903 ----
      }
  
  #ifdef FEAT_RIGHTLEFT
!     /* This is just guessing: when 'rightleft' is set, search for a matching
       * paren/brace in the other direction. */
      if (curwin->w_p_rl && vim_strchr((char_u *)"()[]{}<>", initc) != NULL)
  	backwards = !backwards;
*** ../vim-7.1.057/src/version.c	Wed Aug  8 21:41:19 2007
--- src/version.c	Wed Aug  8 22:44:49 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     58,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
99. The hum of a cooling fan and the click of keys is comforting to you.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.059
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.059
Problem:    When in Ex mode and doing "g/^/vi" and then pressing CTRL-C Vim
	    hangs and beeps. (Antony Scriven)
Solution:   Clear "got_int" in the main loop to avoid the hang.  When typing
	    CTRL-C twice in a row abort the ":g" command.  This is Vi
	    compatible.
Files:	    src/main.c


*** ../vim-7.1.058/src/main.c	Tue Jun 19 20:30:46 2007
--- src/main.c	Tue Aug  7 22:40:35 2007
***************
*** 954,960 ****
      int		cmdwin;	    /* TRUE when working in the command-line window */
      int		noexmode;   /* TRUE when return on entering Ex mode */
  {
!     oparg_T	oa;	/* operator arguments */
  
  #if defined(FEAT_X11) && defined(FEAT_XCLIPBOARD)
      /* Setup to catch a terminating error from the X server.  Just ignore
--- 954,961 ----
      int		cmdwin;	    /* TRUE when working in the command-line window */
      int		noexmode;   /* TRUE when return on entering Ex mode */
  {
!     oparg_T	oa;				/* operator arguments */
!     int		previous_got_int = FALSE;	/* "got_int" was TRUE */
  
  #if defined(FEAT_X11) && defined(FEAT_XCLIPBOARD)
      /* Setup to catch a terminating error from the X server.  Just ignore
***************
*** 1015,1026 ****
  		need_fileinfo = FALSE;
  	    }
  	}
! 	if (got_int && !global_busy)
  	{
! 	    if (!quit_more)
! 		(void)vgetc();		/* flush all buffers */
! 	    got_int = FALSE;
  	}
  	if (!exmode_active)
  	    msg_scroll = FALSE;
  	quit_more = FALSE;
--- 1016,1047 ----
  		need_fileinfo = FALSE;
  	    }
  	}
! 
! 	/* Reset "got_int" now that we got back to the main loop.  Except when
! 	 * inside a ":g/pat/cmd" command, then the "got_int" needs to abort
! 	 * the ":g" command.
! 	 * For ":g/pat/vi" we reset "got_int" when used once.  When used
! 	 * a second time we go back to Ex mode and abort the ":g" command. */
! 	if (got_int)
  	{
! 	    if (noexmode && global_busy && !exmode_active && previous_got_int)
! 	    {
! 		/* Typed two CTRL-C in a row: go back to ex mode as if "Q" was
! 		 * used and keep "got_int" set, so that it aborts ":g". */
! 		exmode_active = EXMODE_NORMAL;
! 		State = NORMAL;
! 	    }
! 	    else if (!global_busy || !exmode_active)
! 	    {
! 		if (!quit_more)
! 		    (void)vgetc();		/* flush all buffers */
! 		got_int = FALSE;
! 	    }
! 	    previous_got_int = TRUE;
  	}
+ 	else
+ 	    previous_got_int = FALSE;
+ 
  	if (!exmode_active)
  	    msg_scroll = FALSE;
  	quit_more = FALSE;
*** ../vim-7.1.058/src/version.c	Wed Aug  8 22:48:16 2007
--- src/version.c	Fri Aug 10 21:30:39 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     59,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
116. You are living with your boyfriend who networks your respective
     computers so you can sit in separate rooms and email each other

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.060
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.060
Problem:    Splitting quickfix window messes up window layout. (Marius
	    Gedminas)
Solution:   Compute the window size in a smarter way. (Martin Toft)
Files:	    src/window.c


*** ../vim-7.1.059/src/window.c	Sun Aug  5 18:49:07 2007
--- src/window.c	Sun Aug  5 17:17:51 2007
***************
*** 2121,2127 ****
  	if (wp->w_p_pvw || bt_quickfix(wp->w_buffer))
  	{
  	    /*
! 	     * The cursor goes to the preview or the quickfix window, try
  	     * finding another window to go to.
  	     */
  	    for (;;)
--- 2121,2127 ----
  	if (wp->w_p_pvw || bt_quickfix(wp->w_buffer))
  	{
  	    /*
! 	     * If the cursor goes to the preview or the quickfix window, try
  	     * finding another window to go to.
  	     */
  	    for (;;)
***************
*** 2308,2314 ****
      frame_T	*frp, *frp2, *frp3;
      frame_T	*frp_close = win->w_frame;
      win_T	*wp;
-     int		old_size = 0;
  
      /*
       * If there is only one window there is nothing to remove.
--- 2308,2313 ----
***************
*** 2329,2361 ****
      if (frp_close->fr_parent->fr_layout == FR_COL)
      {
  #endif
! 	/* When 'winfixheight' is set, remember its old size and restore
! 	 * it later (it's a simplistic solution...).  Don't do this if the
! 	 * window will occupy the full height of the screen. */
! 	if (frp2->fr_win != NULL
! 		&& (frp2->fr_next != NULL || frp2->fr_prev != NULL)
! 		&& frp2->fr_win->w_p_wfh)
! 	    old_size = frp2->fr_win->w_height;
  	frame_new_height(frp2, frp2->fr_height + frp_close->fr_height,
  			    frp2 == frp_close->fr_next ? TRUE : FALSE, FALSE);
- 	if (old_size != 0)
- 	    win_setheight_win(old_size, frp2->fr_win);
  #ifdef FEAT_VERTSPLIT
  	*dirp = 'v';
      }
      else
      {
! 	/* When 'winfixwidth' is set, remember its old size and restore
! 	 * it later (it's a simplistic solution...).  Don't do this if the
! 	 * window will occupy the full width of the screen. */
! 	if (frp2->fr_win != NULL
! 		&& (frp2->fr_next != NULL || frp2->fr_prev != NULL)
! 		&& frp2->fr_win->w_p_wfw)
! 	    old_size = frp2->fr_win->w_width;
  	frame_new_width(frp2, frp2->fr_width + frp_close->fr_width,
  			    frp2 == frp_close->fr_next ? TRUE : FALSE, FALSE);
- 	if (old_size != 0)
- 	    win_setwidth_win(old_size, frp2->fr_win);
  	*dirp = 'h';
      }
  #endif
--- 2328,2404 ----
      if (frp_close->fr_parent->fr_layout == FR_COL)
      {
  #endif
! 	/* When 'winfixheight' is set, try to find another frame in the column
! 	 * (as close to the closed frame as possible) to distribute the height
! 	 * to. */
! 	if (frp2->fr_win != NULL && frp2->fr_win->w_p_wfh)
! 	{
! 	    frp = frp_close->fr_prev;
! 	    frp3 = frp_close->fr_next;
! 	    while (frp != NULL || frp3 != NULL)
! 	    {
! 		if (frp != NULL)
! 		{
! 		    if (frp->fr_win != NULL && !frp->fr_win->w_p_wfh)
! 		    {
! 			frp2 = frp;
! 			wp = frp->fr_win;
! 			break;
! 		    }
! 		    frp = frp->fr_prev;
! 		}
! 		if (frp3 != NULL)
! 		{
! 		    if (frp3->fr_win != NULL && !frp3->fr_win->w_p_wfh)
! 		    {
! 			frp2 = frp3;
! 			wp = frp3->fr_win;
! 			break;
! 		    }
! 		    frp3 = frp3->fr_next;
! 		}
! 	    }
! 	}
  	frame_new_height(frp2, frp2->fr_height + frp_close->fr_height,
  			    frp2 == frp_close->fr_next ? TRUE : FALSE, FALSE);
  #ifdef FEAT_VERTSPLIT
  	*dirp = 'v';
      }
      else
      {
! 	/* When 'winfixwidth' is set, try to find another frame in the column
! 	 * (as close to the closed frame as possible) to distribute the width
! 	 * to. */
! 	if (frp2->fr_win != NULL && frp2->fr_win->w_p_wfw)
! 	{
! 	    frp = frp_close->fr_prev;
! 	    frp3 = frp_close->fr_next;
! 	    while (frp != NULL || frp3 != NULL)
! 	    {
! 		if (frp != NULL)
! 		{
! 		    if (frp->fr_win != NULL && !frp->fr_win->w_p_wfw)
! 		    {
! 			frp2 = frp;
! 			wp = frp->fr_win;
! 			break;
! 		    }
! 		    frp = frp->fr_prev;
! 		}
! 		if (frp3 != NULL)
! 		{
! 		    if (frp3->fr_win != NULL && !frp3->fr_win->w_p_wfw)
! 		    {
! 			frp2 = frp3;
! 			wp = frp3->fr_win;
! 			break;
! 		    }
! 		    frp3 = frp3->fr_next;
! 		}
! 	    }
! 	}
  	frame_new_width(frp2, frp2->fr_width + frp_close->fr_width,
  			    frp2 == frp_close->fr_next ? TRUE : FALSE, FALSE);
  	*dirp = 'h';
      }
  #endif
*** ../vim-7.1.059/src/version.c	Fri Aug 10 21:32:41 2007
--- src/version.c	Sat Aug 11 13:34:42 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     60,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
117. You are more comfortable typing in html.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.061
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.061
Problem:    Win32: When 'encoding' is "latin1" 'ignorecase' doesn't work for
	    characters with umlaut. (Joachim Hofmann)
Solution:   Do not use islower()/isupper()/tolower()/toupper() but our own
	    functions. (Chris Lubinski)
Files:	    src/mbyte.c, src/regexp.c, src/vim.h


*** ../vim-7.1.060/src/mbyte.c	Thu May 10 19:45:20 2007
--- src/mbyte.c	Sat Aug  4 13:44:36 2007
***************
*** 2320,2326 ****
  		/* Single byte: first check normally, then with ignore case. */
  		if (s1[i] != s2[i])
  		{
! 		    cdiff = TOLOWER_LOC(s1[i]) - TOLOWER_LOC(s2[i]);
  		    if (cdiff != 0)
  			return cdiff;
  		}
--- 2320,2326 ----
  		/* Single byte: first check normally, then with ignore case. */
  		if (s1[i] != s2[i])
  		{
! 		    cdiff = MB_TOLOWER(s1[i]) - MB_TOLOWER(s2[i]);
  		    if (cdiff != 0)
  			return cdiff;
  		}
*** ../vim-7.1.060/src/regexp.c	Mon Aug  6 22:27:13 2007
--- src/regexp.c	Sun Aug  5 15:43:27 2007
***************
*** 2220,2226 ****
  				break;
  			    case CLASS_LOWER:
  				for (cu = 1; cu <= 255; cu++)
! 				    if (islower(cu))
  					regc(cu);
  				break;
  			    case CLASS_PRINT:
--- 2220,2226 ----
  				break;
  			    case CLASS_LOWER:
  				for (cu = 1; cu <= 255; cu++)
! 				    if (MB_ISLOWER(cu))
  					regc(cu);
  				break;
  			    case CLASS_PRINT:
***************
*** 2240,2246 ****
  				break;
  			    case CLASS_UPPER:
  				for (cu = 1; cu <= 255; cu++)
! 				    if (isupper(cu))
  					regc(cu);
  				break;
  			    case CLASS_XDIGIT:
--- 2240,2246 ----
  				break;
  			    case CLASS_UPPER:
  				for (cu = 1; cu <= 255; cu++)
! 				    if (MB_ISUPPER(cu))
  					regc(cu);
  				break;
  			    case CLASS_XDIGIT:
***************
*** 3465,3471 ****
  			(enc_utf8 && utf_fold(prog->regstart) == utf_fold(c)))
  			|| (c < 255 && prog->regstart < 255 &&
  #endif
! 			    TOLOWER_LOC(prog->regstart) == TOLOWER_LOC(c)))))
  	    retval = regtry(prog, col);
  	else
  	    retval = 0;
--- 3465,3471 ----
  			(enc_utf8 && utf_fold(prog->regstart) == utf_fold(c)))
  			|| (c < 255 && prog->regstart < 255 &&
  #endif
! 			    MB_TOLOWER(prog->regstart) == MB_TOLOWER(c)))))
  	    retval = regtry(prog, col);
  	else
  	    retval = 0;
***************
*** 4200,4206 ****
  #ifdef FEAT_MBYTE
  			    !enc_utf8 &&
  #endif
! 			    TOLOWER_LOC(*opnd) != TOLOWER_LOC(*reginput))))
  		    status = RA_NOMATCH;
  		else if (*opnd == NUL)
  		{
--- 4200,4206 ----
  #ifdef FEAT_MBYTE
  			    !enc_utf8 &&
  #endif
! 			    MB_TOLOWER(*opnd) != MB_TOLOWER(*reginput))))
  		    status = RA_NOMATCH;
  		else if (*opnd == NUL)
  		{
***************
*** 4733,4742 ****
  		    rst.nextb = *OPERAND(next);
  		    if (ireg_ic)
  		    {
! 			if (isupper(rst.nextb))
! 			    rst.nextb_ic = TOLOWER_LOC(rst.nextb);
  			else
! 			    rst.nextb_ic = TOUPPER_LOC(rst.nextb);
  		    }
  		    else
  			rst.nextb_ic = rst.nextb;
--- 4733,4742 ----
  		    rst.nextb = *OPERAND(next);
  		    if (ireg_ic)
  		    {
! 			if (MB_ISUPPER(rst.nextb))
! 			    rst.nextb_ic = MB_TOLOWER(rst.nextb);
  			else
! 			    rst.nextb_ic = MB_TOUPPER(rst.nextb);
  		    }
  		    else
  			rst.nextb_ic = rst.nextb;
***************
*** 5558,5568 ****
  	    int	    cu, cl;
  
  	    /* This doesn't do a multi-byte character, because a MULTIBYTECODE
! 	     * would have been used for it. */
  	    if (ireg_ic)
  	    {
! 		cu = TOUPPER_LOC(*opnd);
! 		cl = TOLOWER_LOC(*opnd);
  		while (count < maxcount && (*scan == cu || *scan == cl))
  		{
  		    count++;
--- 5558,5569 ----
  	    int	    cu, cl;
  
  	    /* This doesn't do a multi-byte character, because a MULTIBYTECODE
! 	     * would have been used for it.  It does handle single-byte
! 	     * characters, such as latin1. */
  	    if (ireg_ic)
  	    {
! 		cu = MB_TOUPPER(*opnd);
! 		cl = MB_TOLOWER(*opnd);
  		while (count < maxcount && (*scan == cu || *scan == cl))
  		{
  		    count++;
***************
*** 6490,6499 ****
  	cc = utf_fold(c);
      else
  #endif
! 	 if (isupper(c))
! 	cc = TOLOWER_LOC(c);
!     else if (islower(c))
! 	cc = TOUPPER_LOC(c);
      else
  	return vim_strchr(s, c);
  
--- 6491,6500 ----
  	cc = utf_fold(c);
      else
  #endif
! 	 if (MB_ISUPPER(c))
! 	cc = MB_TOLOWER(c);
!     else if (MB_ISLOWER(c))
! 	cc = MB_TOUPPER(c);
      else
  	return vim_strchr(s, c);
  
*** ../vim-7.1.060/src/vim.h	Sat May 12 15:08:22 2007
--- src/vim.h	Sat Aug  4 13:57:36 2007
***************
*** 1380,1387 ****
  #endif
  
  #ifdef FEAT_MBYTE
! # define MB_STRICMP(d, s)	(has_mbyte ? mb_strnicmp((char_u *)(d), (char_u *)(s), (int)MAXCOL) : STRICMP((d), (s)))
! # define MB_STRNICMP(d, s, n)	(has_mbyte ? mb_strnicmp((char_u *)(d), (char_u *)(s), (int)(n)) : STRNICMP((d), (s), (n)))
  #else
  # define MB_STRICMP(d, s)	STRICMP((d), (s))
  # define MB_STRNICMP(d, s, n)	STRNICMP((d), (s), (n))
--- 1380,1393 ----
  #endif
  
  #ifdef FEAT_MBYTE
! /* We need to call mb_stricmp() even when we aren't dealing with a multi-byte
!  * encoding because mb_stricmp() takes care of all ascii and non-ascii
!  * encodings, including characters with umluats in latin1, etc., while
!  * STRICMP() only handles the system locale version, which often does not
!  * handle non-ascii properly. */
! 
! # define MB_STRICMP(d, s)	mb_strnicmp((char_u *)(d), (char_u *)(s), (int)MAXCOL)
! # define MB_STRNICMP(d, s, n)	mb_strnicmp((char_u *)(d), (char_u *)(s), (int)(n))
  #else
  # define MB_STRICMP(d, s)	STRICMP((d), (s))
  # define MB_STRNICMP(d, s, n)	STRNICMP((d), (s), (n))
*** ../vim-7.1.060/src/version.c	Sat Aug 11 13:37:36 2007
--- src/version.c	Sat Aug 11 13:55:24 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     61,
  /**/

-- 
Support your right to bare arms!  Wear short sleeves!

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.062
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.062 (after 7.1.038)
Problem:    Indents of C comments can be wrong. (John Mullin)
Solution:   Adjust ind_len. (Chris Lubinski)
Files:	    src/misc1.c


*** ../vim-7.1.061/src/misc1.c	Mon Aug  6 22:27:13 2007
--- src/misc1.c	Fri Aug 10 19:41:42 2007
***************
*** 222,228 ****
  	 * than old) */
  	while (vim_iswhite(*p))
  	    (void)*p++;
! 	todo = size-ind_done;
      }
      else
      {
--- 222,231 ----
  	 * than old) */
  	while (vim_iswhite(*p))
  	    (void)*p++;
! 	todo = size - ind_done;
! 	ind_len += todo;    /* Set total length of indent in characters,
! 			     * which may have been undercounted until now  */
! 
      }
      else
      {
*** ../vim-7.1.061/src/version.c	Sat Aug 11 13:57:31 2007
--- src/version.c	Sat Aug 11 14:30:52 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     62,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
120. You ask a friend, "What's that big shiny thing?" He says, "It's the sun."

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.063
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.063 (after 7.1.040)
Problem:    Warning for unitialized variable.
Solution:   Initialise it to NULL.
Files:	    src/ex_docmd.c


*** ../vim-7.1.062/src/ex_docmd.c	Thu Jul 26 22:55:11 2007
--- src/ex_docmd.c	Wed Aug  8 22:28:33 2007
***************
*** 10817,10823 ****
      exarg_T	*eap;
  {
      char_u	*p;
!     char_u	*g;
      char_u	*end;
      int		c;
      int		id;
--- 10818,10824 ----
      exarg_T	*eap;
  {
      char_u	*p;
!     char_u	*g = NULL;
      char_u	*end;
      int		c;
      int		id;
*** ../vim-7.1.062/src/version.c	Sat Aug 11 14:32:10 2007
--- src/version.c	Sat Aug 11 15:58:55 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     63,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
124. You begin conversations with, "Who is your internet service provider?"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.064
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.064
Problem:    On Interix some files appear not to exist.
Solution:   Remove the top bit from st_mode. (Ligesh)
Files:	    src/os_unix.c


*** ../vim-7.1.063/src/os_unix.c	Thu May 10 19:42:47 2007
--- src/os_unix.c	Fri Aug 10 19:32:20 2007
***************
*** 2499,2505 ****
--- 2499,2511 ----
      if (stat((char *)name, &statb))
  #endif
  	return -1;
+ #ifdef __INTERIX
+     /* The top bit makes the value negative, which means the file doesn't
+      * exist.  Remove the bit, we don't use it. */
+     return statb.st_mode & ~S_ADDACE;
+ #else
      return statb.st_mode;
+ #endif
  }
  
  /*
*** ../vim-7.1.063/src/version.c	Sat Aug 11 15:59:44 2007
--- src/version.c	Sat Aug 11 22:21:35 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     64,
  /**/

-- 
I have a watch cat! Just break in and she'll watch.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.065 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.065 (extra)
Problem:    Win32: Compilation problem for newer version of w32api.
Solution:   Only define __IID_DEFINED__ when needed. (Chris Sutcliffe)
Files:	    src/Make_ming.mak, src/iid_ole.c


*** ../vim-7.1.064/src/Make_ming.mak	Thu May 10 19:35:54 2007
--- src/Make_ming.mak	Sat Aug 11 14:52:11 2007
***************
*** 572,579 ****
  $(OUTDIR)/if_cscope.o:	if_cscope.c $(INCL) if_cscope.h
  	$(CC) -c $(CFLAGS) if_cscope.c -o $(OUTDIR)/if_cscope.o
  
  $(OUTDIR)/if_ole.o: if_ole.cpp $(INCL)
! 	$(CC) $(CFLAGS) -D__IID_DEFINED__ -c -o $(OUTDIR)/if_ole.o if_ole.cpp
  
  $(OUTDIR)/if_ruby.o: if_ruby.c $(INCL)
  ifeq (16, $(RUBY))
--- 572,580 ----
  $(OUTDIR)/if_cscope.o:	if_cscope.c $(INCL) if_cscope.h
  	$(CC) -c $(CFLAGS) if_cscope.c -o $(OUTDIR)/if_cscope.o
  
+ # Remove -D__IID_DEFINED__ for newer versions of the w32api
  $(OUTDIR)/if_ole.o: if_ole.cpp $(INCL)
! 	$(CC) $(CFLAGS) -c -o $(OUTDIR)/if_ole.o if_ole.cpp
  
  $(OUTDIR)/if_ruby.o: if_ruby.c $(INCL)
  ifeq (16, $(RUBY))
*** ../vim-7.1.064/src/iid_ole.c	Sun Jun 13 18:45:30 2004
--- src/iid_ole.c	Sat Aug 11 14:57:58 2007
***************
*** 16,24 ****
  extern "C"{
  #endif
  
  
  #ifndef __IID_DEFINED__
! #define __IID_DEFINED__
  
  typedef struct _IID
  {
--- 16,33 ----
  extern "C"{
  #endif
  
+ #ifdef __MINGW32__
+ # include <w32api.h>
+ 
+ # if __W32API_MAJOR_VERSION == 3 && __W32API_MINOR_VERSION < 10
+    /* This define is missing from older MingW versions of w32api, even though
+     * IID is defined. */
+ #  define __IID_DEFINED__
+ # endif
+ #endif
  
  #ifndef __IID_DEFINED__
! # define __IID_DEFINED__
  
  typedef struct _IID
  {
***************
*** 28,39 ****
      unsigned char  c[8];
  } IID;
  
! #endif // __IID_DEFINED__
  
  #ifndef CLSID_DEFINED
! #define CLSID_DEFINED
  typedef IID CLSID;
! #endif // CLSID_DEFINED
  
  const IID IID_IVim = {0x0F0BFAE2,0x4C90,0x11d1,{0x82,0xD7,0x00,0x04,0xAC,0x36,0x85,0x19}};
  
--- 37,48 ----
      unsigned char  c[8];
  } IID;
  
! #endif
  
  #ifndef CLSID_DEFINED
! # define CLSID_DEFINED
  typedef IID CLSID;
! #endif
  
  const IID IID_IVim = {0x0F0BFAE2,0x4C90,0x11d1,{0x82,0xD7,0x00,0x04,0xAC,0x36,0x85,0x19}};
  
*** ../vim-7.1.064/src/version.c	Sat Aug 11 22:22:56 2007
--- src/version.c	Sun Aug 12 15:21:34 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     65,
  /**/

-- 
I'm writing a book.  I've got the page numbers done.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.066
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.066
Problem:    When 'bomb' is set or reset the file should be considered
	    modified.  (Tony Mechelynck)
Solution:   Handle like 'endofline'. (Martin Toft)
Files:	    src/buffer.c, src/fileio.c, src/option.c, src/structs.h


*** ../vim-7.1.065/src/buffer.c	Mon Aug  6 22:27:12 2007
--- src/buffer.c	Sat Aug 11 16:56:57 2007
***************
*** 502,507 ****
--- 502,508 ----
      buf->b_start_eol = TRUE;
  #ifdef FEAT_MBYTE
      buf->b_p_bomb = FALSE;
+     buf->b_start_bomb = FALSE;
  #endif
      buf->b_ml.ml_mfp = NULL;
      buf->b_ml.ml_flags = ML_EMPTY;		/* empty buffer */
*** ../vim-7.1.065/src/fileio.c	Tue Jul 10 17:09:51 2007
--- src/fileio.c	Sat Aug 11 16:56:57 2007
***************
*** 654,659 ****
--- 654,660 ----
  	curbuf->b_start_eol = TRUE;
  #ifdef FEAT_MBYTE
  	curbuf->b_p_bomb = FALSE;
+ 	curbuf->b_start_bomb = FALSE;
  #endif
      }
  
***************
*** 912,918 ****
--- 913,922 ----
  	file_rewind = FALSE;
  #ifdef FEAT_MBYTE
  	if (set_options)
+ 	{
  	    curbuf->b_p_bomb = FALSE;
+ 	    curbuf->b_start_bomb = FALSE;
+ 	}
  	conv_error = 0;
  #endif
      }
***************
*** 1361,1367 ****
--- 1365,1374 ----
  		    size -= blen;
  		    mch_memmove(ptr, ptr + blen, (size_t)size);
  		    if (set_options)
+ 		    {
  			curbuf->b_p_bomb = TRUE;
+ 			curbuf->b_start_bomb = TRUE;
+ 		    }
  		}
  
  		if (fio_flags == FIO_UCSBOM)
*** ../vim-7.1.065/src/option.c	Tue Jul 24 14:57:16 2007
--- src/option.c	Sat Aug 11 16:56:57 2007
***************
*** 7118,7123 ****
--- 7118,7128 ----
      /* when 'endofline' is changed, redraw the window title */
      else if ((int *)varp == &curbuf->b_p_eol)
  	need_maketitle = TRUE;
+ #ifdef FEAT_MBYTE
+     /* when 'bomb' is changed, redraw the window title */
+     else if ((int *)varp == &curbuf->b_p_bomb)
+ 	need_maketitle = TRUE;
+ #endif
  #endif
  
      /* when 'bin' is set also set some other options */
***************
*** 10604,10609 ****
--- 10609,10616 ----
      buf->b_start_ffc = *buf->b_p_ff;
      buf->b_start_eol = buf->b_p_eol;
  #ifdef FEAT_MBYTE
+     buf->b_start_bomb = buf->b_p_bomb;
+ 
      /* Only use free/alloc when necessary, they take time. */
      if (buf->b_start_fenc == NULL
  			     || STRCMP(buf->b_start_fenc, buf->b_p_fenc) != 0)
***************
*** 10617,10623 ****
  /*
   * Return TRUE if 'fileformat' and/or 'fileencoding' has a different value
   * from when editing started (save_file_ff() called).
!  * Also when 'endofline' was changed and 'binary' is set.
   * Don't consider a new, empty buffer to be changed.
   */
      int
--- 10624,10631 ----
  /*
   * Return TRUE if 'fileformat' and/or 'fileencoding' has a different value
   * from when editing started (save_file_ff() called).
!  * Also when 'endofline' was changed and 'binary' is set, or when 'bomb' was
!  * changed and 'binary' is not set.
   * Don't consider a new, empty buffer to be changed.
   */
      int
***************
*** 10636,10641 ****
--- 10644,10651 ----
      if (buf->b_p_bin && buf->b_start_eol != buf->b_p_eol)
  	return TRUE;
  #ifdef FEAT_MBYTE
+     if (!buf->b_p_bin && buf->b_start_bomb != buf->b_p_bomb)
+ 	return TRUE;
      if (buf->b_start_fenc == NULL)
  	return (*buf->b_p_fenc != NUL);
      return (STRCMP(buf->b_start_fenc, buf->b_p_fenc) != 0);
*** ../vim-7.1.065/src/structs.h	Thu Jul 26 22:55:11 2007
--- src/structs.h	Sat Aug 11 16:56:57 2007
***************
*** 1453,1458 ****
--- 1453,1459 ----
  #ifdef FEAT_MBYTE
      char_u	*b_start_fenc;	/* 'fileencoding' when edit started or NULL */
      int		b_bad_char;	/* "++bad=" argument when edit started or 0 */
+     int		b_start_bomb;	/* 'bomb' when it was read */
  #endif
  
  #ifdef FEAT_EVAL
*** ../vim-7.1.065/src/version.c	Sun Aug 12 15:24:05 2007
--- src/version.c	Sun Aug 12 15:48:34 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     66,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
127. You bring your laptop and cellular phone to church.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.067
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.067
Problem:    'thesaurus' doesn't work when 'infercase' is set. (Mohsin)
Solution:   Don't copy the characters being completed but check the case and
	    apply it to the suggested word.  Also fix that the first word in
	    the thesaurus line is not used.  (Martin Toft)
Files:	    src/edit.c


*** ../vim-7.1.066/src/edit.c	Sun Jul 29 15:02:34 2007
--- src/edit.c	Sat Aug 11 17:16:51 2007
***************
*** 2057,2063 ****
   * case of the originally typed text is used, and the case of the completed
   * text is inferred, ie this tries to work out what case you probably wanted
   * the rest of the word to be in -- webb
-  * TODO: make this work for multi-byte characters.
   */
      int
  ins_compl_add_infercase(str, len, icase, fname, dir, flags)
--- 2057,2062 ----
***************
*** 2068,2121 ****
      int		dir;
      int		flags;
  {
      int		has_lower = FALSE;
      int		was_letter = FALSE;
-     int		idx;
  
!     if (p_ic && curbuf->b_p_inf && len < IOSIZE)
      {
! 	/* Infer case of completed part -- webb */
! 	/* Use IObuff, str would change text in buffer! */
! 	vim_strncpy(IObuff, str, len);
  
! 	/* Rule 1: Were any chars converted to lower? */
! 	for (idx = 0; idx < compl_length; ++idx)
  	{
! 	    if (islower(compl_orig_text[idx]))
  	    {
! 		has_lower = TRUE;
! 		if (isupper(IObuff[idx]))
! 		{
! 		    /* Rule 1 is satisfied */
! 		    for (idx = compl_length; idx < len; ++idx)
! 			IObuff[idx] = TOLOWER_LOC(IObuff[idx]);
! 		    break;
! 		}
  	    }
  	}
  
! 	/*
! 	 * Rule 2: No lower case, 2nd consecutive letter converted to
! 	 * upper case.
! 	 */
! 	if (!has_lower)
  	{
! 	    for (idx = 0; idx < compl_length; ++idx)
  	    {
! 		if (was_letter && isupper(compl_orig_text[idx])
! 						      && islower(IObuff[idx]))
  		{
! 		    /* Rule 2 is satisfied */
! 		    for (idx = compl_length; idx < len; ++idx)
! 			IObuff[idx] = TOUPPER_LOC(IObuff[idx]);
! 		    break;
  		}
- 		was_letter = isalpha(compl_orig_text[idx]);
  	    }
- 	}
  
! 	/* Copy the original case of the part we typed */
! 	STRNCPY(IObuff, compl_orig_text, compl_length);
  
  	return ins_compl_add(IObuff, len, icase, fname, NULL, dir,
  								flags, FALSE);
--- 2067,2213 ----
      int		dir;
      int		flags;
  {
+     char_u	*p;
+     int		i, c;
+     int		actual_len;		/* Take multi-byte characters */
+     int		actual_compl_length;	/* into account. */
+     int		*wca;		        /* Wide character array. */
      int		has_lower = FALSE;
      int		was_letter = FALSE;
  
!     if (p_ic && curbuf->b_p_inf)
      {
! 	/* Infer case of completed part. */
  
! 	/* Find actual length of completion. */
! #ifdef FEAT_MBYTE
! 	if (has_mbyte)
  	{
! 	    p = str;
! 	    actual_len = 0;
! 	    while (*p != NUL)
  	    {
! 		mb_ptr_adv(p);
! 		++actual_len;
  	    }
  	}
+ 	else
+ #endif
+ 	    actual_len = len;
  
! 	/* Find actual length of original text. */
! #ifdef FEAT_MBYTE
! 	if (has_mbyte)
  	{
! 	    p = compl_orig_text;
! 	    actual_compl_length = 0;
! 	    while (*p != NUL)
  	    {
! 		mb_ptr_adv(p);
! 		++actual_compl_length;
! 	    }
! 	}
! 	else
! #endif
! 	    actual_compl_length = compl_length;
! 
! 	/* Allocate wide character array for the completion and fill it. */
! 	wca = (int *)alloc(actual_len * sizeof(int));
! 	if (wca != NULL)
! 	{
! 	    p = str;
! 	    for (i = 0; i < actual_len; ++i)
! #ifdef FEAT_MBYTE
! 		if (has_mbyte)
! 		    wca[i] = mb_ptr2char_adv(&p);
! 		else
! #endif
! 		    wca[i] = *(p++);
! 
! 	    /* Rule 1: Were any chars converted to lower? */
! 	    p = compl_orig_text;
! 	    for (i = 0; i < actual_compl_length; ++i)
! 	    {
! #ifdef FEAT_MBYTE
! 		if (has_mbyte)
! 		    c = mb_ptr2char_adv(&p);
! 		else
! #endif
! 		    c = *(p++);
! 		if (MB_ISLOWER(c))
  		{
! 		    has_lower = TRUE;
! 		    if (MB_ISUPPER(wca[i]))
! 		    {
! 			/* Rule 1 is satisfied. */
! 			for (i = actual_compl_length; i < actual_len; ++i)
! 			    wca[i] = MB_TOLOWER(wca[i]);
! 			break;
! 		    }
  		}
  	    }
  
! 	    /*
! 	     * Rule 2: No lower case, 2nd consecutive letter converted to
! 	     * upper case.
! 	     */
! 	    if (!has_lower)
! 	    {
! 		p = compl_orig_text;
! 		for (i = 0; i < actual_compl_length; ++i)
! 		{
! #ifdef FEAT_MBYTE
! 		    if (has_mbyte)
! 			c = mb_ptr2char_adv(&p);
! 		    else
! #endif
! 			c = *(p++);
! 		    if (was_letter && MB_ISUPPER(c) && MB_ISLOWER(wca[i]))
! 		    {
! 			/* Rule 2 is satisfied. */
! 			for (i = actual_compl_length; i < actual_len; ++i)
! 			    wca[i] = MB_TOUPPER(wca[i]);
! 			break;
! 		    }
! 		    was_letter = MB_ISLOWER(c) || MB_ISUPPER(c);
! 		}
! 	    }
! 
! 	    /* Copy the original case of the part we typed. */
! 	    p = compl_orig_text;
! 	    for (i = 0; i < actual_compl_length; ++i)
! 	    {
! #ifdef FEAT_MBYTE
! 		if (has_mbyte)
! 		    c = mb_ptr2char_adv(&p);
! 		else
! #endif
! 		    c = *(p++);
! 		if (MB_ISLOWER(c))
! 		    wca[i] = MB_TOLOWER(wca[i]);
! 		else if (MB_ISUPPER(c))
! 		    wca[i] = MB_TOUPPER(wca[i]);
! 	    }
! 
! 	    /* 
! 	     * Generate encoding specific output from wide character array.
! 	     * Multi-byte characters can occupy up to five bytes more than
! 	     * ASCII characters, and we also need one byte for NUL, so stay
! 	     * six bytes away from the edge of IObuff.
! 	     */
! 	    p = IObuff;
! 	    i = 0;
! 	    while (i < actual_len && (p - IObuff + 6) < IOSIZE)
! #ifdef FEAT_MBYTE
! 		if (has_mbyte)
! 		    p += mb_char2bytes(wca[i++], p);
! 		else
! #endif
! 		    *(p++) = wca[i++];
! 	    *p = NUL;
! 
! 	    vim_free(wca);
! 	}
  
  	return ins_compl_add(IObuff, len, icase, fname, NULL, dir,
  								flags, FALSE);
***************
*** 2842,2847 ****
--- 2934,2940 ----
  			/*
  			 * Add the other matches on the line
  			 */
+ 			ptr = buf;
  			while (!got_int)
  			{
  			    /* Find start of the next word.  Skip white
***************
*** 2851,2857 ****
  				break;
  			    wstart = ptr;
  
! 			    /* Find end of the word and add it. */
  #ifdef FEAT_MBYTE
  			    if (has_mbyte)
  				/* Japanese words may have characters in
--- 2944,2950 ----
  				break;
  			    wstart = ptr;
  
! 			    /* Find end of the word. */
  #ifdef FEAT_MBYTE
  			    if (has_mbyte)
  				/* Japanese words may have characters in
***************
*** 2868,2876 ****
  			    else
  #endif
  				ptr = find_word_end(ptr);
! 			    add_r = ins_compl_add_infercase(wstart,
! 				    (int)(ptr - wstart),
! 				    p_ic, files[i], *dir, 0);
  			}
  		    }
  		    if (add_r == OK)
--- 2961,2972 ----
  			    else
  #endif
  				ptr = find_word_end(ptr);
! 
! 			    /* Add the word. Skip the regexp match. */
! 			    if (wstart != regmatch->startp[0])
! 				add_r = ins_compl_add_infercase(wstart,
! 					(int)(ptr - wstart),
! 					p_ic, files[i], *dir, 0);
  			}
  		    }
  		    if (add_r == OK)
*** ../vim-7.1.066/src/version.c	Sun Aug 12 15:50:26 2007
--- src/version.c	Sun Aug 12 16:36:34 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     67,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
128. You can access the Net -- via your portable and cellular phone.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.068
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.068
Problem:    When 'equalalways' is set and splitting a window, it's possible
	    that another small window gets bigger.
Solution:   Only equalize window sizes when after a split the windows are
	    smaller than another window. (Martin Toft)
Files:	    runtime/doc/options.txt, runtime/doc/windows.txt, src/window.c


*** ../vim-7.1.067/runtime/doc/options.txt	Sat May 12 16:27:04 2007
--- runtime/doc/options.txt	Sat Aug 11 17:25:38 2007
***************
*** 1,4 ****
! *options.txt*	For Vim version 7.1.  Last change: 2007 May 11
  
  
  		  VIM REFERENCE MANUAL	  by Bram Moolenaar
--- 1,4 ----
! *options.txt*	For Vim version 7.1.  Last change: 2007 Aug 10
  
  
  		  VIM REFERENCE MANUAL	  by Bram Moolenaar
***************
*** 2415,2422 ****
  	When mixing vertically and horizontally split windows, a minimal size
  	is computed and some windows may be larger if there is room.  The
  	'eadirection' option tells in which direction the size is affected.
! 	Changing the height of a window can be avoided by setting
! 	'winfixheight'.
  
  						*'equalprg'* *'ep'*
  'equalprg' 'ep'		string	(default "")
--- 2418,2425 ----
  	When mixing vertically and horizontally split windows, a minimal size
  	is computed and some windows may be larger if there is room.  The
  	'eadirection' option tells in which direction the size is affected.
! 	Changing the height and width of a window can be avoided by setting
! 	'winfixheight' and 'winfixwidth', respectively.
  
  						*'equalprg'* *'ep'*
  'equalprg' 'ep'		string	(default "")
*** ../vim-7.1.067/runtime/doc/windows.txt	Sat May 12 16:42:48 2007
--- runtime/doc/windows.txt	Sat Aug 11 17:25:38 2007
***************
*** 132,138 ****
  		the same file.  Make new window N high (default is to use half
  		the height of the current window).  Reduces the current window
  		height to create room (and others, if the 'equalalways' option
! 		is set and 'eadirection' isn't "hor").
  		Note: CTRL-S does not work on all terminals and might block
  		further input, use CTRL-Q to get going again.
  		Also see |++opt| and |+cmd|.
--- 132,139 ----
  		the same file.  Make new window N high (default is to use half
  		the height of the current window).  Reduces the current window
  		height to create room (and others, if the 'equalalways' option
! 		is set, 'eadirection' isn't "hor", and one of them is higher
! 		than the current or the new window).
  		Note: CTRL-S does not work on all terminals and might block
  		further input, use CTRL-Q to get going again.
  		Also see |++opt| and |+cmd|.
***************
*** 140,148 ****
  CTRL-W CTRL-V						*CTRL-W_CTRL-V*
  CTRL-W v						*CTRL-W_v*
  :[N]vs[plit] [++opt] [+cmd] [file]			*:vs* *:vsplit*
! 		Like |:split|, but split vertically.  If 'equalalways' is set
! 		and 'eadirection' isn't "ver" the windows will be spread out
! 		horizontally, unless a width was specified.
  		Note: In other places CTRL-Q does the same as CTRL-V, but here
  		it doesn't!
  
--- 141,153 ----
  CTRL-W CTRL-V						*CTRL-W_CTRL-V*
  CTRL-W v						*CTRL-W_v*
  :[N]vs[plit] [++opt] [+cmd] [file]			*:vs* *:vsplit*
! 		Like |:split|, but split vertically.  The windows will be
! 		spread out horizontally if
! 		1. a width was not specified,
! 		2. 'equalalways' is set,
! 		3. 'eadirection' isn't "ver", and
! 		4. one of the other windows are wider than the current or new
! 		   window.
  		Note: In other places CTRL-Q does the same as CTRL-V, but here
  		it doesn't!
  
*** ../vim-7.1.067/src/window.c	Sat Aug 11 13:37:36 2007
--- src/window.c	Sat Aug 11 17:25:38 2007
***************
*** 733,739 ****
      if (flags & WSP_VERT)
      {
  	layout = FR_ROW;
- 	do_equal = (p_ea && new_size == 0 && *p_ead != 'v');
  
  	/*
  	 * Check if we are able to split the current window and compute its
--- 733,738 ----
***************
*** 770,785 ****
  	 * instead, if possible. */
  	if (oldwin->w_p_wfw)
  	    win_setwidth_win(oldwin->w_width + new_size, oldwin);
      }
      else
  #endif
      {
  	layout = FR_COL;
- 	do_equal = (p_ea && new_size == 0
- #ifdef FEAT_VERTSPLIT
- 		&& *p_ead != 'h'
- #endif
- 		);
  
  	/*
  	 * Check if we are able to split the current window and compute its
--- 769,799 ----
  	 * instead, if possible. */
  	if (oldwin->w_p_wfw)
  	    win_setwidth_win(oldwin->w_width + new_size, oldwin);
+ 
+ 	/* Only make all windows the same width if one of them (except oldwin)
+ 	 * is wider than one of the split windows. */
+ 	if (!do_equal && p_ea && size == 0 && *p_ead != 'v'
+ 	   && oldwin->w_frame->fr_parent != NULL)
+ 	{
+ 	    frp = oldwin->w_frame->fr_parent->fr_child;
+ 	    while (frp != NULL)
+ 	    {
+ 		if (frp->fr_win != oldwin && frp->fr_win != NULL
+ 			&& (frp->fr_win->w_width > new_size
+ 			    || frp->fr_win->w_width > oldwin->w_width
+ 						   - new_size - STATUS_HEIGHT))
+ 		{
+ 		    do_equal = TRUE;
+ 		    break;
+ 		}
+ 		frp = frp->fr_next;
+ 	    }
+ 	}
      }
      else
  #endif
      {
  	layout = FR_COL;
  
  	/*
  	 * Check if we are able to split the current window and compute its
***************
*** 831,836 ****
--- 845,873 ----
  	    oldwin_height = oldwin->w_height;
  	    if (need_status)
  		oldwin_height -= STATUS_HEIGHT;
+ 	}
+ 
+ 	/* Only make all windows the same height if one of them (except oldwin)
+ 	 * is higher than one of the split windows. */
+ 	if (!do_equal && p_ea && size == 0
+ #ifdef FEAT_VERTSPLIT
+ 		&& *p_ead != 'h'
+ #endif
+ 	   && oldwin->w_frame->fr_parent != NULL)
+ 	{
+ 	    frp = oldwin->w_frame->fr_parent->fr_child;
+ 	    while (frp != NULL)
+ 	    {
+ 		if (frp->fr_win != oldwin && frp->fr_win != NULL
+ 			&& (frp->fr_win->w_height > new_size
+ 			    || frp->fr_win->w_height > oldwin_height - new_size
+ 							      - STATUS_HEIGHT))
+ 		{
+ 		    do_equal = TRUE;
+ 		    break;
+ 		}
+ 		frp = frp->fr_next;
+ 	    }
  	}
      }
  
*** ../vim-7.1.067/src/version.c	Sun Aug 12 16:38:03 2007
--- src/version.c	Sun Aug 12 16:51:36 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     68,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
129. You cancel your newspaper subscription.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.069
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.069
Problem:    GTK GUI: When using confirm() without a default button there still
	    is a default choice.
Solution:   Ignore Enter and Space when there is no default button. (Chris
	    Lubinski)
Files:	    src/gui_gtk.c


*** ../vim-7.1.068/src/gui_gtk.c	Mon May 14 19:35:51 2007
--- src/gui_gtk.c	Sat Aug 11 17:38:03 2007
***************
*** 1630,1640 ****
   */
  /*ARGSUSED*/
      static int
! dlg_key_press_event(GtkWidget * widget, GdkEventKey * event, CancelData *data)
  {
!     /* Ignore hitting Enter when there is no default button. */
!     if (data->ignore_enter && event->keyval == GDK_Return)
  	return TRUE;
  
      if (event->keyval != GDK_Escape && event->keyval != GDK_Return)
  	return FALSE;
--- 1630,1643 ----
   */
  /*ARGSUSED*/
      static int
! dlg_key_press_event(GtkWidget *widget, GdkEventKey *event, CancelData *data)
  {
!     /* Ignore hitting Enter (or Space) when there is no default button. */
!     if (data->ignore_enter && (event->keyval == GDK_Return
! 						     || event->keyval == ' '))
  	return TRUE;
+     else    /* A different key was pressed, return to normal behavior */
+ 	data->ignore_enter = FALSE;
  
      if (event->keyval != GDK_Escape && event->keyval != GDK_Return)
  	return FALSE;
***************
*** 2223,2228 ****
--- 2226,2238 ----
  dialog_key_press_event_cb(GtkWidget *widget, GdkEventKey *event, gpointer data)
  {
      DialogInfo *di = (DialogInfo *)data;
+ 
+     /* Ignore hitting Enter (or Space) when there is no default button. */
+     if (di->ignore_enter && (event->keyval == GDK_Return
+ 						     || event->keyval == ' '))
+ 	return TRUE;
+     else    /* A different key was pressed, return to normal behavior */
+ 	di->ignore_enter = FALSE;
  
      /* Close the dialog when hitting "Esc". */
      if (event->keyval == GDK_Escape)
*** ../vim-7.1.068/src/version.c	Sun Aug 12 16:55:01 2007
--- src/version.c	Tue Aug 14 14:58:36 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     69,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
148. You find it easier to dial-up the National Weather Service
     Weather/your_town/now.html than to simply look out the window.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.070 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.070 (extra)
Problem:    Win32 GUI: When using confirm() without a default button there
	    still is a default choice.
Solution:   Set focus on something else than a button. (Chris Lubinski)
Files:	    src/gui_w32.c


*** ../vim-7.1.069/src/gui_w32.c	Tue Jun 19 10:09:15 2007
--- src/gui_w32.c	Sat Aug 11 17:39:50 2007
***************
*** 2894,2899 ****
--- 2894,2903 ----
  	(void)SetFocus(hwnd);
  	if (dialog_default_button > IDCANCEL)
  	    (void)SetFocus(GetDlgItem(hwnd, dialog_default_button));
+ 	else
+ 	    /* We don't have a default, set focus on another element of the
+ 	     * dialog window, probably the icon */
+ 	    (void)SetFocus(GetDlgItem(hwnd, DLG_NONBUTTON_CONTROL));
  	return FALSE;
      }
  
*** ../vim-7.1.069/src/version.c	Tue Aug 14 14:59:41 2007
--- src/version.c	Tue Aug 14 16:55:41 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     70,
  /**/

-- 
You are not really successful until someone claims he sat
beside you in school.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.071
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.071 (after 7.1.040)
Problem:    Regexp patterns are not tested.
Solution:   Add a basic test, to be expanded later.
	    Also add (commented-out) support for valgrind.
Files:	    src/testdir/Makefile, src/testdir/test64.in, src/testdir/test64.ok


*** ../vim-7.1.070/src/testdir/Makefile	Thu Jul 26 22:55:11 2007
--- src/testdir/Makefile	Tue Aug 14 15:16:08 2007
***************
*** 4,9 ****
--- 4,13 ----
  
  VIMPROG = ../vim
  
+ # Uncomment this line for using valgrind.
+ # The output goes into a file "valgrind.$PID" (sorry, no test number).
+ # VALGRIND = valgrind --tool=memcheck --num-callers=15 --logfile=valgrind
+ 
  SCRIPTS = test1.out test2.out test3.out test4.out test5.out test6.out \
  		test7.out test8.out test9.out test10.out test11.out \
  		test12.out  test13.out test14.out test15.out test17.out \
***************
*** 15,21 ****
  		test43.out test44.out test45.out test46.out test47.out \
  		test48.out test49.out test51.out test52.out test53.out \
  		test54.out test55.out test56.out test57.out test58.out \
! 		test59.out test60.out test61.out test62.out test63.out
  
  SCRIPTS_GUI = test16.out
  
--- 19,26 ----
  		test43.out test44.out test45.out test46.out test47.out \
  		test48.out test49.out test51.out test52.out test53.out \
  		test54.out test55.out test56.out test57.out test58.out \
! 		test59.out test60.out test61.out test62.out test63.out \
! 		test64.out
  
  SCRIPTS_GUI = test16.out
  
***************
*** 38,44 ****
  
  test1.out: test1.in
  	-rm -f $*.failed tiny.vim small.vim mbyte.vim test.ok X* viminfo
! 	$(VIMPROG) -u unix.vim -U NONE --noplugin -s dotest.in $*.in
  	@/bin/sh -c "if diff test.out $*.ok; \
  		then mv -f test.out $*.out; \
  		else echo; \
--- 43,49 ----
  
  test1.out: test1.in
  	-rm -f $*.failed tiny.vim small.vim mbyte.vim test.ok X* viminfo
! 	$(VALGRIND) $(VIMPROG) -u unix.vim -U NONE --noplugin -s dotest.in $*.in
  	@/bin/sh -c "if diff test.out $*.ok; \
  		then mv -f test.out $*.out; \
  		else echo; \
***************
*** 51,57 ****
  	cp $*.ok test.ok
  	# Sleep a moment to avoid that the xterm title is messed up
  	@-sleep .2
! 	-$(VIMPROG) -u unix.vim -U NONE --noplugin -s dotest.in $*.in
  	@/bin/sh -c "if test -f test.out; then\
  		  if diff test.out $*.ok; \
  		  then mv -f test.out $*.out; \
--- 56,62 ----
  	cp $*.ok test.ok
  	# Sleep a moment to avoid that the xterm title is messed up
  	@-sleep .2
! 	-$(VALGRIND) $(VIMPROG) -u unix.vim -U NONE --noplugin -s dotest.in $*.in
  	@/bin/sh -c "if test -f test.out; then\
  		  if diff test.out $*.ok; \
  		  then mv -f test.out $*.out; \
*** ../vim-7.1.070/src/testdir/test64.in	Tue Aug 14 17:26:28 2007
--- src/testdir/test64.in	Tue Aug 14 16:03:44 2007
***************
*** 0 ****
--- 1,52 ----
+ Test for regexp patterns.
+ 
+ A pattern that gives the expected result produces OK, so that we know it was
+ actually tried.
+ 
+ STARTTEST
+ :so small.vim
+ :" tl is a List of Lists with:
+ :"    regexp pattern
+ :"    text to test the pattern on
+ :"    expected match (optional)
+ :"    expected submatch 1 (optional)
+ :"    expected submatch 2 (optional)
+ :"    etc.
+ :"  When there is no match use only the first two items.
+ :let tl = []
+ :call add(tl, ['b', 'abcdef', 'b'])
+ :call add(tl, ['bc*', 'abccccdef', 'bcccc'])
+ :call add(tl, ['bc\{-}', 'abccccdef', 'b'])
+ :call add(tl, ['bc\{-}\(d\)', 'abccccdef', 'bccccd', 'd'])
+ :call add(tl, ['x', 'abcdef'])
+ :"
+ :for t in tl
+ :  let l = matchlist(t[1], t[0])
+ :" check the match itself
+ :  if len(l) == 0 && len(t) > 2
+ :    $put ='ERROR: pat: \"' . t[0] . '\", text: \"' . t[1] . '\", did not match, expected: \"' . t[2] . '\"'
+ :  elseif len(l) > 0 && len(t) == 2
+ :    $put ='ERROR: pat: \"' . t[0] . '\", text: \"' . t[1] . '\", match: \"' . l[0] . '\", expected no match'
+ :  elseif len(t) > 2 && l[0] != t[2]
+ :    $put ='ERROR: pat: \"' . t[0] . '\", text: \"' . t[1] . '\", match: \"' . l[0] . '\", expected: \"' . t[2] . '\"'
+ :  else
+ :    $put ='OK'
+ :  endif
+ :  if len(l) > 0
+ :"   check all the nine submatches
+ :    for i in range(1, 9)
+ :      if len(t) <= i + 2
+ :        let e = ''
+ :      else
+ :        let e = t[i + 2]
+ :      endif
+ :      if l[i] != e
+ :        $put ='ERROR: pat: \"' . t[0] . '\", text: \"' . t[1] . '\", submatch ' . i . ': \"' . l[i] . '\", expected: \"' . e . '\"'
+ :      endif
+ :    endfor
+ :  endif
+ :endfor
+ :/^Results/,$wq! test.out
+ ENDTEST
+ 
+ Results of test64:
*** ../vim-7.1.070/src/testdir/test64.ok	Tue Aug 14 17:26:28 2007
--- src/testdir/test64.ok	Tue Aug 14 16:01:47 2007
***************
*** 0 ****
--- 1,6 ----
+ Results of test64:
+ OK
+ OK
+ OK
+ OK
+ OK
*** ../vim-7.1.070/src/version.c	Tue Aug 14 16:57:04 2007
--- src/version.c	Tue Aug 14 17:25:20 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     71,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
150. You find yourself counting emoticons to get to sleep.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.072 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.072 (extra, after 7.1.041 and 7.1.071)
Problem:    Some changes for patch 7.1.071 are in extra files.
Solution:   Update the extra files.  Also fix a few warnings from the DOS test
	    makefile.
Files:	    src/testdir/Make_amiga.mak, src/testdir/Make_dos.mak,
	    src/testdir/Make_os2.mak, src/testdir/Make_vms.mms


*** ../vim-7.1.071/src/testdir/Make_amiga.mak	Thu Jul 26 23:10:50 2007
--- src/testdir/Make_amiga.mak	Tue Aug 14 15:14:03 2007
***************
*** 25,31 ****
  		test43.out test44.out test45.out test46.out test47.out \
  		test48.out test51.out test53.out test54.out test55.out \
  		test56.out test57.out test58.out test59.out test60.out \
! 		test61.out test62.out test63.out
  
  .SUFFIXES: .in .out
  
--- 25,31 ----
  		test43.out test44.out test45.out test46.out test47.out \
  		test48.out test51.out test53.out test54.out test55.out \
  		test56.out test57.out test58.out test59.out test60.out \
! 		test61.out test62.out test63.out test64.out
  
  .SUFFIXES: .in .out
  
***************
*** 108,110 ****
--- 108,111 ----
  test61.out: test61.in
  test62.out: test62.in
  test63.out: test63.in
+ test64.out: test64.in
*** ../vim-7.1.071/src/testdir/Make_dos.mak	Thu Jul 26 23:10:50 2007
--- src/testdir/Make_dos.mak	Tue Aug 14 15:14:25 2007
***************
*** 19,25 ****
  		test44.out test45.out test46.out test47.out \
  		test48.out test51.out test53.out test54.out \
  		test55.out test56.out test57.out test58.out test59.out \
! 		test60.out test61.out test62.out test63.out
  
  SCRIPTS =	test3.out test4.out test5.out test6.out test7.out \
  		test8.out test9.out test11.out test13.out test14.out \
--- 19,25 ----
  		test44.out test45.out test46.out test47.out \
  		test48.out test51.out test53.out test54.out \
  		test55.out test56.out test57.out test58.out test59.out \
! 		test60.out test61.out test62.out test63.out test64.out
  
  SCRIPTS =	test3.out test4.out test5.out test6.out test7.out \
  		test8.out test9.out test11.out test13.out test14.out \
***************
*** 51,69 ****
  
  clean:
  	-del *.out
! 	-del test.ok
! 	-del small.vim
! 	-del tiny.vim
! 	-del mbyte.vim
  	-del X*
! 	-del viminfo
  
  .in.out:
  	copy $*.ok test.ok
  	$(VIMPROG) -u dos.vim -U NONE --noplugin -s dotest.in $*.in
  	diff test.out $*.ok
! 	-del $*.out
  	rename test.out $*.out
  	-del X*
  	-del test.ok
! 	-del viminfo
--- 51,69 ----
  
  clean:
  	-del *.out
! 	-if exist test.ok del test.ok
! 	-if exist small.vim del small.vim
! 	-if exist tiny.vim del tiny.vim
! 	-if exist mbyte.vim del mbyte.vim
  	-del X*
! 	-if exist viminfo del viminfo
  
  .in.out:
  	copy $*.ok test.ok
  	$(VIMPROG) -u dos.vim -U NONE --noplugin -s dotest.in $*.in
  	diff test.out $*.ok
! 	-if exist $*.out del $*.out
  	rename test.out $*.out
  	-del X*
  	-del test.ok
! 	-if exist viminfo del viminfo
*** ../vim-7.1.071/src/testdir/Make_os2.mak	Thu Jul 26 23:10:50 2007
--- src/testdir/Make_os2.mak	Tue Aug 14 15:14:44 2007
***************
*** 25,31 ****
  		test43.out test44.out test45.out test46.out test47.out \
  		test48.out test51.out test53.out test54.out test55.out \
  		test56.out test57.out test58.out test59.out test60.out \
! 		test61.out test62.out test63.out
  
  .SUFFIXES: .in .out
  
--- 25,31 ----
  		test43.out test44.out test45.out test46.out test47.out \
  		test48.out test51.out test53.out test54.out test55.out \
  		test56.out test57.out test58.out test59.out test60.out \
! 		test61.out test62.out test63.out test64.out
  
  .SUFFIXES: .in .out
  
*** ../vim-7.1.071/src/testdir/Make_vms.mms	Thu Jul 26 23:10:50 2007
--- src/testdir/Make_vms.mms	Tue Aug 14 15:15:56 2007
***************
*** 4,10 ****
  # Authors:	Zoltan Arpadffy, <arpadffy@polarhome.com>
  #		Sandor Kopanyi,  <sandor.kopanyi@mailbox.hu>
  #
! # Last change:  2007 Jul 24
  #
  # This has been tested on VMS 6.2 to 7.2 on DEC Alpha and VAX.
  # Edit the lines in the Configuration section below to select.
--- 4,10 ----
  # Authors:	Zoltan Arpadffy, <arpadffy@polarhome.com>
  #		Sandor Kopanyi,  <sandor.kopanyi@mailbox.hu>
  #
! # Last change:  2007 Aug 14
  #
  # This has been tested on VMS 6.2 to 7.2 on DEC Alpha and VAX.
  # Edit the lines in the Configuration section below to select.
***************
*** 59,65 ****
  	 test43.out test44.out test45.out test46.out \
  	 test48.out test51.out test53.out test54.out test55.out \
  	 test56.out test57.out test58.out test59.out test60.out \
! 	 test61.out test62.out test63.out
  
  .IFDEF WANT_GUI
  SCRIPT_GUI = test16.out
--- 59,65 ----
  	 test43.out test44.out test45.out test46.out \
  	 test48.out test51.out test53.out test54.out test55.out \
  	 test56.out test57.out test58.out test59.out test60.out \
! 	 test61.out test62.out test63.out test64.out
  
  .IFDEF WANT_GUI
  SCRIPT_GUI = test16.out
*** ../vim-7.1.071/src/version.c	Tue Aug 14 17:28:14 2007
--- src/version.c	Tue Aug 14 17:51:21 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     72,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
152. You find yourself falling for someone you've never seen or hardly
     know, but, boy can he/she TYPE!!!!!!

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.073
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.073 (after 7.1.062)
Problem:    Wrong cursor position and crash when 'preserveindent' is set.
	    (Charles Campbell)
Solution:   Handle the situation that we start without indent. (Chris
	    Lubinski)
Files:	    src/misc1.c


*** ../vim-7.1.072/src/misc1.c	Sat Aug 11 14:32:10 2007
--- src/misc1.c	Tue Aug 14 21:21:49 2007
***************
*** 104,110 ****
      int		ind_done = 0;	    /* measured in spaces */
      int		tab_pad;
      int		retval = FALSE;
!     int		orig_char_len = 0;  /* number of initial whitespace chars when
  				       'et' and 'pi' are both set */
  
      /*
--- 104,110 ----
      int		ind_done = 0;	    /* measured in spaces */
      int		tab_pad;
      int		retval = FALSE;
!     int		orig_char_len = -1; /* number of initial whitespace chars when
  				       'et' and 'pi' are both set */
  
      /*
***************
*** 159,165 ****
  
  	    /* Fill to next tabstop with a tab, if possible */
  	    tab_pad = (int)curbuf->b_p_ts - (ind_done % (int)curbuf->b_p_ts);
! 	    if (todo >= tab_pad && orig_char_len == 0)
  	    {
  		doit = TRUE;
  		todo -= tab_pad;
--- 159,165 ----
  
  	    /* Fill to next tabstop with a tab, if possible */
  	    tab_pad = (int)curbuf->b_p_ts - (ind_done % (int)curbuf->b_p_ts);
! 	    if (todo >= tab_pad && orig_char_len == -1)
  	    {
  		doit = TRUE;
  		todo -= tab_pad;
***************
*** 206,216 ****
      /* If 'preserveindent' and 'expandtab' are both set keep the original
       * characters and allocate accordingly.  We will fill the rest with spaces
       * after the if (!curbuf->b_p_et) below. */
!     if (orig_char_len != 0)
      {
  	newline = alloc(orig_char_len + size - ind_done + line_len);
  	if (newline == NULL)
  	    return FALSE;
  	p = oldline;
  	s = newline;
  	while (orig_char_len > 0)
--- 206,220 ----
      /* If 'preserveindent' and 'expandtab' are both set keep the original
       * characters and allocate accordingly.  We will fill the rest with spaces
       * after the if (!curbuf->b_p_et) below. */
!     if (orig_char_len != -1)
      {
  	newline = alloc(orig_char_len + size - ind_done + line_len);
  	if (newline == NULL)
  	    return FALSE;
+ 	todo = size - ind_done;
+ 	ind_len = orig_char_len + todo;    /* Set total length of indent in
+ 					    * characters, which may have been
+ 					    * undercounted until now  */
  	p = oldline;
  	s = newline;
  	while (orig_char_len > 0)
***************
*** 222,230 ****
  	 * than old) */
  	while (vim_iswhite(*p))
  	    (void)*p++;
- 	todo = size - ind_done;
- 	ind_len += todo;    /* Set total length of indent in characters,
- 			     * which may have been undercounted until now  */
  
      }
      else
--- 226,231 ----
*** ../vim-7.1.072/src/version.c	Tue Aug 14 17:54:37 2007
--- src/version.c	Tue Aug 14 22:14:54 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     73,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
157. You fum through a magazine, you first check to see if it has a web
     address.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.074
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.074
Problem:    Crash when calling string() on a recurively nested List.
Solution:   Check result value for being NULL. (Yukihiro Nakadaira)
Files:	    src/eval.c


*** ../vim-7.1.073/src/eval.c	Mon Aug  6 22:27:12 2007
--- src/eval.c	Tue Aug 14 22:01:12 2007
***************
*** 6802,6808 ****
   * "numbuf" is used for a number.
   * Does not put quotes around strings, as ":echo" displays values.
   * When "copyID" is not NULL replace recursive lists and dicts with "...".
!  * May return NULL;
   */
      static char_u *
  echo_string(tv, tofree, numbuf, copyID)
--- 6802,6808 ----
   * "numbuf" is used for a number.
   * Does not put quotes around strings, as ":echo" displays values.
   * When "copyID" is not NULL replace recursive lists and dicts with "...".
!  * May return NULL.
   */
      static char_u *
  echo_string(tv, tofree, numbuf, copyID)
***************
*** 6887,6893 ****
   * If the memory is allocated "tofree" is set to it, otherwise NULL.
   * "numbuf" is used for a number.
   * Puts quotes around strings, so that they can be parsed back by eval().
!  * May return NULL;
   */
      static char_u *
  tv2string(tv, tofree, numbuf, copyID)
--- 6887,6893 ----
   * If the memory is allocated "tofree" is set to it, otherwise NULL.
   * "numbuf" is used for a number.
   * Puts quotes around strings, so that they can be parsed back by eval().
!  * May return NULL.
   */
      static char_u *
  tv2string(tv, tofree, numbuf, copyID)
***************
*** 14974,14979 ****
--- 14974,14983 ----
  
      p1 = tv2string(&(*(listitem_T **)s1)->li_tv, &tofree1, numbuf1, 0);
      p2 = tv2string(&(*(listitem_T **)s2)->li_tv, &tofree2, numbuf2, 0);
+     if (p1 == NULL)
+ 	p1 = (char_u *)"";
+     if (p2 == NULL)
+ 	p2 = (char_u *)"";
      if (item_compare_ic)
  	res = STRICMP(p1, p2);
      else
***************
*** 15463,15469 ****
  
      rettv->v_type = VAR_STRING;
      rettv->vval.v_string = tv2string(&argvars[0], &tofree, numbuf, 0);
!     if (tofree == NULL)
  	rettv->vval.v_string = vim_strsave(rettv->vval.v_string);
  }
  
--- 15467,15474 ----
  
      rettv->v_type = VAR_STRING;
      rettv->vval.v_string = tv2string(&argvars[0], &tofree, numbuf, 0);
!     /* Make a copy if we have a value but it's not in allocate memory. */
!     if (rettv->vval.v_string != NULL && tofree == NULL)
  	rettv->vval.v_string = vim_strsave(rettv->vval.v_string);
  }
  
***************
*** 20167,20172 ****
--- 20174,20180 ----
  		char_u	buf[MSG_BUF_LEN];
  		char_u	numbuf2[NUMBUFLEN];
  		char_u	*tofree;
+ 		char_u	*s;
  
  		msg_puts((char_u *)"(");
  		for (i = 0; i < argcount; ++i)
***************
*** 20177,20186 ****
  			msg_outnum((long)argvars[i].vval.v_number);
  		    else
  		    {
! 			trunc_string(tv2string(&argvars[i], &tofree,
! 					      numbuf2, 0), buf, MSG_BUF_CLEN);
! 			msg_puts(buf);
! 			vim_free(tofree);
  		    }
  		}
  		msg_puts((char_u *)")");
--- 20185,20197 ----
  			msg_outnum((long)argvars[i].vval.v_number);
  		    else
  		    {
! 			s = tv2string(&argvars[i], &tofree, numbuf2, 0);
! 			if (s != NULL)
! 			{
! 			    trunc_string(s, buf, MSG_BUF_CLEN);
! 			    msg_puts(buf);
! 			    vim_free(tofree);
! 			}
  		    }
  		}
  		msg_puts((char_u *)")");
***************
*** 20258,20271 ****
  	    char_u	buf[MSG_BUF_LEN];
  	    char_u	numbuf2[NUMBUFLEN];
  	    char_u	*tofree;
  
  	    /* The value may be very long.  Skip the middle part, so that we
  	     * have some idea how it starts and ends. smsg() would always
  	     * truncate it at the end. */
! 	    trunc_string(tv2string(fc.rettv, &tofree, numbuf2, 0),
! 							   buf, MSG_BUF_CLEN);
! 	    smsg((char_u *)_("%s returning %s"), sourcing_name, buf);
! 	    vim_free(tofree);
  	}
  	msg_puts((char_u *)"\n");   /* don't overwrite this either */
  
--- 20269,20286 ----
  	    char_u	buf[MSG_BUF_LEN];
  	    char_u	numbuf2[NUMBUFLEN];
  	    char_u	*tofree;
+ 	    char_u	*s;
  
  	    /* The value may be very long.  Skip the middle part, so that we
  	     * have some idea how it starts and ends. smsg() would always
  	     * truncate it at the end. */
! 	    s = tv2string(fc.rettv, &tofree, numbuf2, 0);
! 	    if (s != NULL)
! 	    {
! 		trunc_string(s, buf, MSG_BUF_CLEN);
! 		smsg((char_u *)_("%s returning %s"), sourcing_name, buf);
! 		vim_free(tofree);
! 	    }
  	}
  	msg_puts((char_u *)"\n");   /* don't overwrite this either */
  
*** ../vim-7.1.073/src/version.c	Tue Aug 14 22:15:53 2007
--- src/version.c	Tue Aug 14 22:27:24 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     74,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
159. You get excited whenever discussing your hard drive.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.075
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.075
Problem:    ":let v:statusmsg" reads memory already freed.
Solution:   Don't set v:statusmsg when listing it.
Files:	    src/eval.c


*** ../vim-7.1.074/src/eval.c	Tue Aug 14 22:28:35 2007
--- src/eval.c	Tue Aug 14 22:01:12 2007
***************
*** 18022,18028 ****
      int		type;
      char_u	*string;
  {
!     msg_attr(prefix, 0);    /* don't use msg(), it overwrites "v:statusmsg" */
      if (name != NULL)	/* "a:" vars don't have a name stored */
  	msg_puts(name);
      msg_putchar(' ');
--- 18022,18030 ----
      int		type;
      char_u	*string;
  {
!     /* don't use msg() or msg_attr() to avoid overwriting "v:statusmsg" */
!     msg_start();
!     msg_puts(prefix);
      if (name != NULL)	/* "a:" vars don't have a name stored */
  	msg_puts(name);
      msg_putchar(' ');
*** ../vim-7.1.074/src/version.c	Tue Aug 14 22:28:35 2007
--- src/version.c	Tue Aug 14 22:39:49 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     75,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
160. You get in the elevator and double-click the button for the floor
     you want.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.076
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.076
Problem:    Another strcpy() with overlapping arguments.
Solution:   Use mch_memmove(). (Dominique Pelle)  And another one.
Files:	    src/ex_docmd.c, src/normal.c


*** ../vim-7.1.075/src/ex_docmd.c	Sat Aug 11 15:59:44 2007
--- src/ex_docmd.c	Wed Aug  8 22:28:33 2007
***************
*** 4493,4499 ****
  	    if (eap->argt & (USECTRLV | XFILE))
  		++p;		/* skip CTRL-V and next char */
  	    else
! 		STRCPY(p, p + 1);	/* remove CTRL-V and skip next char */
  	    if (*p == NUL)		/* stop at NUL after CTRL-V */
  		break;
  	}
--- 4493,4500 ----
  	    if (eap->argt & (USECTRLV | XFILE))
  		++p;		/* skip CTRL-V and next char */
  	    else
! 				/* remove CTRL-V and skip next char */
! 		mch_memmove(p, p + 1, STRLEN(p));
  	    if (*p == NUL)		/* stop at NUL after CTRL-V */
  		break;
  	}
*** ../vim-7.1.075/src/normal.c	Wed Aug  8 21:41:19 2007
--- src/normal.c	Sun Aug 12 17:35:20 2007
***************
*** 3760,3766 ****
      extra_len = (int)STRLEN(p);
      overflow = old_len + extra_len - SHOWCMD_COLS;
      if (overflow > 0)
! 	STRCPY(showcmd_buf, showcmd_buf + overflow);
      STRCAT(showcmd_buf, p);
  
      if (char_avail())
--- 3760,3767 ----
      extra_len = (int)STRLEN(p);
      overflow = old_len + extra_len - SHOWCMD_COLS;
      if (overflow > 0)
! 	mch_memmove(showcmd_buf, showcmd_buf + overflow,
! 						      old_len - overflow + 1);
      STRCAT(showcmd_buf, p);
  
      if (char_avail())
*** ../vim-7.1.075/src/version.c	Tue Aug 14 22:40:13 2007
--- src/version.c	Tue Aug 14 22:53:13 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     76,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
161. You get up before the sun rises to check your e-mail, and you
     find yourself in the very same chair long after the sun has set.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.077
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.077
Problem:    Using "can_spell" without initializing it. (Dominique Pelle)
Solution:   Set a default for get_syntax_attr().
Files:	    src/syntax.c


*** ../vim-7.1.076/src/syntax.c	Thu Jul 26 22:55:11 2007
--- src/syntax.c	Sun Aug 12 19:49:07 2007
***************
*** 1727,1732 ****
--- 1727,1739 ----
  {
      int	    attr = 0;
  
+     if (can_spell != NULL)
+ 	/* Default: Only do spelling when there is no @Spell cluster or when
+ 	 * ":syn spell toplevel" was used. */
+ 	*can_spell = syn_buf->b_syn_spell == SYNSPL_DEFAULT
+ 		    ? (syn_buf->b_spell_cluster_id == 0)
+ 		    : (syn_buf->b_syn_spell == SYNSPL_TOP);
+ 
      /* check for out of memory situation */
      if (syn_buf->b_sst_array == NULL)
  	return 0;
*** ../vim-7.1.076/src/version.c	Tue Aug 14 22:54:00 2007
--- src/version.c	Tue Aug 14 23:06:26 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     77,
  /**/

-- 
Send $25.00 for handy leaflet on how to make money by selling leaflets

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.078
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.078
Problem:    Dropping a file name on gvim that contains a CSI byte doesn't work
	    when editing the command line.
Solution:   Escape the CSI byte when inserting in the input buffer. (Yukihiro
	    Nakadaira)
Files:	    src/gui.c, src/ui.c


*** ../vim-7.1.077/src/gui.c	Thu May 10 19:19:15 2007
--- src/gui.c	Tue Aug 14 12:41:43 2007
***************
*** 5117,5123 ****
  		p = vim_strsave_escaped(fnames[i], (char_u *)"\\ \t\"|");
  # endif
  		if (p != NULL)
! 		    add_to_input_buf(p, (int)STRLEN(p));
  		vim_free(p);
  		vim_free(fnames[i]);
  	    }
--- 5117,5123 ----
  		p = vim_strsave_escaped(fnames[i], (char_u *)"\\ \t\"|");
  # endif
  		if (p != NULL)
! 		    add_to_input_buf_csi(p, (int)STRLEN(p));
  		vim_free(p);
  		vim_free(fnames[i]);
  	    }
*** ../vim-7.1.077/src/ui.c	Thu May 10 21:14:11 2007
--- src/ui.c	Tue Aug 14 12:41:42 2007
***************
*** 1603,1610 ****
  #if defined(FEAT_GUI) || defined(FEAT_MOUSE_GPM) \
  	|| defined(FEAT_XCLIPBOARD) || defined(VMS) \
  	|| defined(FEAT_SNIFF) || defined(FEAT_CLIENTSERVER) \
- 	|| (defined(FEAT_GUI) && (!defined(USE_ON_FLY_SCROLL) \
- 		|| defined(FEAT_MENU))) \
  	|| defined(PROTO)
  /*
   * Add the given bytes to the input buffer
--- 1603,1608 ----
***************
*** 1630,1636 ****
  }
  #endif
  
! #if (defined(FEAT_XIM) && defined(FEAT_GUI_GTK)) \
  	|| (defined(FEAT_MBYTE) && defined(FEAT_MBYTE_IME)) \
  	|| (defined(FEAT_GUI) && (!defined(USE_ON_FLY_SCROLL) \
  		|| defined(FEAT_MENU))) \
--- 1628,1636 ----
  }
  #endif
  
! #if ((defined(FEAT_XIM) || defined(FEAT_DND)) && defined(FEAT_GUI_GTK)) \
! 	|| defined(FEAT_GUI_MSWIN) \
! 	|| defined(FEAT_GUI_MAC) \
  	|| (defined(FEAT_MBYTE) && defined(FEAT_MBYTE_IME)) \
  	|| (defined(FEAT_GUI) && (!defined(USE_ON_FLY_SCROLL) \
  		|| defined(FEAT_MENU))) \
*** ../vim-7.1.077/src/version.c	Tue Aug 14 23:06:51 2007
--- src/version.c	Wed Aug 15 20:07:06 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     78,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
164. You got out to buy software, instead of going out for a beer.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.079
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.079
Problem:    When the locale is "C" and 'encoding' is "latin1" then the "@"
	    character in 'isfname', 'isprint', etc. doesn't pick up accented
	    characters.
Solution:   Instead of isalpha() use MB_ISLOWER() and MB_ISUPPER().
Files:	    src/charset.c, src/macros.h


*** ../vim-7.1.078/src/charset.c	Mon Aug  6 22:27:12 2007
--- src/charset.c	Tue Aug 14 13:43:30 2007
***************
*** 207,213 ****
  	    }
  	    while (c <= c2)
  	    {
! 		if (!do_isalpha || isalpha(c)
  #ifdef FEAT_FKMAP
  			|| (p_altkeymap && (F_isalpha(c) || F_isdigit(c)))
  #endif
--- 207,216 ----
  	    }
  	    while (c <= c2)
  	    {
! 		/* Use the MB_ functions here, because isalpha() doesn't
! 		 * work properly when 'encoding' is "latin1" and the locale is
! 		 * "C".  */
! 		if (!do_isalpha || MB_ISLOWER(c) || MB_ISUPPER(c)
  #ifdef FEAT_FKMAP
  			|| (p_altkeymap && (F_isalpha(c) || F_isdigit(c)))
  #endif
*** ../vim-7.1.078/src/macros.h	Thu May 10 19:21:00 2007
--- src/macros.h	Sat Aug  4 13:44:18 2007
***************
*** 54,63 ****
  
  /*
   * toupper() and tolower() that use the current locale.
!  * On some systems toupper()/tolower() only work on lower/uppercase characters
   * Careful: Only call TOUPPER_LOC() and TOLOWER_LOC() with a character in the
   * range 0 - 255.  toupper()/tolower() on some systems can't handle others.
!  * Note: for UTF-8 use utf_toupper() and utf_tolower().
   */
  #ifdef MSWIN
  #  define TOUPPER_LOC(c)	toupper_tab[(c) & 255]
--- 54,65 ----
  
  /*
   * toupper() and tolower() that use the current locale.
!  * On some systems toupper()/tolower() only work on lower/uppercase
!  * characters, first use islower() or isupper() then.
   * Careful: Only call TOUPPER_LOC() and TOLOWER_LOC() with a character in the
   * range 0 - 255.  toupper()/tolower() on some systems can't handle others.
!  * Note: It is often better to use MB_TOLOWER() and MB_TOUPPER(), because many
!  * toupper() and tolower() implementations only work for ASCII.
   */
  #ifdef MSWIN
  #  define TOUPPER_LOC(c)	toupper_tab[(c) & 255]
*** ../vim-7.1.078/src/version.c	Wed Aug 15 20:07:53 2007
--- src/version.c	Wed Aug 15 20:39:18 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     79,
  /**/

-- 
You're as much use as a condom machine at the Vatican.
                  -- Rimmer to Holly in Red Dwarf 'Queeg'

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.080 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.080 (extra)
Problem:    Compiler warnings for using "const char *" for "char *".
Solution:   Add type casts. (Chris Sutcliffe)
Files:	    src/GvimExt/gvimext.cpp


*** ../vim-7.1.079/src/GvimExt/gvimext.cpp	Thu May 10 21:09:38 2007
--- src/GvimExt/gvimext.cpp	Thu Aug 16 21:25:56 2007
***************
*** 69,82 ****
  
      // Registry didn't work, use the search path.
      if (name[0] == 0)
! 	strcpy(name, searchpath("gvim.exe"));
  
      if (!runtime)
      {
  	// Only when looking for the executable, not the runtime dir, we can
  	// search for the batch file or a name without a path.
  	if (name[0] == 0)
! 	    strcpy(name, searchpath("gvim.bat"));
  	if (name[0] == 0)
  	    strcpy(name, "gvim");	// finds gvim.bat or gvim.exe
  
--- 69,82 ----
  
      // Registry didn't work, use the search path.
      if (name[0] == 0)
! 	strcpy(name, searchpath((char *)"gvim.exe"));
  
      if (!runtime)
      {
  	// Only when looking for the executable, not the runtime dir, we can
  	// search for the batch file or a name without a path.
  	if (name[0] == 0)
! 	    strcpy(name, searchpath((char *)"gvim.bat"));
  	if (name[0] == 0)
  	    strcpy(name, "gvim");	// finds gvim.bat or gvim.exe
  
***************
*** 152,160 ****
  	FARPROC	    *ptr;
      } libintl_entry[] =
      {
! 	{"gettext",		(FARPROC*)&dyn_libintl_gettext},
! 	{"textdomain",		(FARPROC*)&dyn_libintl_textdomain},
! 	{"bindtextdomain",	(FARPROC*)&dyn_libintl_bindtextdomain},
  	{NULL, NULL}
      };
  
--- 152,160 ----
  	FARPROC	    *ptr;
      } libintl_entry[] =
      {
! 	{(char *)"gettext",		(FARPROC*)&dyn_libintl_gettext},
! 	{(char *)"textdomain",		(FARPROC*)&dyn_libintl_textdomain},
! 	{(char *)"bindtextdomain",	(FARPROC*)&dyn_libintl_bindtextdomain},
  	{NULL, NULL}
      };
  
***************
*** 835,841 ****
  		    (LPTSTR)location) > (HINSTANCE)32)
  	    return location;
      }
!     return "";
  }
  # endif
  #endif
--- 835,841 ----
  		    (LPTSTR)location) > (HINSTANCE)32)
  	    return location;
      }
!     return (char *)"";
  }
  # endif
  #endif
*** ../vim-7.1.079/src/version.c	Wed Aug 15 20:40:45 2007
--- src/version.c	Sat Aug 18 16:58:36 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     80,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
192. Your boss asks you to "go fer" coffee and you come up with 235 FTP sites.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.081
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.081
Problem:    Command line completion for a shell command: "cat </tmp/file<Tab>"
	    doesn't work.
Solution:   Start the file name at any character that can't be in a file name.
	    (Martin Toft)
Files:	    src/ex_docmd.c


*** ../vim-7.1.080/src/ex_docmd.c	Tue Aug 14 22:54:00 2007
--- src/ex_docmd.c	Sat Aug 18 14:58:53 2007
***************
*** 3281,3319 ****
  
      if (ea.argt & XFILE)
      {
! 	int in_quote = FALSE;
! 	char_u *bow = NULL;	/* Beginning of word */
  
  	/*
  	 * Allow spaces within back-quotes to count as part of the argument
  	 * being expanded.
  	 */
  	xp->xp_pattern = skipwhite(arg);
! 	for (p = xp->xp_pattern; *p; )
  	{
! 	    if (*p == '\\' && p[1] != NUL)
  		++p;
  #ifdef SPACE_IN_FILENAME
! 	    else if (vim_iswhite(*p) && (!(ea.argt & NOSPC) || usefilter))
  #else
! 	    else if (vim_iswhite(*p))
  #endif
  	    {
! 		p = skipwhite(p);
  		if (in_quote)
  		    bow = p;
  		else
  		    xp->xp_pattern = p;
! 		--p;
! 	    }
! 	    else if (*p == '`')
! 	    {
! 		if (!in_quote)
! 		{
! 		    xp->xp_pattern = p;
! 		    bow = p + 1;
! 		}
! 		in_quote = !in_quote;
  	    }
  	    mb_ptr_adv(p);
  	}
--- 3281,3344 ----
  
      if (ea.argt & XFILE)
      {
! 	int	c;
! 	int	in_quote = FALSE;
! 	char_u	*bow = NULL;	/* Beginning of word */
  
  	/*
  	 * Allow spaces within back-quotes to count as part of the argument
  	 * being expanded.
  	 */
  	xp->xp_pattern = skipwhite(arg);
! 	p = xp->xp_pattern;
! 	while (*p != NUL)
  	{
! #ifdef FEAT_MBYTE
! 	    if (has_mbyte)
! 		c = mb_ptr2char(p);
! 	    else
! #endif
! 		c = *p;
! 	    if (c == '\\' && p[1] != NUL)
  		++p;
+ 	    else if (c == '`')
+ 	    {
+ 		if (!in_quote)
+ 		{
+ 		    xp->xp_pattern = p;
+ 		    bow = p + 1;
+ 		}
+ 		in_quote = !in_quote;
+ 	    }
  #ifdef SPACE_IN_FILENAME
! 	    else if (!vim_isfilec(c) && (!(ea.argt & NOSPC) || usefilter))
  #else
! 	    else if (!vim_isfilec(c))
  #endif
  	    {
! 		while (*p != NUL)
! 		{
! #ifdef FEAT_MBYTE
! 		    if (has_mbyte)
! 			c = mb_ptr2char(p);
! 		    else
! #endif
! 			c = *p;
! 		    if (c == '`' || vim_isfilec(c))
! 			break;
! #ifdef FEAT_MBYTE
! 		    if (has_mbyte)
! 			len = (*mb_ptr2len)(p);
! 		    else
! #endif
! 			len = 1;
! 		    mb_ptr_adv(p);
! 		}
  		if (in_quote)
  		    bow = p;
  		else
  		    xp->xp_pattern = p;
! 		p -= len;
  	    }
  	    mb_ptr_adv(p);
  	}
*** ../vim-7.1.080/src/version.c	Sat Aug 18 16:59:43 2007
--- src/version.c	Sat Aug 18 17:45:54 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     81,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
194. Your business cards contain your e-mail and home page address.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.082
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.082
Problem:    After a ":split" the matchparen highlighting isn't there.
Solution:   Install a WinEnter autocommand.  Also fixes that after
	    ":NoMatchParen" only the current window is updated. (Martin Toft)
Files:	    runtime/doc/pi_paren.txt, runtime/plugin/matchparen.vim


*** ../vim-7.1.081/runtime/doc/pi_paren.txt	Sat May 12 16:23:41 2007
--- runtime/doc/pi_paren.txt	Sat Aug 18 15:08:32 2007
***************
*** 12,19 ****
  You can avoid loading this plugin by setting the "loaded_matchparen" variable: >
  	:let loaded_matchparen = 1
  
! The plugin installs CursorMoved autocommands to redefine the match
! highlighting.
  
  To disable the plugin after it was loaded use this command: >
  
--- 12,19 ----
  You can avoid loading this plugin by setting the "loaded_matchparen" variable: >
  	:let loaded_matchparen = 1
  
! The plugin installs CursorMoved, CursorMovedI and WinEnter autocommands to
! redefine the match highlighting.
  
  To disable the plugin after it was loaded use this command: >
  
*** ../vim-7.1.081/runtime/plugin/matchparen.vim	Thu Aug  2 23:00:06 2007
--- runtime/plugin/matchparen.vim	Sat Aug 18 15:08:32 2007
***************
*** 1,6 ****
  " Vim plugin for showing matching parens
  " Maintainer:  Bram Moolenaar <Bram@vim.org>
! " Last Change: 2007 Jul 30
  
  " Exit quickly when:
  " - this plugin was already loaded (or disabled)
--- 1,6 ----
  " Vim plugin for showing matching parens
  " Maintainer:  Bram Moolenaar <Bram@vim.org>
! " Last Change: 2007 Aug 8
  
  " Exit quickly when:
  " - this plugin was already loaded (or disabled)
***************
*** 13,19 ****
  
  augroup matchparen
    " Replace all matchparen autocommands
!   autocmd! CursorMoved,CursorMovedI * call s:Highlight_Matching_Pair()
  augroup END
  
  " Skip the rest if it was already done.
--- 13,19 ----
  
  augroup matchparen
    " Replace all matchparen autocommands
!   autocmd! CursorMoved,CursorMovedI,WinEnter * call s:Highlight_Matching_Pair()
  augroup END
  
  " Skip the rest if it was already done.
***************
*** 126,132 ****
  endfunction
  
  " Define commands that will disable and enable the plugin.
! command! NoMatchParen 3match none | unlet! g:loaded_matchparen | au! matchparen
! command! DoMatchParen runtime plugin/matchparen.vim | doau CursorMoved
  
  let &cpo = cpo_save
--- 126,133 ----
  endfunction
  
  " Define commands that will disable and enable the plugin.
! command! NoMatchParen windo 3match none | unlet! g:loaded_matchparen |
! 	  \ au! matchparen
! command! DoMatchParen runtime plugin/matchparen.vim | windo doau CursorMoved
  
  let &cpo = cpo_save
*** ../vim-7.1.081/src/version.c	Sat Aug 18 17:46:50 2007
--- src/version.c	Sat Aug 18 18:19:20 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     82,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
195. Your cat has its own home page.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.083
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.083 (after 7.1.081)
Problem:    Command line completion doesn't work with wildcards.
Solution:   Add vim_isfilec_or_wc() and use it. (Martin Toft)
Files:	    src/charset.c, src/proto/charset.pro, src/ex_docmd.c


*** ../vim-7.1.082/src/charset.c	Wed Aug 15 20:40:45 2007
--- src/charset.c	Sun Aug 19 22:30:25 2007
***************
*** 932,937 ****
--- 932,954 ----
  }
  
  /*
+  * return TRUE if 'c' is a valid file-name character or a wildcard character
+  * Assume characters above 0x100 are valid (multi-byte).
+  * Explicitly interpret ']' as a wildcard character as mch_has_wildcard("]")
+  * returns false.
+  */
+     int
+ vim_isfilec_or_wc(c)
+     int c;
+ {
+     char_u buf[2];
+ 
+     buf[0] = (char_u)c;
+     buf[1] = NUL;
+     return vim_isfilec(c) || c == ']' || mch_has_wildcard(buf);
+ }
+ 
+ /*
   * return TRUE if 'c' is a printable character
   * Assume characters above 0x100 are printable (multi-byte), except for
   * Unicode.
*** ../vim-7.1.082/src/proto/charset.pro	Sat May  5 19:21:32 2007
--- src/proto/charset.pro	Sun Aug 19 22:30:28 2007
***************
*** 21,26 ****
--- 21,27 ----
  int vim_iswordp __ARGS((char_u *p));
  int vim_iswordc_buf __ARGS((char_u *p, buf_T *buf));
  int vim_isfilec __ARGS((int c));
+ int vim_isfilec_or_wc __ARGS((int c));
  int vim_isprintc __ARGS((int c));
  int vim_isprintc_strict __ARGS((int c));
  int lbr_chartabsize __ARGS((unsigned char *s, colnr_T col));
*** ../vim-7.1.082/src/ex_docmd.c	Sat Aug 18 17:46:50 2007
--- src/ex_docmd.c	Sun Aug 19 22:29:17 2007
***************
*** 3311,3319 ****
  		in_quote = !in_quote;
  	    }
  #ifdef SPACE_IN_FILENAME
! 	    else if (!vim_isfilec(c) && (!(ea.argt & NOSPC) || usefilter))
  #else
! 	    else if (!vim_isfilec(c))
  #endif
  	    {
  		while (*p != NUL)
--- 3311,3320 ----
  		in_quote = !in_quote;
  	    }
  #ifdef SPACE_IN_FILENAME
! 	    else if (!vim_isfilec_or_wc(c)
! 					 && (!(ea.argt & NOSPC) || usefilter))
  #else
! 	    else if (!vim_isfilec_or_wc(c))
  #endif
  	    {
  		while (*p != NUL)
***************
*** 3324,3330 ****
  		    else
  #endif
  			c = *p;
! 		    if (c == '`' || vim_isfilec(c))
  			break;
  #ifdef FEAT_MBYTE
  		    if (has_mbyte)
--- 3325,3331 ----
  		    else
  #endif
  			c = *p;
! 		    if (c == '`' || vim_isfilec_or_wc(c))
  			break;
  #ifdef FEAT_MBYTE
  		    if (has_mbyte)
*** ../vim-7.1.082/src/version.c	Sat Aug 18 18:20:57 2007
--- src/version.c	Sun Aug 19 22:31:43 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     83,
  /**/

-- 
    "You mean there really is an answer?"
    "Yes! But you're not going to like it!"
    "Oh do please tell us!"
    "You're really not going to like it!"
    "but we MUST know - tell us"
    "Alright, the answer is...."
    "yes..."
    "... is ..."
    "yes... come on!"
    "is 42!"
		(Douglas Adams - The Hitchhiker's Guide to the Galaxy)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.084
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.084
Problem:    Using the "-nb" argument twice causes netbeans not to get
	    fileOpened events.
Solution:   Change "&" to "&&". (Xavier de Gaye)
Files:	    src/ex_cmds.c


*** ../vim-7.1.083/src/ex_cmds.c	Wed Jul 25 22:55:22 2007
--- src/ex_cmds.c	Tue Aug 21 15:02:43 2007
***************
*** 3776,3782 ****
  	    workshop_file_opened((char *)curbuf->b_ffname, curbuf->b_p_ro);
  # endif
  # ifdef FEAT_NETBEANS_INTG
! 	if (usingNetbeans & ((flags & ECMD_SET_HELP) != ECMD_SET_HELP))
  	    netbeans_file_opened(curbuf);
  # endif
      }
--- 3787,3793 ----
  	    workshop_file_opened((char *)curbuf->b_ffname, curbuf->b_p_ro);
  # endif
  # ifdef FEAT_NETBEANS_INTG
! 	if (usingNetbeans && ((flags & ECMD_SET_HELP) != ECMD_SET_HELP))
  	    netbeans_file_opened(curbuf);
  # endif
      }
*** ../vim-7.1.083/src/version.c	Sun Aug 19 22:42:27 2007
--- src/version.c	Tue Aug 21 15:04:03 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     84,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
220. Your wife asks for sex and you tell her where to find you on IRC.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.085
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.085
Problem:    ":e fold.c" then ":sp fold.c" results in folds of original window
	    to disappear. (Akita Noek)
Solution:   Invoke foldUpdateAll() for all windows of the changed buffer.
	    (Martin Toft)
Files:	    src/ex_cmds.c


*** ../vim-7.1.084/src/ex_cmds.c	Tue Aug 21 15:05:54 2007
--- src/ex_cmds.c	Tue Aug 21 15:02:43 2007
***************
*** 2974,2980 ****
   * 'fnum' is the number of the file, if zero use ffname/sfname.
   *
   * Return 1 for "normal" error, 2 for "not written" error, 0 for success
!  * -1 for succesfully opening another file.
   * 'lnum' is the line number for the cursor in the new file (if non-zero).
   */
      int
--- 2974,2980 ----
   * 'fnum' is the number of the file, if zero use ffname/sfname.
   *
   * Return 1 for "normal" error, 2 for "not written" error, 0 for success
!  * -1 for successfully opening another file.
   * 'lnum' is the line number for the cursor in the new file (if non-zero).
   */
      int
***************
*** 3584,3592 ****
  	curwin_init();
  
  #ifdef FEAT_FOLDING
! 	/* It's like all lines in the buffer changed.  Need to update
! 	 * automatic folding. */
  	foldUpdateAll(curwin);
  #endif
  
  	/* Change directories when the 'acd' option is set. */
--- 3584,3603 ----
  	curwin_init();
  
  #ifdef FEAT_FOLDING
! 	/* It's possible that all lines in the buffer changed.  Need to update
! 	 * automatic folding for all windows where it's used. */
! # ifdef FEAT_WINDOWS
! 	{
! 	    win_T	    *win;
! 	    tabpage_T	    *tp;
! 
! 	    FOR_ALL_TAB_WINDOWS(tp, win)
! 		if (win->w_buffer == curbuf)
! 		    foldUpdateAll(win);
! 	}
! # else
  	foldUpdateAll(curwin);
+ # endif
  #endif
  
  	/* Change directories when the 'acd' option is set. */
*** ../vim-7.1.084/src/version.c	Tue Aug 21 15:05:54 2007
--- src/version.c	Tue Aug 21 15:26:43 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     85,
  /**/

-- 
Your fault: core dumped

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.086
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.086
Problem:    Crash when using specific Python syntax highlighting.  (Quirk)
Solution:   Check for a negative index, coming from a keyword match at the
	    start of a line from a saved state.
Files:	    src/syntax.c


*** ../vim-7.1.085/src/syntax.c	Tue Aug 14 23:06:51 2007
--- src/syntax.c	Tue Aug 21 17:13:51 2007
***************
*** 279,285 ****
   */
  typedef struct state_item
  {
!     int		si_idx;			/* index of syntax pattern */
      int		si_id;			/* highlight group ID for keywords */
      int		si_trans_id;		/* idem, transparancy removed */
      int		si_m_lnum;		/* lnum of the match */
--- 279,286 ----
   */
  typedef struct state_item
  {
!     int		si_idx;			/* index of syntax pattern or
! 					   KEYWORD_IDX */
      int		si_id;			/* highlight group ID for keywords */
      int		si_trans_id;		/* idem, transparancy removed */
      int		si_m_lnum;		/* lnum of the match */
***************
*** 837,845 ****
  			    current_lnum = end_lnum;
  			    break;
  			}
! 			spp = &(SYN_ITEMS(syn_buf)[cur_si->si_idx]);
! 			found_flags = spp->sp_flags;
! 			found_match_idx = spp->sp_sync_idx;
  			found_current_lnum = current_lnum;
  			found_current_col = current_col;
  			found_m_endpos = cur_si->si_m_endpos;
--- 838,855 ----
  			    current_lnum = end_lnum;
  			    break;
  			}
! 			if (cur_si->si_idx < 0)
! 			{
! 			    /* Cannot happen? */
! 			    found_flags = 0;
! 			    found_match_idx = KEYWORD_IDX;
! 			}
! 			else
! 			{
! 			    spp = &(SYN_ITEMS(syn_buf)[cur_si->si_idx]);
! 			    found_flags = spp->sp_flags;
! 			    found_match_idx = spp->sp_sync_idx;
! 			}
  			found_current_lnum = current_lnum;
  			found_current_col = current_col;
  			found_m_endpos = cur_si->si_m_endpos;
***************
*** 2533,2538 ****
--- 2543,2552 ----
      stateitem_T	*sip = &CUR_STATE(idx);
      synpat_T	*spp;
  
+     /* This should not happen... */
+     if (sip->si_idx < 0)
+ 	return;
+ 
      spp = &(SYN_ITEMS(syn_buf)[sip->si_idx]);
      if (sip->si_flags & HL_MATCH)
  	sip->si_id = spp->sp_syn_match_id;
***************
*** 2648,2653 ****
--- 2662,2671 ----
      lpos_T	end_endpos;
      int		end_idx;
  
+     /* return quickly for a keyword */
+     if (sip->si_idx < 0)
+ 	return;
+ 
      /* Don't update when it's already done.  Can be a match of an end pattern
       * that started in a previous line.  Watch out: can also be a "keepend"
       * from a containing item. */
***************
*** 2759,2764 ****
--- 2777,2786 ----
      lpos_T	pos;
      char_u	*line;
      int		had_match = FALSE;
+ 
+     /* just in case we are invoked for a keyword */
+     if (idx < 0)
+ 	return;
  
      /*
       * Check for being called with a START pattern.
*** ../vim-7.1.085/src/version.c	Tue Aug 21 15:28:32 2007
--- src/version.c	Tue Aug 21 17:21:06 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     86,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
222. You send more than 20 personal e-mails a day.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.087
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.087
Problem:    Reading past ":cscope find" command.  Writing past end of a buffer.
Solution:   Check length of the argument before using the pattern.  Use
	    vim_strncpy().  (Dominique Pelle)
Files:	    if_cscope.c


*** ../vim-7.1.086/src/if_cscope.c	Sun Mar 11 15:48:29 2007
--- src/if_cscope.c	Sun Aug 19 22:17:09 2007
***************
*** 73,78 ****
--- 73,80 ----
  
  
  static csinfo_T	    csinfo[CSCOPE_MAX_CONNECTIONS];
+ static int	    eap_arg_len;    /* length of eap->arg, set in
+ 				       cs_lookup_cmd() */
  static cscmd_T	    cs_cmds[] =
  {
      { "add",	cs_add,
***************
*** 260,273 ****
  
      if ((p = cs_manage_matches(NULL, NULL, -1, Get)) == NULL)
  	return TRUE;
! 
!     if ((int)strlen(p) > size)
!     {
! 	strncpy((char *)buf, p, size - 1);
! 	buf[size] = '\0';
!     }
!     else
! 	(void)strcpy((char *)buf, p);
  
      return FALSE;
  } /* cs_fgets */
--- 262,268 ----
  
      if ((p = cs_manage_matches(NULL, NULL, -1, Get)) == NULL)
  	return TRUE;
!     vim_strncpy(buf, (char_u *)p, size - 1);
  
      return FALSE;
  } /* cs_fgets */
***************
*** 386,392 ****
   * PRIVATE: cs_add
   *
   * add cscope database or a directory name (to look for cscope.out)
!  * the the cscope connection list
   *
   * MAXPATHL 256
   */
--- 381,387 ----
   * PRIVATE: cs_add
   *
   * add cscope database or a directory name (to look for cscope.out)
!  * to the cscope connection list
   *
   * MAXPATHL 256
   */
***************
*** 966,972 ****
      }
  
      pat = opt + strlen(opt) + 1;
!     if (pat == NULL || (pat != NULL && pat[0] == '\0'))
      {
  	cs_usage_msg(Find);
  	return FALSE;
--- 961,967 ----
      }
  
      pat = opt + strlen(opt) + 1;
!     if (pat >= (char *)eap->arg + eap_arg_len)
      {
  	cs_usage_msg(Find);
  	return FALSE;
***************
*** 1317,1323 ****
  #else
  	    /* compare pathnames first */
  	    && ((fullpathcmp(csinfo[j].fname, fname, FALSE) & FPC_SAME)
! 		/* if not Windows 9x, test index file atributes too */
  		|| (!mch_windows95()
  		    && csinfo[j].nVolume == bhfi.dwVolumeSerialNumber
  		    && csinfo[j].nIndexHigh == bhfi.nFileIndexHigh
--- 1312,1318 ----
  #else
  	    /* compare pathnames first */
  	    && ((fullpathcmp(csinfo[j].fname, fname, FALSE) & FPC_SAME)
! 		/* if not Windows 9x, test index file attributes too */
  		|| (!mch_windows95()
  		    && csinfo[j].nVolume == bhfi.dwVolumeSerialNumber
  		    && csinfo[j].nIndexHigh == bhfi.nFileIndexHigh
***************
*** 1401,1406 ****
--- 1396,1404 ----
      if (eap->arg == NULL)
  	return NULL;
  
+     /* Store length of eap->arg before it gets modified by strtok(). */
+     eap_arg_len = STRLEN(eap->arg);
+ 
      if ((stok = strtok((char *)(eap->arg), (const char *)" ")) == NULL)
  	return NULL;
  
***************
*** 2195,2201 ****
  	    cs_add_common(dblist[i], pplist[i], fllist[i]);
  	    if (p_csverbose)
  	    {
! 		/* dont' use smsg_attr because want to display
  		 * connection number in the same line as
  		 * "Added cscope database..."
  		 */
--- 2193,2199 ----
  	    cs_add_common(dblist[i], pplist[i], fllist[i]);
  	    if (p_csverbose)
  	    {
! 		/* don't use smsg_attr() because we want to display the
  		 * connection number in the same line as
  		 * "Added cscope database..."
  		 */
*** ../vim-7.1.086/src/version.c	Tue Aug 21 17:29:04 2007
--- src/version.c	Tue Aug 21 17:59:42 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     87,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
223. You set up a web-cam as your home's security system.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.088 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.088 (extra)
Problem:    The coordinates used by ":winpos" differ from what getwinposx()
	    and getwinposy() return.
Solution:   Use MoveWindowStructure() instead of MoveWindow(). (Michael Henry)
Files:	    src/gui_mac.c


*** ../vim-7.1.087/src/gui_mac.c	Tue Jun 19 16:33:53 2007
--- src/gui_mac.c	Wed Aug 29 20:33:34 2007
***************
*** 3149,3155 ****
      /* TODO:  Should make sure the window is move within range
       *	      e.g.: y > ~16 [Menu bar], x > 0, x < screen width
       */
!     MoveWindow(gui.VimWindow, x, y, TRUE);
  }
  
      void
--- 3149,3155 ----
      /* TODO:  Should make sure the window is move within range
       *	      e.g.: y > ~16 [Menu bar], x > 0, x < screen width
       */
!     MoveWindowStructure(gui.VimWindow, x, y, TRUE);
  }
  
      void
***************
*** 5556,5562 ****
   * SetDialogTracksCursor() : Get the I-beam cursor over input box
   * MoveDialogItem():	    Probably better than SetDialogItem
   * SizeDialogItem():		(but is it Carbon Only?)
!  * AutoSizeDialog():	    Magic resize of dialog based on text lenght
   */
  }
  #endif /* FEAT_DIALOG_GUI */
--- 5556,5562 ----
   * SetDialogTracksCursor() : Get the I-beam cursor over input box
   * MoveDialogItem():	    Probably better than SetDialogItem
   * SizeDialogItem():		(but is it Carbon Only?)
!  * AutoSizeDialog():	    Magic resize of dialog based on text length
   */
  }
  #endif /* FEAT_DIALOG_GUI */
*** ../vim-7.1.087/src/version.c	Tue Aug 21 18:02:58 2007
--- src/version.c	Thu Aug 30 10:32:28 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     88,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
10E. You start counting in hex.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.089
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.089
Problem:    ":let loaded_getscriptPlugin" doesn't clear to eol, result is
	    "#1in".
Solution:   Clear to the end of the screen after displaying the first variable
	    value.
Files:	    src/eval.c


*** ../vim-7.1.088/src/eval.c	Tue Aug 14 22:40:13 2007
--- src/eval.c	Wed Aug 29 22:40:15 2007
***************
*** 369,385 ****
  static int ex_let_vars __ARGS((char_u *arg, typval_T *tv, int copy, int semicolon, int var_count, char_u *nextchars));
  static char_u *skip_var_list __ARGS((char_u *arg, int *var_count, int *semicolon));
  static char_u *skip_var_one __ARGS((char_u *arg));
! static void list_hashtable_vars __ARGS((hashtab_T *ht, char_u *prefix, int empty));
! static void list_glob_vars __ARGS((void));
! static void list_buf_vars __ARGS((void));
! static void list_win_vars __ARGS((void));
  #ifdef FEAT_WINDOWS
! static void list_tab_vars __ARGS((void));
  #endif
! static void list_vim_vars __ARGS((void));
! static void list_script_vars __ARGS((void));
! static void list_func_vars __ARGS((void));
! static char_u *list_arg_vars __ARGS((exarg_T *eap, char_u *arg));
  static char_u *ex_let_one __ARGS((char_u *arg, typval_T *tv, int copy, char_u *endchars, char_u *op));
  static int check_changedtick __ARGS((char_u *arg));
  static char_u *get_lval __ARGS((char_u *name, typval_T *rettv, lval_T *lp, int unlet, int skip, int quiet, int fne_flags));
--- 369,385 ----
  static int ex_let_vars __ARGS((char_u *arg, typval_T *tv, int copy, int semicolon, int var_count, char_u *nextchars));
  static char_u *skip_var_list __ARGS((char_u *arg, int *var_count, int *semicolon));
  static char_u *skip_var_one __ARGS((char_u *arg));
! static void list_hashtable_vars __ARGS((hashtab_T *ht, char_u *prefix, int empty, int *first));
! static void list_glob_vars __ARGS((int *first));
! static void list_buf_vars __ARGS((int *first));
! static void list_win_vars __ARGS((int *first));
  #ifdef FEAT_WINDOWS
! static void list_tab_vars __ARGS((int *first));
  #endif
! static void list_vim_vars __ARGS((int *first));
! static void list_script_vars __ARGS((int *first));
! static void list_func_vars __ARGS((int *first));
! static char_u *list_arg_vars __ARGS((exarg_T *eap, char_u *arg, int *first));
  static char_u *ex_let_one __ARGS((char_u *arg, typval_T *tv, int copy, char_u *endchars, char_u *op));
  static int check_changedtick __ARGS((char_u *arg));
  static char_u *get_lval __ARGS((char_u *name, typval_T *rettv, lval_T *lp, int unlet, int skip, int quiet, int fne_flags));
***************
*** 704,711 ****
  static hashtab_T *find_var_ht __ARGS((char_u *name, char_u **varname));
  static void vars_clear_ext __ARGS((hashtab_T *ht, int free_val));
  static void delete_var __ARGS((hashtab_T *ht, hashitem_T *hi));
! static void list_one_var __ARGS((dictitem_T *v, char_u *prefix));
! static void list_one_var_a __ARGS((char_u *prefix, char_u *name, int type, char_u *string));
  static void set_var __ARGS((char_u *name, typval_T *varp, int copy));
  static int var_check_ro __ARGS((int flags, char_u *name));
  static int var_check_fixed __ARGS((int flags, char_u *name));
--- 704,711 ----
  static hashtab_T *find_var_ht __ARGS((char_u *name, char_u **varname));
  static void vars_clear_ext __ARGS((hashtab_T *ht, int free_val));
  static void delete_var __ARGS((hashtab_T *ht, hashitem_T *hi));
! static void list_one_var __ARGS((dictitem_T *v, char_u *prefix, int *first));
! static void list_one_var_a __ARGS((char_u *prefix, char_u *name, int type, char_u *string, int *first));
  static void set_var __ARGS((char_u *name, typval_T *varp, int copy));
  static int var_check_ro __ARGS((int flags, char_u *name));
  static int var_check_fixed __ARGS((int flags, char_u *name));
***************
*** 1699,1704 ****
--- 1699,1705 ----
      int		semicolon = 0;
      char_u	op[2];
      char_u	*argend;
+     int		first = TRUE;
  
      argend = skip_var_list(arg, &var_count, &semicolon);
      if (argend == NULL)
***************
*** 1715,1733 ****
  	    EMSG(_(e_invarg));
  	else if (!ends_excmd(*arg))
  	    /* ":let var1 var2" */
! 	    arg = list_arg_vars(eap, arg);
  	else if (!eap->skip)
  	{
  	    /* ":let" */
! 	    list_glob_vars();
! 	    list_buf_vars();
! 	    list_win_vars();
  #ifdef FEAT_WINDOWS
! 	    list_tab_vars();
  #endif
! 	    list_script_vars();
! 	    list_func_vars();
! 	    list_vim_vars();
  	}
  	eap->nextcmd = check_nextcmd(arg);
      }
--- 1716,1734 ----
  	    EMSG(_(e_invarg));
  	else if (!ends_excmd(*arg))
  	    /* ":let var1 var2" */
! 	    arg = list_arg_vars(eap, arg, &first);
  	else if (!eap->skip)
  	{
  	    /* ":let" */
! 	    list_glob_vars(&first);
! 	    list_buf_vars(&first);
! 	    list_win_vars(&first);
  #ifdef FEAT_WINDOWS
! 	    list_tab_vars(&first);
  #endif
! 	    list_script_vars(&first);
! 	    list_func_vars(&first);
! 	    list_vim_vars(&first);
  	}
  	eap->nextcmd = check_nextcmd(arg);
      }
***************
*** 1932,1941 ****
   * If "empty" is TRUE also list NULL strings as empty strings.
   */
      static void
! list_hashtable_vars(ht, prefix, empty)
      hashtab_T	*ht;
      char_u	*prefix;
      int		empty;
  {
      hashitem_T	*hi;
      dictitem_T	*di;
--- 1933,1943 ----
   * If "empty" is TRUE also list NULL strings as empty strings.
   */
      static void
! list_hashtable_vars(ht, prefix, empty, first)
      hashtab_T	*ht;
      char_u	*prefix;
      int		empty;
+     int		*first;
  {
      hashitem_T	*hi;
      dictitem_T	*di;
***************
*** 1950,1956 ****
  	    di = HI2DI(hi);
  	    if (empty || di->di_tv.v_type != VAR_STRING
  					   || di->di_tv.vval.v_string != NULL)
! 		list_one_var(di, prefix);
  	}
      }
  }
--- 1952,1958 ----
  	    di = HI2DI(hi);
  	    if (empty || di->di_tv.v_type != VAR_STRING
  					   || di->di_tv.vval.v_string != NULL)
! 		list_one_var(di, prefix, first);
  	}
      }
  }
***************
*** 1959,1990 ****
   * List global variables.
   */
      static void
! list_glob_vars()
  {
!     list_hashtable_vars(&globvarht, (char_u *)"", TRUE);
  }
  
  /*
   * List buffer variables.
   */
      static void
! list_buf_vars()
  {
      char_u	numbuf[NUMBUFLEN];
  
!     list_hashtable_vars(&curbuf->b_vars.dv_hashtab, (char_u *)"b:", TRUE);
  
      sprintf((char *)numbuf, "%ld", (long)curbuf->b_changedtick);
!     list_one_var_a((char_u *)"b:", (char_u *)"changedtick", VAR_NUMBER, numbuf);
  }
  
  /*
   * List window variables.
   */
      static void
! list_win_vars()
  {
!     list_hashtable_vars(&curwin->w_vars.dv_hashtab, (char_u *)"w:", TRUE);
  }
  
  #ifdef FEAT_WINDOWS
--- 1961,1998 ----
   * List global variables.
   */
      static void
! list_glob_vars(first)
!     int *first;
  {
!     list_hashtable_vars(&globvarht, (char_u *)"", TRUE, first);
  }
  
  /*
   * List buffer variables.
   */
      static void
! list_buf_vars(first)
!     int *first;
  {
      char_u	numbuf[NUMBUFLEN];
  
!     list_hashtable_vars(&curbuf->b_vars.dv_hashtab, (char_u *)"b:",
! 								 TRUE, first);
  
      sprintf((char *)numbuf, "%ld", (long)curbuf->b_changedtick);
!     list_one_var_a((char_u *)"b:", (char_u *)"changedtick", VAR_NUMBER,
! 							       numbuf, first);
  }
  
  /*
   * List window variables.
   */
      static void
! list_win_vars(first)
!     int *first;
  {
!     list_hashtable_vars(&curwin->w_vars.dv_hashtab,
! 						 (char_u *)"w:", TRUE, first);
  }
  
  #ifdef FEAT_WINDOWS
***************
*** 1992,2000 ****
   * List tab page variables.
   */
      static void
! list_tab_vars()
  {
!     list_hashtable_vars(&curtab->tp_vars.dv_hashtab, (char_u *)"t:", TRUE);
  }
  #endif
  
--- 2000,2010 ----
   * List tab page variables.
   */
      static void
! list_tab_vars(first)
!     int *first;
  {
!     list_hashtable_vars(&curtab->tp_vars.dv_hashtab,
! 						 (char_u *)"t:", TRUE, first);
  }
  #endif
  
***************
*** 2002,2040 ****
   * List Vim variables.
   */
      static void
! list_vim_vars()
  {
!     list_hashtable_vars(&vimvarht, (char_u *)"v:", FALSE);
  }
  
  /*
   * List script-local variables, if there is a script.
   */
      static void
! list_script_vars()
  {
      if (current_SID > 0 && current_SID <= ga_scripts.ga_len)
! 	list_hashtable_vars(&SCRIPT_VARS(current_SID), (char_u *)"s:", FALSE);
  }
  
  /*
   * List function variables, if there is a function.
   */
      static void
! list_func_vars()
  {
      if (current_funccal != NULL)
  	list_hashtable_vars(&current_funccal->l_vars.dv_hashtab,
! 						       (char_u *)"l:", FALSE);
  }
  
  /*
   * List variables in "arg".
   */
      static char_u *
! list_arg_vars(eap, arg)
      exarg_T	*eap;
      char_u	*arg;
  {
      int		error = FALSE;
      int		len;
--- 2012,2055 ----
   * List Vim variables.
   */
      static void
! list_vim_vars(first)
!     int *first;
  {
!     list_hashtable_vars(&vimvarht, (char_u *)"v:", FALSE, first);
  }
  
  /*
   * List script-local variables, if there is a script.
   */
      static void
! list_script_vars(first)
!     int *first;
  {
      if (current_SID > 0 && current_SID <= ga_scripts.ga_len)
! 	list_hashtable_vars(&SCRIPT_VARS(current_SID),
! 						(char_u *)"s:", FALSE, first);
  }
  
  /*
   * List function variables, if there is a function.
   */
      static void
! list_func_vars(first)
!     int *first;
  {
      if (current_funccal != NULL)
  	list_hashtable_vars(&current_funccal->l_vars.dv_hashtab,
! 						(char_u *)"l:", FALSE, first);
  }
  
  /*
   * List variables in "arg".
   */
      static char_u *
! list_arg_vars(eap, arg, first)
      exarg_T	*eap;
      char_u	*arg;
+     int		*first;
  {
      int		error = FALSE;
      int		len;
***************
*** 2091,2105 ****
  			{
  			    switch (*name)
  			    {
! 				case 'g': list_glob_vars(); break;
! 				case 'b': list_buf_vars(); break;
! 				case 'w': list_win_vars(); break;
  #ifdef FEAT_WINDOWS
! 				case 't': list_tab_vars(); break;
  #endif
! 				case 'v': list_vim_vars(); break;
! 				case 's': list_script_vars(); break;
! 				case 'l': list_func_vars(); break;
  				default:
  					  EMSG2(_("E738: Can't list variables for %s"), name);
  			    }
--- 2106,2120 ----
  			{
  			    switch (*name)
  			    {
! 				case 'g': list_glob_vars(first); break;
! 				case 'b': list_buf_vars(first); break;
! 				case 'w': list_win_vars(first); break;
  #ifdef FEAT_WINDOWS
! 				case 't': list_tab_vars(first); break;
  #endif
! 				case 'v': list_vim_vars(first); break;
! 				case 's': list_script_vars(first); break;
! 				case 'l': list_func_vars(first); break;
  				default:
  					  EMSG2(_("E738: Can't list variables for %s"), name);
  			    }
***************
*** 2116,2122 ****
  			    *arg = NUL;
  			    list_one_var_a((char_u *)"",
  				    arg == arg_subsc ? name : name_start,
! 				    tv.v_type, s == NULL ? (char_u *)"" : s);
  			    *arg = c;
  			    vim_free(tf);
  			}
--- 2131,2139 ----
  			    *arg = NUL;
  			    list_one_var_a((char_u *)"",
  				    arg == arg_subsc ? name : name_start,
! 				    tv.v_type,
! 				    s == NULL ? (char_u *)"" : s,
! 				    first);
  			    *arg = c;
  			    vim_free(tf);
  			}
***************
*** 18001,18009 ****
   * List the value of one internal variable.
   */
      static void
! list_one_var(v, prefix)
      dictitem_T	*v;
      char_u	*prefix;
  {
      char_u	*tofree;
      char_u	*s;
--- 18024,18033 ----
   * List the value of one internal variable.
   */
      static void
! list_one_var(v, prefix, first)
      dictitem_T	*v;
      char_u	*prefix;
+     int		*first;
  {
      char_u	*tofree;
      char_u	*s;
***************
*** 18011,18026 ****
  
      s = echo_string(&v->di_tv, &tofree, numbuf, ++current_copyID);
      list_one_var_a(prefix, v->di_key, v->di_tv.v_type,
! 						s == NULL ? (char_u *)"" : s);
      vim_free(tofree);
  }
  
      static void
! list_one_var_a(prefix, name, type, string)
      char_u	*prefix;
      char_u	*name;
      int		type;
      char_u	*string;
  {
      /* don't use msg() or msg_attr() to avoid overwriting "v:statusmsg" */
      msg_start();
--- 18035,18051 ----
  
      s = echo_string(&v->di_tv, &tofree, numbuf, ++current_copyID);
      list_one_var_a(prefix, v->di_key, v->di_tv.v_type,
! 					 s == NULL ? (char_u *)"" : s, first);
      vim_free(tofree);
  }
  
      static void
! list_one_var_a(prefix, name, type, string, first)
      char_u	*prefix;
      char_u	*name;
      int		type;
      char_u	*string;
+     int		*first;  /* when TRUE clear rest of screen and set to FALSE */
  {
      /* don't use msg() or msg_attr() to avoid overwriting "v:statusmsg" */
      msg_start();
***************
*** 18052,18057 ****
--- 18077,18087 ----
  
      if (type == VAR_FUNC)
  	msg_puts((char_u *)"()");
+     if (*first)
+     {
+ 	msg_clr_eos();
+ 	*first = FALSE;
+     }
  }
  
  /*
*** ../vim-7.1.088/src/version.c	Thu Aug 30 10:34:19 2007
--- src/version.c	Thu Aug 30 11:06:32 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     89,
  /**/

-- 
Edison's greatest achievement came in 1879, when he invented the
electric company.  Edison's design was a brilliant adaptation of the
simple electrical circuit: the electric company sends electricity
through a wire to a customer, then immediately gets the electricity
back through another wire

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.090
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.090
Problem:    Compiler warning on Mac OS X 10.5.
Solution:   Don't redeclare sigaltstack(). (Hisashi T Fujinaka)
Files:	    src/os_unix.c


*** ../vim-7.1.089/src/os_unix.c	Sat Aug 11 22:22:56 2007
--- src/os_unix.c	Wed Aug 22 22:28:48 2007
***************
*** 753,759 ****
      if (signal_stack != NULL)
      {
  # ifdef HAVE_SIGALTSTACK
! #  ifdef __APPLE__
  	/* missing prototype.  Adding it to osdef?.h.in doesn't work, because
  	 * "struct sigaltstack" needs to be declared. */
  	extern int sigaltstack __ARGS((const struct sigaltstack *ss, struct sigaltstack *oss));
--- 753,760 ----
      if (signal_stack != NULL)
      {
  # ifdef HAVE_SIGALTSTACK
! #  if defined(__APPLE__) && (!defined(MAC_OS_X_VERSION_MAX_ALLOWED) \
! 		|| MAC_OS_X_VERSION_MAX_ALLOWED <= 1040)
  	/* missing prototype.  Adding it to osdef?.h.in doesn't work, because
  	 * "struct sigaltstack" needs to be declared. */
  	extern int sigaltstack __ARGS((const struct sigaltstack *ss, struct sigaltstack *oss));
***************
*** 5688,5694 ****
  
  /*
   * Closes connection to gpm
!  * returns non-zero if connection succesfully closed
   */
      static void
  gpm_close()
--- 5689,5695 ----
  
  /*
   * Closes connection to gpm
!  * returns non-zero if connection successfully closed
   */
      static void
  gpm_close()
*** ../vim-7.1.089/src/version.c	Thu Aug 30 11:10:38 2007
--- src/version.c	Thu Aug 30 11:46:07 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     90,
  /**/

-- 
       We're knights of the round table
       We dance whene'er we're able
       We do routines and chorus scenes
       With footwork impeccable.
       We dine well here in Camelot
       We eat ham and jam and spam a lot.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.091 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.091 (extra)
Problem:    Win32: Can't embed Vim inside another application.
Solution:   Add the --windowid argument. (Nageshwar)
Files:	    runtime/doc/gui_w32.txt, runtime/doc/starting.txt,
	    runtime/doc/vi_diff.txt, src/globals.h, src/gui_w32.c, src/main.c


*** ../vim-7.1.090/runtime/doc/gui_w32.txt	Sat May 12 15:35:53 2007
--- runtime/doc/gui_w32.txt	Tue Aug 14 17:32:27 2007
***************
*** 1,4 ****
! *gui_w32.txt*   For Vim version 7.1.  Last change: 2007 May 03
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
--- 1,4 ----
! *gui_w32.txt*   For Vim version 7.1.  Last change: 2007 Aug 14
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
***************
*** 52,57 ****
--- 52,67 ----
  								*gui-w32s*
  There is a specific version of gvim.exe that runs under the Win32s subsystem
  of Windows 3.1 or 3.11.  See |win32s|.
+ 
+ 
+ Using Vim as a plugin					*gui-w32-windowid*
+ 
+ When gvim starts up normally, it creates its own top level window.  If you
+ pass Vim the command-line option |--windowid| with a decimal or hexadecimal
+ value, Vim will create a window that is a child of the window with the given
+ ID.  This enables Vim to act as a plugin in another application.  This really
+ is a programmer's interface, and is of no use without a supporting application
+ to spawn Vim correctly.
  
  ==============================================================================
  2. Vim as default editor				*vim-default-editor*
*** ../vim-7.1.090/runtime/doc/starting.txt	Sat May 12 16:56:17 2007
--- runtime/doc/starting.txt	Tue Aug 14 17:34:22 2007
***************
*** 1,4 ****
! *starting.txt*  For Vim version 7.1.  Last change: 2007 May 12
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
--- 1,4 ----
! *starting.txt*  For Vim version 7.1.  Last change: 2007 Aug 14
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
***************
*** 547,552 ****
--- 547,557 ----
  		GTK+ GUI Vim only.  Make gvim try to use GtkPlug mechanism, so
  		that it runs inside another window.  See |gui-gtk-socketid|
  		for details. {not in Vi}
+ 
+ --windowid {id}						*--windowid*
+ 		Win32 GUI Vim only.  Make gvim try to use the window {id} as a
+ 		parent, so that it runs inside that window.  See
+ 		|gui-w32-windowid| for details. {not in Vi}
  
  --echo-wid						*--echo-wid*
  		GTK+ GUI Vim only.  Make gvim echo the Window ID on stdout,
*** ../vim-7.1.090/runtime/doc/vi_diff.txt	Sat May 12 14:54:28 2007
--- runtime/doc/vi_diff.txt	Tue Aug 14 17:35:10 2007
***************
*** 1,4 ****
! *vi_diff.txt*   For Vim version 7.1.  Last change: 2007 May 07
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
--- 1,4 ----
! *vi_diff.txt*   For Vim version 7.1.  Last change: 2007 Aug 14
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
***************
*** 826,831 ****
--- 826,833 ----
  --servername {name}	Vim: Specify Vim server name
  
  --socketid {id}		Vim: GTK window socket to run Vim in
+ 
+ --windowid {id}		Vim: Win32 window ID to run Vim in
  
  --version	Vim: show version message and exit.
  
*** ../vim-7.1.090/src/globals.h	Thu May 10 19:26:02 2007
--- src/globals.h	Wed Aug 29 22:27:45 2007
***************
*** 876,882 ****
  EXTERN int no_mapping INIT(= FALSE);	/* currently no mapping allowed */
  EXTERN int no_zero_mapping INIT(= 0);	/* mapping zero not allowed */
  EXTERN int allow_keys INIT(= FALSE);	/* allow key codes when no_mapping
! 					     * is set */
  EXTERN int no_u_sync INIT(= 0);		/* Don't call u_sync() */
  
  EXTERN int restart_edit INIT(= 0);	/* call edit when next cmd finished */
--- 876,882 ----
  EXTERN int no_mapping INIT(= FALSE);	/* currently no mapping allowed */
  EXTERN int no_zero_mapping INIT(= 0);	/* mapping zero not allowed */
  EXTERN int allow_keys INIT(= FALSE);	/* allow key codes when no_mapping
! 					 * is set */
  EXTERN int no_u_sync INIT(= 0);		/* Don't call u_sync() */
  
  EXTERN int restart_edit INIT(= 0);	/* call edit when next cmd finished */
***************
*** 1250,1255 ****
--- 1250,1263 ----
  #ifdef FEAT_GUI_GTK
  EXTERN guint32	gtk_socket_id INIT(= 0);
  EXTERN int	echo_wid_arg INIT(= FALSE);	/* --echo-wid argument */
+ #endif
+ 
+ #ifdef FEAT_GUI_W32
+ /*
+  * The value of the --windowid argument.
+  * For embedding gvim inside another application.
+  */
+ EXTERN int	win_socket_id INIT(= 0);
  #endif
  
  #if defined(FEAT_CLIENTSERVER) || defined(FEAT_EVAL)
*** ../vim-7.1.090/src/gui_w32.c	Tue Aug 14 16:57:04 2007
--- src/gui_w32.c	Tue Aug 14 17:13:41 2007
***************
*** 23,28 ****
--- 23,30 ----
   * e.g., replace LONG with LONG_PTR, etc.
   */
  
+ #include "vim.h"
+ 
  /*
   * These are new in Windows ME/XP, only defined in recent compilers.
   */
***************
*** 1432,1447 ****
  	}
      }
      else
! 	/* Open toplevel window. */
  	s_hwnd = CreateWindow(
! 	    szVimWndClass, "Vim MSWindows GUI",
! 	    WS_OVERLAPPEDWINDOW,
! 	    gui_win_x == -1 ? CW_USEDEFAULT : gui_win_x,
! 	    gui_win_y == -1 ? CW_USEDEFAULT : gui_win_y,
! 	    100,				/* Any value will do */
! 	    100,				/* Any value will do */
! 	    NULL, NULL,
! 	    s_hinst, NULL);
  
      if (s_hwnd == NULL)
  	return FAIL;
--- 1434,1462 ----
  	}
      }
      else
!     {
! 	/* If the provided windowid is not valid reset it to zero, so that it
! 	 * is ignored and we open our own window. */
! 	if (IsWindow((HWND)win_socket_id) <= 0)
! 	    win_socket_id = 0;
! 
! 	/* Create a window.  If win_socket_id is not zero without border and
! 	 * titlebar, it will be reparented below. */
  	s_hwnd = CreateWindow(
! 		szVimWndClass, "Vim MSWindows GUI",
! 		win_socket_id == 0 ? WS_OVERLAPPEDWINDOW : WS_POPUP,
! 		gui_win_x == -1 ? CW_USEDEFAULT : gui_win_x,
! 		gui_win_y == -1 ? CW_USEDEFAULT : gui_win_y,
! 		100,				/* Any value will do */
! 		100,				/* Any value will do */
! 		NULL, NULL,
! 		s_hinst, NULL);
! 	if (s_hwnd != NULL && win_socket_id != 0)
! 	{
! 	    SetParent(s_hwnd, (HWND)win_socket_id);
! 	    ShowWindow(s_hwnd, SW_SHOWMAXIMIZED);
! 	}
!     }
  
      if (s_hwnd == NULL)
  	return FAIL;
*** ../vim-7.1.090/src/main.c	Fri Aug 10 21:32:41 2007
--- src/main.c	Tue Aug 14 17:22:52 2007
***************
*** 275,280 ****
--- 275,281 ----
       *   -display or --display
       *   --server...
       *   --socketid
+      *   --windowid
       */
      early_arg_scan(&params);
  
***************
*** 1489,1495 ****
   * Get the name of the display, before gui_prepare() removes it from
   * argv[].  Used for the xterm-clipboard display.
   *
!  * Also find the --server... arguments and --socketid
   */
  /*ARGSUSED*/
      static void
--- 1490,1496 ----
   * Get the name of the display, before gui_prepare() removes it from
   * argv[].  Used for the xterm-clipboard display.
   *
!  * Also find the --server... arguments and --socketid and --windowid
   */
  /*ARGSUSED*/
      static void
***************
*** 1536,1559 ****
  #  endif
  	}
  # endif
! # ifdef FEAT_GUI_GTK
  	else if (STRICMP(argv[i], "--socketid") == 0)
  	{
! 	    unsigned int    socket_id;
  	    int		    count;
  
  	    if (i == argc - 1)
  		mainerr_arg_missing((char_u *)argv[i]);
  	    if (STRNICMP(argv[i+1], "0x", 2) == 0)
! 		count = sscanf(&(argv[i + 1][2]), "%x", &socket_id);
  	    else
! 		count = sscanf(argv[i+1], "%u", &socket_id);
  	    if (count != 1)
  		mainerr(ME_INVALID_ARG, (char_u *)argv[i]);
  	    else
! 		gtk_socket_id = socket_id;
  	    i++;
  	}
  	else if (STRICMP(argv[i], "--echo-wid") == 0)
  	    echo_wid_arg = TRUE;
  # endif
--- 1537,1571 ----
  #  endif
  	}
  # endif
! 
! # if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_W32)
! #  ifdef FEAT_GUI_W32
! 	else if (STRICMP(argv[i], "--windowid") == 0)
! #  else
  	else if (STRICMP(argv[i], "--socketid") == 0)
+ #  endif
  	{
! 	    unsigned int    id;
  	    int		    count;
  
  	    if (i == argc - 1)
  		mainerr_arg_missing((char_u *)argv[i]);
  	    if (STRNICMP(argv[i+1], "0x", 2) == 0)
! 		count = sscanf(&(argv[i + 1][2]), "%x", &id);
  	    else
! 		count = sscanf(argv[i+1], "%u", &id);
  	    if (count != 1)
  		mainerr(ME_INVALID_ARG, (char_u *)argv[i]);
  	    else
! #  ifdef FEAT_GUI_W32
! 		win_socket_id = id;
! #  else
! 		gtk_socket_id = id;
! #  endif
  	    i++;
  	}
+ # endif
+ # ifdef FEAT_GUI_GTK
  	else if (STRICMP(argv[i], "--echo-wid") == 0)
  	    echo_wid_arg = TRUE;
  # endif
***************
*** 1683,1690 ****
  		    }
  		}
  #endif
! #ifdef FEAT_GUI_GTK
  		else if (STRNICMP(argv[0] + argv_idx, "socketid", 8) == 0)
  		{
  		    /* already processed -- snatch the following arg */
  		    if (argc > 1)
--- 1695,1706 ----
  		    }
  		}
  #endif
! #if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_W32)
! # ifdef FEAT_GUI_GTK
  		else if (STRNICMP(argv[0] + argv_idx, "socketid", 8) == 0)
+ # else
+ 		else if (STRNICMP(argv[0] + argv_idx, "windowid", 8) == 0)
+ # endif
  		{
  		    /* already processed -- snatch the following arg */
  		    if (argc > 1)
***************
*** 1693,1698 ****
--- 1709,1716 ----
  			++argv;
  		    }
  		}
+ #endif
+ #ifdef FEAT_GUI_GTK
  		else if (STRNICMP(argv[0] + argv_idx, "echo-wid", 8) == 0)
  		{
  		    /* already processed, skip */
***************
*** 3120,3125 ****
--- 3138,3144 ----
  #endif
  #ifdef FEAT_GUI_W32
      main_msg(_("-P <parent title>\tOpen Vim inside parent application"));
+     main_msg(_("--windowid <HWND>\tOpen Vim inside another win32 widget"));
  #endif
  
  #ifdef FEAT_GUI_GNOME
*** ../vim-7.1.090/src/version.c	Thu Aug 30 11:46:46 2007
--- src/version.c	Thu Aug 30 12:21:02 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     91,
  /**/

-- 
       We're knights of the Round Table
       Our shows are formidable
       But many times
       We're given rhymes
       That are quite unsingable
       We're opera mad in Camelot
       We sing from the diaphragm a lot.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.092 (extra)
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.092 (extra, after 7.1.088)
Problem:    Wrong arguments for MoveWindowStructure().
Solution:   Remove "TRUE". (Michael Henry)
Files:	    src/gui_mac.c


*** ../vim-7.1.091/src/gui_mac.c	Thu Aug 30 10:34:19 2007
--- src/gui_mac.c	Thu Aug 30 12:48:41 2007
***************
*** 3149,3155 ****
      /* TODO:  Should make sure the window is move within range
       *	      e.g.: y > ~16 [Menu bar], x > 0, x < screen width
       */
!     MoveWindowStructure(gui.VimWindow, x, y, TRUE);
  }
  
      void
--- 3149,3155 ----
      /* TODO:  Should make sure the window is move within range
       *	      e.g.: y > ~16 [Menu bar], x > 0, x < screen width
       */
!     MoveWindowStructure(gui.VimWindow, x, y);
  }
  
      void
***************
*** 5293,5299 ****
      short	itemType;
      short	useIcon;
      short	width;
!     short	totalButtonWidth = 0;   /* the width of all button together
  					   including spacing */
      short	widestButton = 0;
      short	dfltButtonEdge     = 20;  /* gut feeling */
--- 5293,5299 ----
      short	itemType;
      short	useIcon;
      short	width;
!     short	totalButtonWidth = 0;   /* the width of all buttons together
  					   including spacing */
      short	widestButton = 0;
      short	dfltButtonEdge     = 20;  /* gut feeling */
***************
*** 5483,5489 ****
      {
  
  	macMoveDialogItem(theDialog, button, buttonItm.box.left, buttonItm.box.top, &box);
! 	/* With vertical, it's better to have all button the same lenght */
  	if (vertical)
  	{
  	    macSizeDialogItem(theDialog, button, widestButton, 0);
--- 5483,5489 ----
      {
  
  	macMoveDialogItem(theDialog, button, buttonItm.box.left, buttonItm.box.top, &box);
! 	/* With vertical, it's better to have all buttons the same length */
  	if (vertical)
  	{
  	    macSizeDialogItem(theDialog, button, widestButton, 0);
*** ../vim-7.1.091/src/version.c	Thu Aug 30 12:24:21 2007
--- src/version.c	Thu Aug 30 12:47:24 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     92,
  /**/

-- 
       In war we're tough and able.
       Quite indefatigable
       Between our quests
       We sequin vests
       And impersonate Clark Gable
       It's a busy life in Camelot.
       I have to push the pram a lot.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.093
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.093
Problem:    Reading past end of a screen line when determining cell width.
	    (Dominique Pelle)
Solution:   Add an argument to mb_off2cells() for the maximum offset.
Files:	    src/globals.h, src/gui.c, src/mbyte.c, src/proto/mbyte.pro,
	    src/screen.c


*** ../vim-7.1.092/src/globals.h	Thu Aug 30 12:24:21 2007
--- src/globals.h	Wed Aug 29 22:27:45 2007
***************
*** 801,807 ****
  EXTERN int (*mb_char2bytes) __ARGS((int c, char_u *buf)) INIT(= latin_char2bytes);
  EXTERN int (*mb_ptr2cells) __ARGS((char_u *p)) INIT(= latin_ptr2cells);
  EXTERN int (*mb_char2cells) __ARGS((int c)) INIT(= latin_char2cells);
! EXTERN int (*mb_off2cells) __ARGS((unsigned off)) INIT(= latin_off2cells);
  EXTERN int (*mb_ptr2char) __ARGS((char_u *p)) INIT(= latin_ptr2char);
  EXTERN int (*mb_head_off) __ARGS((char_u *base, char_u *p)) INIT(= latin_head_off);
  
--- 801,807 ----
  EXTERN int (*mb_char2bytes) __ARGS((int c, char_u *buf)) INIT(= latin_char2bytes);
  EXTERN int (*mb_ptr2cells) __ARGS((char_u *p)) INIT(= latin_ptr2cells);
  EXTERN int (*mb_char2cells) __ARGS((int c)) INIT(= latin_char2cells);
! EXTERN int (*mb_off2cells) __ARGS((unsigned off, unsigned max_off)) INIT(= latin_off2cells);
  EXTERN int (*mb_ptr2char) __ARGS((char_u *p)) INIT(= latin_ptr2char);
  EXTERN int (*mb_head_off) __ARGS((char_u *base, char_u *p)) INIT(= latin_head_off);
  
*** ../vim-7.1.092/src/gui.c	Wed Aug 15 20:07:53 2007
--- src/gui.c	Wed Aug 29 22:16:51 2007
***************
*** 1080,1086 ****
  		cur_width = gui.char_width;
  	    }
  #ifdef FEAT_MBYTE
! 	    if (has_mbyte && (*mb_off2cells)(LineOffset[gui.row] + gui.col) > 1)
  	    {
  		/* Double wide character. */
  		if (shape_table[idx].shape != SHAPE_VER)
--- 1080,1087 ----
  		cur_width = gui.char_width;
  	    }
  #ifdef FEAT_MBYTE
! 	    if (has_mbyte && (*mb_off2cells)(LineOffset[gui.row] + gui.col,
! 				    LineOffset[gui.row] + screen_Columns) > 1)
  	    {
  		/* Double wide character. */
  		if (shape_table[idx].shape != SHAPE_VER)
***************
*** 1159,1165 ****
  #endif
  
  # if defined(FEAT_GUI_TABLINE) && (defined(FEAT_GUI_MSWIN) \
!  	|| defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_MAC))
      if (gui_has_tabline())
  	text_area_y += gui.tabline_height;
  #endif
--- 1160,1166 ----
  #endif
  
  # if defined(FEAT_GUI_TABLINE) && (defined(FEAT_GUI_MSWIN) \
! 	|| defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_MAC))
      if (gui_has_tabline())
  	text_area_y += gui.tabline_height;
  #endif
*** ../vim-7.1.092/src/mbyte.c	Sat Aug 11 13:57:31 2007
--- src/mbyte.c	Thu Aug 30 13:48:30 2007
***************
*** 1310,1329 ****
  /*
   * mb_off2cells() function pointer.
   * Return number of display cells for char at ScreenLines[off].
!  * Caller must make sure "off" and "off + 1" are valid!
   */
  /*ARGSUSED*/
      int
! latin_off2cells(off)
      unsigned	off;
  {
      return 1;
  }
  
      int
! dbcs_off2cells(off)
      unsigned	off;
  {
      /* Number of cells is equal to number of bytes, except for euc-jp when
       * the first byte is 0x8e. */
      if (enc_dbcs == DBCS_JPNU && ScreenLines[off] == 0x8e)
--- 1310,1335 ----
  /*
   * mb_off2cells() function pointer.
   * Return number of display cells for char at ScreenLines[off].
!  * We make sure that the offset used is less than "max_off".
   */
  /*ARGSUSED*/
      int
! latin_off2cells(off, max_off)
      unsigned	off;
+     unsigned	max_off;
  {
      return 1;
  }
  
      int
! dbcs_off2cells(off, max_off)
      unsigned	off;
+     unsigned	max_off;
  {
+     /* never check beyond end of the line */
+     if (off >= max_off)
+ 	return 1;
+ 
      /* Number of cells is equal to number of bytes, except for euc-jp when
       * the first byte is 0x8e. */
      if (enc_dbcs == DBCS_JPNU && ScreenLines[off] == 0x8e)
***************
*** 1332,1341 ****
  }
  
      int
! utf_off2cells(off)
      unsigned	off;
  {
!     return ScreenLines[off + 1] == 0 ? 2 : 1;
  }
  
  /*
--- 1338,1348 ----
  }
  
      int
! utf_off2cells(off, max_off)
      unsigned	off;
+     unsigned	max_off;
  {
!     return (off + 1 < max_off && ScreenLines[off + 1] == 0) ? 2 : 1;
  }
  
  /*
***************
*** 2899,2910 ****
      if (composing_hangul)
  	return TRUE;
  #endif
!     if (enc_dbcs != 0)
! 	return dbcs_off2cells(LineOffset[row] + col) > 1;
!     if (enc_utf8)
! 	return (col + 1 < Columns
! 		&& ScreenLines[LineOffset[row] + col + 1] == 0);
!     return FALSE;
  }
  
  # if defined(FEAT_CLIPBOARD) || defined(FEAT_GUI) || defined(FEAT_RIGHTLEFT) \
--- 2906,2913 ----
      if (composing_hangul)
  	return TRUE;
  #endif
!     return (*mb_off2cells)(LineOffset[row] + col,
! 					LineOffset[row] + screen_Columns) > 1;
  }
  
  # if defined(FEAT_CLIPBOARD) || defined(FEAT_GUI) || defined(FEAT_RIGHTLEFT) \
*** ../vim-7.1.092/src/proto/mbyte.pro	Sat May  5 20:02:52 2007
--- src/proto/mbyte.pro	Wed Aug 29 20:49:02 2007
***************
*** 12,20 ****
  int utf_ptr2cells __ARGS((char_u *p));
  int dbcs_ptr2cells __ARGS((char_u *p));
  int latin_char2cells __ARGS((int c));
! int latin_off2cells __ARGS((unsigned off));
! int dbcs_off2cells __ARGS((unsigned off));
! int utf_off2cells __ARGS((unsigned off));
  int latin_ptr2char __ARGS((char_u *p));
  int utf_ptr2char __ARGS((char_u *p));
  int mb_ptr2char_adv __ARGS((char_u **pp));
--- 12,20 ----
  int utf_ptr2cells __ARGS((char_u *p));
  int dbcs_ptr2cells __ARGS((char_u *p));
  int latin_char2cells __ARGS((int c));
! int latin_off2cells __ARGS((unsigned off, unsigned max_off));
! int dbcs_off2cells __ARGS((unsigned off, unsigned max_off));
! int utf_off2cells __ARGS((unsigned off, unsigned max_off));
  int latin_ptr2char __ARGS((char_u *p));
  int utf_ptr2char __ARGS((char_u *p));
  int mb_ptr2char_adv __ARGS((char_u **pp));
*** ../vim-7.1.092/src/screen.c	Sun Aug  5 20:10:16 2007
--- src/screen.c	Thu Aug 30 10:31:26 2007
***************
*** 1024,1030 ****
  	    type = VALID;
      }
  
!     /* Trick: we want to avoid clearning the screen twice.  screenclear() will
       * set "screen_cleared" to TRUE.  The special value MAYBE (which is still
       * non-zero and thus not FALSE) will indicate that screenclear() was not
       * called. */
--- 1024,1030 ----
  	    type = VALID;
      }
  
!     /* Trick: we want to avoid clearing the screen twice.  screenclear() will
       * set "screen_cleared" to TRUE.  The special value MAYBE (which is still
       * non-zero and thus not FALSE) will indicate that screenclear() was not
       * called. */
***************
*** 4632,4638 ****
  
  	/*
  	 * At end of screen line and there is more to come: Display the line
! 	 * so far.  If there is no more to display it is catched above.
  	 */
  	if ((
  #ifdef FEAT_RIGHTLEFT
--- 4632,4638 ----
  
  	/*
  	 * At end of screen line and there is more to come: Display the line
! 	 * so far.  If there is no more to display it is caught above.
  	 */
  	if ((
  #ifdef FEAT_RIGHTLEFT
***************
*** 4709,4717 ****
  #endif
  #ifdef FEAT_MBYTE
  			 && !(has_mbyte
! 			     && ((*mb_off2cells)(LineOffset[screen_row]) == 2
  				 || (*mb_off2cells)(LineOffset[screen_row - 1]
! 							+ (int)Columns - 2) == 2))
  #endif
  		   )
  		{
--- 4709,4721 ----
  #endif
  #ifdef FEAT_MBYTE
  			 && !(has_mbyte
! 			     && ((*mb_off2cells)(LineOffset[screen_row],
! 				     LineOffset[screen_row] + screen_Columns)
! 									  == 2
  				 || (*mb_off2cells)(LineOffset[screen_row - 1]
! 							+ (int)Columns - 2,
! 				     LineOffset[screen_row] + screen_Columns)
! 									== 2))
  #endif
  		   )
  		{
***************
*** 4871,4876 ****
--- 4875,4884 ----
  {
      unsigned	    off_from;
      unsigned	    off_to;
+ #ifdef FEAT_MBYTE
+     unsigned	    max_off_from;
+     unsigned	    max_off_to;
+ #endif
      int		    col = 0;
  #if defined(FEAT_GUI) || defined(UNIX) || defined(FEAT_VERTSPLIT)
      int		    hl;
***************
*** 4897,4902 ****
--- 4905,4914 ----
  
      off_from = (unsigned)(current_ScreenLine - ScreenLines);
      off_to = LineOffset[row] + coloff;
+ #ifdef FEAT_MBYTE
+     max_off_from = off_from + screen_Columns;
+     max_off_to = LineOffset[row] + screen_Columns;
+ #endif
  
  #ifdef FEAT_RIGHTLEFT
      if (rlflag)
***************
*** 4931,4937 ****
      {
  #ifdef FEAT_MBYTE
  	if (has_mbyte && (col + 1 < endcol))
! 	    char_cells = (*mb_off2cells)(off_from);
  	else
  	    char_cells = 1;
  #endif
--- 4943,4949 ----
      {
  #ifdef FEAT_MBYTE
  	if (has_mbyte && (col + 1 < endcol))
! 	    char_cells = (*mb_off2cells)(off_from, max_off_from);
  	else
  	    char_cells = 1;
  #endif
***************
*** 5008,5014 ****
  		 * ScreenLinesUC[] is sufficient. */
  		if (char_cells == 1
  			&& col + 1 < endcol
! 			&& (*mb_off2cells)(off_to) > 1)
  		{
  		    /* Writing a single-cell character over a double-cell
  		     * character: need to redraw the next cell. */
--- 5020,5026 ----
  		 * ScreenLinesUC[] is sufficient. */
  		if (char_cells == 1
  			&& col + 1 < endcol
! 			&& (*mb_off2cells)(off_to, max_off_to) > 1)
  		{
  		    /* Writing a single-cell character over a double-cell
  		     * character: need to redraw the next cell. */
***************
*** 5017,5024 ****
  		}
  		else if (char_cells == 2
  			&& col + 2 < endcol
! 			&& (*mb_off2cells)(off_to) == 1
! 			&& (*mb_off2cells)(off_to + 1) > 1)
  		{
  		    /* Writing the second half of a double-cell character over
  		     * a double-cell character: need to redraw the second
--- 5029,5036 ----
  		}
  		else if (char_cells == 2
  			&& col + 2 < endcol
! 			&& (*mb_off2cells)(off_to, max_off_to) == 1
! 			&& (*mb_off2cells)(off_to + 1, max_off_to) > 1)
  		{
  		    /* Writing the second half of a double-cell character over
  		     * a double-cell character: need to redraw the second
***************
*** 5037,5046 ****
  	     * char over the left halve of an existing one. */
  	    if (has_mbyte && col + char_cells == endcol
  		    && ((char_cells == 1
! 			    && (*mb_off2cells)(off_to) > 1)
  			|| (char_cells == 2
! 			    && (*mb_off2cells)(off_to) == 1
! 			    && (*mb_off2cells)(off_to + 1) > 1)))
  		clear_next = TRUE;
  #endif
  
--- 5049,5058 ----
  	     * char over the left halve of an existing one. */
  	    if (has_mbyte && col + char_cells == endcol
  		    && ((char_cells == 1
! 			    && (*mb_off2cells)(off_to, max_off_to) > 1)
  			|| (char_cells == 2
! 			    && (*mb_off2cells)(off_to, max_off_to) == 1
! 			    && (*mb_off2cells)(off_to + 1, max_off_to) > 1)))
  		clear_next = TRUE;
  #endif
  
***************
*** 5180,5189 ****
  			/* find previous character by counting from first
  			 * column and get its width. */
  			unsigned off = LineOffset[row];
  
  			while (off < off_to)
  			{
! 			    prev_cells = (*mb_off2cells)(off);
  			    off += prev_cells;
  			}
  		    }
--- 5192,5202 ----
  			/* find previous character by counting from first
  			 * column and get its width. */
  			unsigned off = LineOffset[row];
+ 			unsigned max_off = LineOffset[row] + screen_Columns;
  
  			while (off < off_to)
  			{
! 			    prev_cells = (*mb_off2cells)(off, max_off);
  			    off += prev_cells;
  			}
  		    }
***************
*** 5369,5375 ****
  static int skip_status_match_char __ARGS((expand_T *xp, char_u *s));
  
  /*
!  * Get the lenght of an item as it will be shown in the status line.
   */
      static int
  status_match_len(xp, s)
--- 5382,5388 ----
  static int skip_status_match_char __ARGS((expand_T *xp, char_u *s));
  
  /*
!  * Get the length of an item as it will be shown in the status line.
   */
      static int
  status_match_len(xp, s)
***************
*** 5435,5441 ****
      int		row;
      char_u	*buf;
      int		len;
!     int		clen;		/* lenght in screen cells */
      int		fillchar;
      int		attr;
      int		i;
--- 5448,5454 ----
      int		row;
      char_u	*buf;
      int		len;
!     int		clen;		/* length in screen cells */
      int		fillchar;
      int		attr;
      int		i;
***************
*** 6187,6192 ****
--- 6200,6206 ----
      char_u	*ptr = text;
      int		c;
  #ifdef FEAT_MBYTE
+     unsigned	max_off;
      int		mbyte_blen = 1;
      int		mbyte_cells = 1;
      int		u8c = 0;
***************
*** 6203,6208 ****
--- 6217,6225 ----
  	return;
  
      off = LineOffset[row] + col;
+ #ifdef FEAT_MBYTE
+     max_off = LineOffset[row] + screen_Columns;
+ #endif
      while (col < screen_Columns
  	    && (len < 0 || (int)(ptr - text) < len)
  	    && *ptr != NUL)
***************
*** 6326,6344 ****
  	    else if (has_mbyte
  		    && (len < 0 ? ptr[mbyte_blen] == NUL
  					     : ptr + mbyte_blen >= text + len)
! 		    && ((mbyte_cells == 1 && (*mb_off2cells)(off) > 1)
  			|| (mbyte_cells == 2
! 			    && (*mb_off2cells)(off) == 1
! 			    && (*mb_off2cells)(off + 1) > 1)))
  		clear_next_cell = TRUE;
  
  	    /* Make sure we never leave a second byte of a double-byte behind,
  	     * it confuses mb_off2cells(). */
  	    if (enc_dbcs
! 		    && ((mbyte_cells == 1 && (*mb_off2cells)(off) > 1)
  			|| (mbyte_cells == 2
! 			    && (*mb_off2cells)(off) == 1
! 			    && (*mb_off2cells)(off + 1) > 1)))
  		ScreenLines[off + mbyte_blen] = 0;
  #endif
  	    ScreenLines[off] = c;
--- 6343,6361 ----
  	    else if (has_mbyte
  		    && (len < 0 ? ptr[mbyte_blen] == NUL
  					     : ptr + mbyte_blen >= text + len)
! 		    && ((mbyte_cells == 1 && (*mb_off2cells)(off, max_off) > 1)
  			|| (mbyte_cells == 2
! 			    && (*mb_off2cells)(off, max_off) == 1
! 			    && (*mb_off2cells)(off + 1, max_off) > 1)))
  		clear_next_cell = TRUE;
  
  	    /* Make sure we never leave a second byte of a double-byte behind,
  	     * it confuses mb_off2cells(). */
  	    if (enc_dbcs
! 		    && ((mbyte_cells == 1 && (*mb_off2cells)(off, max_off) > 1)
  			|| (mbyte_cells == 2
! 			    && (*mb_off2cells)(off, max_off) == 1
! 			    && (*mb_off2cells)(off + 1, max_off) > 1)))
  		ScreenLines[off + mbyte_blen] = 0;
  #endif
  	    ScreenLines[off] = c;
***************
*** 6924,6929 ****
--- 6941,6949 ----
  {
      int		r, c;
      int		off;
+ #ifdef FEAT_MBYTE
+     int		max_off;
+ #endif
  
      /* Can't use ScreenLines unless initialized */
      if (ScreenLines == NULL)
***************
*** 6934,6943 ****
      for (r = row; r < row + height; ++r)
      {
  	off = LineOffset[r];
  	for (c = col; c < col + width; ++c)
  	{
  #ifdef FEAT_MBYTE
! 	    if (enc_dbcs != 0 && dbcs_off2cells(off + c) > 1)
  	    {
  		screen_char_2(off + c, r, c);
  		++c;
--- 6954,6966 ----
      for (r = row; r < row + height; ++r)
      {
  	off = LineOffset[r];
+ #ifdef FEAT_MBYTE
+ 	max_off = off + screen_Columns;
+ #endif
  	for (c = col; c < col + width; ++c)
  	{
  #ifdef FEAT_MBYTE
! 	    if (enc_dbcs != 0 && dbcs_off2cells(off + c, max_off) > 1)
  	    {
  		screen_char_2(off + c, r, c);
  		++c;
***************
*** 6947,6953 ****
  	    {
  		screen_char(off + c, r, c);
  #ifdef FEAT_MBYTE
! 		if (utf_off2cells(off + c) > 1)
  		    ++c;
  #endif
  	    }
--- 6970,6976 ----
  	    {
  		screen_char(off + c, r, c);
  #ifdef FEAT_MBYTE
! 		if (utf_off2cells(off + c, max_off) > 1)
  		    ++c;
  #endif
  	    }
*** ../vim-7.1.092/src/version.c	Thu Aug 30 12:50:00 2007
--- src/version.c	Thu Aug 30 13:45:25 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     93,
  /**/

-- 
There is a fine line between courage and foolishness.
Unfortunately, it's not a fence.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.094
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.094
Problem:    When checking if syntax highlighting is present, looking in the
	    current buffer instead of the specified one.
Solution:   Use "buf" instead of "curbuf".
Files:	    src/syntax.c


*** ../vim-7.1.093/src/syntax.c	Tue Aug 21 17:29:04 2007
--- src/syntax.c	Wed Aug 29 23:27:52 2007
***************
*** 5987,5994 ****
  {
      return (buf->b_syn_patterns.ga_len != 0
  	    || buf->b_syn_clusters.ga_len != 0
! 	    || curbuf->b_keywtab.ht_used > 0
! 	    || curbuf->b_keywtab_ic.ht_used > 0);
  }
  
  #if defined(FEAT_CMDL_COMPL) || defined(PROTO)
--- 5987,5994 ----
  {
      return (buf->b_syn_patterns.ga_len != 0
  	    || buf->b_syn_clusters.ga_len != 0
! 	    || buf->b_keywtab.ht_used > 0
! 	    || buf->b_keywtab_ic.ht_used > 0);
  }
  
  #if defined(FEAT_CMDL_COMPL) || defined(PROTO)
*** ../vim-7.1.093/src/version.c	Thu Aug 30 13:51:52 2007
--- src/version.c	Thu Aug 30 19:35:52 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     94,
  /**/

-- 
MAN:     You don't frighten us, English pig-dog!  Go and boil your bottoms,
         son of a silly person.  I blow my nose on you, so-called Arthur-king,
         you and your silly English K...kaniggets.
   He puts hands to his ears and blows a raspberry.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.095
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.095
Problem:    The FocusLost and FocusGained autocommands are triggered
	    asynchronously in the GUI.  This may cause arbitrary problems.
Solution:   Put the focus event in the input buffer and handle it when ready
	    for it.
Files:	    src/eval.c, src/getchar.c, src/gui.c, src/gui_gtk_x11.c,
	    src/keymap.h


*** ../vim-7.1.094/src/eval.c	Thu Aug 30 11:10:38 2007
--- src/eval.c	Mon Sep  3 22:48:09 2007
***************
*** 9912,9929 ****
  
      ++no_mapping;
      ++allow_keys;
!     if (argvars[0].v_type == VAR_UNKNOWN)
! 	/* getchar(): blocking wait. */
! 	n = safe_vgetc();
!     else if (get_tv_number_chk(&argvars[0], &error) == 1)
! 	/* getchar(1): only check if char avail */
! 	n = vpeekc();
!     else if (error || vpeekc() == NUL)
! 	/* illegal argument or getchar(0) and no char avail: return zero */
! 	n = 0;
!     else
! 	/* getchar(0) and char avail: return char */
! 	n = safe_vgetc();
      --no_mapping;
      --allow_keys;
  
--- 9912,9935 ----
  
      ++no_mapping;
      ++allow_keys;
!     for (;;)
!     {
! 	if (argvars[0].v_type == VAR_UNKNOWN)
! 	    /* getchar(): blocking wait. */
! 	    n = safe_vgetc();
! 	else if (get_tv_number_chk(&argvars[0], &error) == 1)
! 	    /* getchar(1): only check if char avail */
! 	    n = vpeekc();
! 	else if (error || vpeekc() == NUL)
! 	    /* illegal argument or getchar(0) and no char avail: return zero */
! 	    n = 0;
! 	else
! 	    /* getchar(0) and char avail: return char */
! 	    n = safe_vgetc();
! 	if (n == K_IGNORE)
! 	    continue;
! 	break;
!     }
      --no_mapping;
      --allow_keys;
  
*** ../vim-7.1.094/src/getchar.c	Thu May 10 18:43:02 2007
--- src/getchar.c	Wed Aug 29 22:38:49 2007
***************
*** 1596,1603 ****
  		continue;
  	    }
  #endif
- 
  #ifdef FEAT_GUI
  	    /* Translate K_CSI to CSI.  The special key is only used to avoid
  	     * it being recognized as the start of a special key. */
  	    if (c == K_CSI)
--- 1596,1610 ----
  		continue;
  	    }
  #endif
  #ifdef FEAT_GUI
+ 	    /* The caller doesn't need to know that the focus event is delayed
+ 	     * until getting a character. */
+ 	    if (c == K_FOCUSGAINED || c == K_FOCUSLOST)
+ 	    {
+ 		ui_focus_change(c == K_FOCUSGAINED);
+ 		continue;
+ 	    }
+ 
  	    /* Translate K_CSI to CSI.  The special key is only used to avoid
  	     * it being recognized as the start of a special key. */
  	    if (c == K_CSI)
*** ../vim-7.1.094/src/gui.c	Thu Aug 30 13:51:52 2007
--- src/gui.c	Thu Aug 30 14:10:48 2007
***************
*** 4519,4525 ****
      xim_set_focus(in_focus);
  # endif
  
!     ui_focus_change(in_focus);
  #endif
  }
  
--- 4519,4536 ----
      xim_set_focus(in_focus);
  # endif
  
!     /* Put events in the input queue only when allowed.
!      * ui_focus_change() isn't called directly, because it invokes
!      * autocommands and that must not happen asynchronously. */
!     if (!hold_gui_events)
!     {
! 	char_u  bytes[3];
! 
! 	bytes[0] = CSI;
! 	bytes[1] = KS_EXTRA;
! 	bytes[2] = in_focus ? (int)KE_FOCUSGAINED : (int)KE_FOCUSLOST;
! 	add_to_input_buf(bytes, 3);
!     }
  #endif
  }
  
*** ../vim-7.1.094/src/gui_gtk_x11.c	Tue Jun 19 18:07:52 2007
--- src/gui_gtk_x11.c	Wed Aug 29 22:43:34 2007
***************
*** 813,822 ****
      if (blink_state == BLINK_NONE)
  	gui_mch_start_blink();
  
!     /* make sure keyboard input goes to the draw area (if this is focus for a window) */
      if (widget != gui.drawarea)
  	gtk_widget_grab_focus(gui.drawarea);
  
      return TRUE;
  }
  
--- 813,827 ----
      if (blink_state == BLINK_NONE)
  	gui_mch_start_blink();
  
!     /* make sure keyboard input goes to the draw area (if this is focus for a
!      * window) */
      if (widget != gui.drawarea)
  	gtk_widget_grab_focus(gui.drawarea);
  
+     /* make sure the input buffer is read */
+     if (gtk_main_level() > 0)
+ 	gtk_main_quit();
+ 
      return TRUE;
  }
  
***************
*** 828,833 ****
--- 833,842 ----
  
      if (blink_state != BLINK_NONE)
  	gui_mch_stop_blink();
+ 
+     /* make sure the input buffer is read */
+     if (gtk_main_level() > 0)
+ 	gtk_main_quit();
  
      return TRUE;
  }
*** ../vim-7.1.094/src/keymap.h	Sat May  5 19:34:22 2007
--- src/keymap.h	Wed Aug 29 22:17:51 2007
***************
*** 254,259 ****
--- 254,261 ----
      , KE_DROP		/* DnD data is available */
      , KE_CURSORHOLD	/* CursorHold event */
      , KE_NOP		/* doesn't do something */
+     , KE_FOCUSGAINED	/* focus gained */
+     , KE_FOCUSLOST	/* focus lost */
  };
  
  /*
***************
*** 445,450 ****
--- 447,454 ----
  #define K_CMDWIN	TERMCAP2KEY(KS_EXTRA, KE_CMDWIN)
  
  #define K_DROP		TERMCAP2KEY(KS_EXTRA, KE_DROP)
+ #define K_FOCUSGAINED	TERMCAP2KEY(KS_EXTRA, KE_FOCUSGAINED)
+ #define K_FOCUSLOST	TERMCAP2KEY(KS_EXTRA, KE_FOCUSLOST)
  
  #define K_CURSORHOLD	TERMCAP2KEY(KS_EXTRA, KE_CURSORHOLD)
  
*** ../vim-7.1.094/src/version.c	Thu Aug 30 19:36:52 2007
--- src/version.c	Wed Sep  5 21:42:41 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     95,
  /**/

-- 
ARTHUR:      Who are you?
TALL KNIGHT: We are the Knights Who Say "Ni"!
BEDEVERE:    No!  Not the Knights Who Say "Ni"!
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.096
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.096
Problem:    Reading past end of a string when resizing Vim. (Dominique Pelle)
Solution:   Check the string pointer before getting the char it points to.
Files:	    src/message.c


*** ../vim-7.1.095/src/message.c	Tue Aug  7 21:59:26 2007
--- src/message.c	Thu Aug 30 22:53:03 2007
***************
*** 944,949 ****
--- 944,950 ----
  		c = K_IGNORE;
  	    }
  #endif
+ 
  	    /*
  	     * Allow scrolling back in the messages.
  	     * Also accept scroll-down commands when messages fill the screen,
***************
*** 1840,1845 ****
--- 1841,1847 ----
      char_u	*sb_str = str;
      int		sb_col = msg_col;
      int		wrap;
+     int		did_last_char;
  
      did_wait_return = FALSE;
      while ((maxlen < 0 || (int)(s - str) < maxlen) && *s != NUL)
***************
*** 1909,1915 ****
--- 1911,1920 ----
  		else
  #endif
  		    msg_screen_putchar(*s++, attr);
+ 		did_last_char = TRUE;
  	    }
+ 	    else
+ 		did_last_char = FALSE;
  
  	    if (p_more)
  		/* store text for scrolling back */
***************
*** 1944,1954 ****
  
  	    /* When we displayed a char in last column need to check if there
  	     * is still more. */
! 	    if (*s >= ' '
! #ifdef FEAT_RIGHTLEFT
! 		    && !cmdmsg_rl
! #endif
! 	       )
  		continue;
  	}
  
--- 1949,1955 ----
  
  	    /* When we displayed a char in last column need to check if there
  	     * is still more. */
! 	    if (did_last_char)
  		continue;
  	}
  
*** ../vim-7.1.095/src/version.c	Wed Sep  5 21:45:54 2007
--- src/version.c	Thu Sep  6 12:31:28 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     96,
  /**/

-- 
Yah, well, we had to carve our electrons out of driftwood we'd
find.  In the winter.  Uphill.  Both ways.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.097
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.097
Problem:    ":setlocal stl=%!1+1" does not work.
Solution:   Adjust check for pointer. (Politz)
Files:	    src/option.c


*** ../vim-7.1.096/src/option.c	Sun Aug 12 15:50:26 2007
--- src/option.c	Wed Sep  5 22:34:27 2007
***************
*** 6348,6354 ****
  		errmsg = check_stl_option(p_ruf);
  	}
  	/* check 'statusline' only if it doesn't start with "%!" */
! 	else if (varp != &p_stl || s[0] != '%' || s[1] != '!')
  	    errmsg = check_stl_option(s);
  	if (varp == &p_ruf && errmsg == NULL)
  	    comp_col();
--- 6352,6358 ----
  		errmsg = check_stl_option(p_ruf);
  	}
  	/* check 'statusline' only if it doesn't start with "%!" */
! 	else if (varp == &p_ruf || s[0] != '%' || s[1] != '!')
  	    errmsg = check_stl_option(s);
  	if (varp == &p_ruf && errmsg == NULL)
  	    comp_col();
*** ../vim-7.1.096/src/version.c	Thu Sep  6 12:53:59 2007
--- src/version.c	Thu Sep  6 13:31:37 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     97,
  /**/

-- 
Not too long ago, cut and paste was done with scissors and glue...

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.098
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.098
Problem:    ":call s:var()" doesn't work if "s:var" is a Funcref. (Andy Wokula)
Solution:   Before converting "s:" into a script ID, check if it is a Funcref.
Files:	    src/eval.c


*** ../vim-7.1.097/src/eval.c	Wed Sep  5 21:45:54 2007
--- src/eval.c	Thu Sep  6 12:11:19 2007
***************
*** 19367,19372 ****
--- 19367,19394 ----
      if (lv.ll_name == NULL)
      {
  	/* Error found, but continue after the function name. */
+ 	*pp = end;
+ 	goto theend;
+     }
+ 
+     /* Check if the name is a Funcref.  If so, use the value. */
+     if (lv.ll_exp_name != NULL)
+     {
+ 	len = (int)STRLEN(lv.ll_exp_name);
+ 	name = deref_func_name(lv.ll_exp_name, &len);
+ 	if (name == lv.ll_exp_name)
+ 	    name = NULL;
+     }
+     else
+     {
+ 	len = (int)(end - *pp);
+ 	name = deref_func_name(*pp, &len);
+ 	if (name == *pp)
+ 	    name = NULL;
+     }
+     if (name != NULL)
+     {
+ 	name = vim_strsave(name);
  	*pp = end;
  	goto theend;
      }
*** ../vim-7.1.097/src/version.c	Thu Sep  6 13:32:53 2007
--- src/version.c	Thu Sep  6 14:24:10 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     98,
  /**/

-- 
Not too long ago, a program was something you watched on TV...

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.099
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.099
Problem:    When the 'keymap' and 'paste' options have a non-default value,
	    ":mkexrc" and ":mksession" do not correctly set the options.
Solution:   Set the options with side effects before other options.
Files:	    src/option.c

 
*** ../vim-7.1.098/src/option.c	Thu Sep  6 13:32:53 2007
--- src/option.c	Wed Sep  5 22:34:27 2007
***************
*** 427,432 ****
--- 427,434 ----
  #define P_NOGLOB       0x100000L/* do not use local value for global vimrc */
  #define P_NFNAME       0x200000L/* only normal file name chars allowed */
  #define P_INSECURE     0x400000L/* option was set from a modeline */
+ #define P_PRI_MKRC     0x800000L/* priority for :mkvimrc (setting option has
+ 				   side effects) */
  
  #define ISK_LATIN1  (char_u *)"@,48-57,_,192-255"
  
***************
*** 773,778 ****
--- 775,782 ----
  			    {(char_u *)0L, (char_u *)0L}
  #endif
  			    },
+ 			    /* P_PRI_MKRC isn't needed here, optval_default()
+ 			     * always returns TRUE for 'compatible' */
      {"compatible",  "cp",   P_BOOL|P_RALL,
  			    (char_u *)&p_cp, PV_NONE,
  			    {(char_u *)TRUE, (char_u *)FALSE}},
***************
*** 1515,1521 ****
  			    {(char_u *)0L, (char_u *)0L}
  #endif
  			    },
!     {"keymap",	    "kmp",  P_STRING|P_ALLOCED|P_VI_DEF|P_RBUF|P_RSTAT|P_NFNAME,
  #ifdef FEAT_KEYMAP
  			    (char_u *)&p_keymap, PV_KMAP,
  			    {(char_u *)"", (char_u *)0L}
--- 1519,1525 ----
  			    {(char_u *)0L, (char_u *)0L}
  #endif
  			    },
!     {"keymap",	    "kmp",  P_STRING|P_ALLOCED|P_VI_DEF|P_RBUF|P_RSTAT|P_NFNAME|P_PRI_MKRC,
  #ifdef FEAT_KEYMAP
  			    (char_u *)&p_keymap, PV_KMAP,
  			    {(char_u *)"", (char_u *)0L}
***************
*** 1836,1842 ****
      {"paragraphs",  "para", P_STRING|P_VI_DEF,
  			    (char_u *)&p_para, PV_NONE,
  			    {(char_u *)"IPLPPPQPP LIpplpipbp", (char_u *)0L}},
!     {"paste",	    NULL,   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_paste, PV_NONE,
  			    {(char_u *)FALSE, (char_u *)0L}},
      {"pastetoggle", "pt",   P_STRING|P_VI_DEF,
--- 1840,1846 ----
      {"paragraphs",  "para", P_STRING|P_VI_DEF,
  			    (char_u *)&p_para, PV_NONE,
  			    {(char_u *)"IPLPPPQPP LIpplpipbp", (char_u *)0L}},
!     {"paste",	    NULL,   P_BOOL|P_VI_DEF|P_PRI_MKRC,
  			    (char_u *)&p_paste, PV_NONE,
  			    {(char_u *)FALSE, (char_u *)0L}},
      {"pastetoggle", "pt",   P_STRING|P_VI_DEF,
***************
*** 8535,8547 ****
      char_u		*varp_local = NULL;	/* fresh value */
      char		*cmd;
      int			round;
  
      /*
       * The options that don't have a default (terminal name, columns, lines)
       * are never written.  Terminal options are also not written.
       */
!     for (p = &options[0]; !istermoption(p); p++)
! 	if (!(p->flags & P_NO_MKRC) && !istermoption(p))
  	{
  	    /* skip global option when only doing locals */
  	    if (p->indir == PV_NONE && !(opt_flags & OPT_GLOBAL))
--- 8539,8558 ----
      char_u		*varp_local = NULL;	/* fresh value */
      char		*cmd;
      int			round;
+     int			pri;
  
      /*
       * The options that don't have a default (terminal name, columns, lines)
       * are never written.  Terminal options are also not written.
+      * Do the loop over "options[]" twice: once for options with the
+      * P_PRI_MKRC flag and once without.
       */
!     for (pri = 1; pri >= 0; --pri)
!     {
!       for (p = &options[0]; !istermoption(p); p++)
! 	if (!(p->flags & P_NO_MKRC)
! 		&& !istermoption(p)
! 		&& ((pri == 1) == ((p->flags & P_PRI_MKRC) != 0)))
  	{
  	    /* skip global option when only doing locals */
  	    if (p->indir == PV_NONE && !(opt_flags & OPT_GLOBAL))
***************
*** 8637,8642 ****
--- 8648,8654 ----
  		}
  	    }
  	}
+     }
      return OK;
  }
  
*** ../vim-7.1.098/src/version.c	Thu Sep  6 14:25:50 2007
--- src/version.c	Thu Sep  6 16:32:31 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     99,
  /**/

-- 
Not too long ago, a keyboard was something to make music with...

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim-dev@vim.org
Subject: patch 7.1.100
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 7.1.100
Problem:    Win32: Executing cscope doesn't always work properly.
Solution:   Use another way to invoke cscope. (Mike Williams)
Files:	    src/if_cscope.c, src/if_cscope.h, src/main.c,
	    src/proto/if_cscope.pro


*** ../vim-7.1.099/src/if_cscope.c	Tue Aug 21 18:02:58 2007
--- src/if_cscope.c	Sun Sep  2 16:50:50 2007
***************
*** 24,34 ****
      /* not UNIX, must be WIN32 */
  # include "vimio.h"
  # include <fcntl.h>
- # include <process.h>
- # define STDIN_FILENO    0
- # define STDOUT_FILENO   1
- # define STDERR_FILENO   2
- # define pipe(fds) _pipe(fds, 256, O_TEXT|O_NOINHERIT)
  #endif
  #include "if_cscope.h"
  
--- 24,29 ----
***************
*** 65,71 ****
  static char *	    cs_parse_results __ARGS((int cnumber, char *buf, int bufsize, char **context, char **linenumber, char **search));
  static char *	    cs_pathcomponents __ARGS((char *path));
  static void	    cs_print_tags_priv __ARGS((char **, char **, int));
! static int	    cs_read_prompt __ARGS((int ));
  static void	    cs_release_csp __ARGS((int, int freefnpp));
  static int	    cs_reset __ARGS((exarg_T *eap));
  static char *	    cs_resolve_file __ARGS((int, char *));
--- 60,66 ----
  static char *	    cs_parse_results __ARGS((int cnumber, char *buf, int bufsize, char **context, char **linenumber, char **search));
  static char *	    cs_pathcomponents __ARGS((char *path));
  static void	    cs_print_tags_priv __ARGS((char **, char **, int));
! static int	    cs_read_prompt __ARGS((int));
  static void	    cs_release_csp __ARGS((int, int freefnpp));
  static int	    cs_reset __ARGS((exarg_T *eap));
  static char *	    cs_resolve_file __ARGS((int, char *));
***************
*** 504,510 ****
  #if defined(UNIX)
      else if (S_ISREG(statbuf.st_mode) || S_ISLNK(statbuf.st_mode))
  #else
! 	/* substitute define S_ISREG from os_unix.h */
      else if (((statbuf.st_mode) & S_IFMT) == S_IFREG)
  #endif
      {
--- 499,505 ----
  #if defined(UNIX)
      else if (S_ISREG(statbuf.st_mode) || S_ISLNK(statbuf.st_mode))
  #else
! 	/* WIN32 - substitute define S_ISREG from os_unix.h */
      else if (((statbuf.st_mode) & S_IFMT) == S_IFREG)
  #endif
      {
***************
*** 717,733 ****
  cs_create_connection(i)
      int i;
  {
!     int to_cs[2], from_cs[2], len;
!     char *prog, *cmd, *ppath = NULL;
! #ifndef UNIX
!     int in_save, out_save, err_save;
!     long_i ph;
! # ifdef FEAT_GUI
!     HWND activewnd = NULL;
!     HWND consolewnd = NULL;
! # endif
  #endif
  
      /*
       * Cscope reads from to_cs[0] and writes to from_cs[1]; vi reads from
       * from_cs[0] and writes to to_cs[1].
--- 712,734 ----
  cs_create_connection(i)
      int i;
  {
! #ifdef UNIX
!     int		to_cs[2], from_cs[2];
! #endif
!     int		len;
!     char	*prog, *cmd, *ppath = NULL;
! #ifdef WIN32
!     int		fd;
!     SECURITY_ATTRIBUTES sa;
!     PROCESS_INFORMATION pi;
!     STARTUPINFO si;
!     BOOL	pipe_stdin = FALSE, pipe_stdout = FALSE;
!     HANDLE	stdin_rd, stdout_rd;
!     HANDLE	stdout_wr, stdin_wr;
!     BOOL	created;
  #endif
  
+ #if defined(UNIX)
      /*
       * Cscope reads from to_cs[0] and writes to from_cs[1]; vi reads from
       * from_cs[0] and writes to to_cs[1].
***************
*** 748,765 ****
  	return CSCOPE_FAILURE;
      }
  
- #if defined(UNIX)
      switch (csinfo[i].pid = fork())
      {
      case -1:
  	(void)EMSG(_("E622: Could not fork for cscope"));
  	goto err_closing;
      case 0:				/* child: run cscope. */
- #else
- 	in_save = dup(STDIN_FILENO);
- 	out_save = dup(STDOUT_FILENO);
- 	err_save = dup(STDERR_FILENO);
- #endif
  	if (dup2(to_cs[0], STDIN_FILENO) == -1)
  	    PERROR("cs_create_connection 1");
  	if (dup2(from_cs[1], STDOUT_FILENO) == -1)
--- 749,760 ----
***************
*** 768,782 ****
  	    PERROR("cs_create_connection 3");
  
  	/* close unused */
- #if defined(UNIX)
  	(void)close(to_cs[1]);
  	(void)close(from_cs[0]);
  #else
! 	/* On win32 we must close opposite ends because we are the parent */
! 	(void)close(to_cs[0]);
! 	to_cs[0] = -1;
! 	(void)close(from_cs[1]);
! 	from_cs[1] = -1;
  #endif
  	/* expand the cscope exec for env var's */
  	if ((prog = (char *)alloc(MAXPATHL + 1)) == NULL)
--- 763,794 ----
  	    PERROR("cs_create_connection 3");
  
  	/* close unused */
  	(void)close(to_cs[1]);
  	(void)close(from_cs[0]);
  #else
! 	/* WIN32 */
! 	/* Create pipes to communicate with cscope */
! 	sa.nLength = sizeof(SECURITY_ATTRIBUTES);
! 	sa.bInheritHandle = TRUE;
! 	sa.lpSecurityDescriptor = NULL;
! 
! 	if (!(pipe_stdin = CreatePipe(&stdin_rd, &stdin_wr, &sa, 0))
! 		|| !(pipe_stdout = CreatePipe(&stdout_rd, &stdout_wr, &sa, 0)))
! 	{
! 	    (void)EMSG(_("E566: Could not create cscope pipes"));
! err_closing:
! 	    if (pipe_stdin)
! 	    {
! 		CloseHandle(stdin_rd);
! 		CloseHandle(stdin_wr);
! 	    }
! 	    if (pipe_stdout)
! 	    {
! 		CloseHandle(stdout_rd);
! 		CloseHandle(stdout_wr);
! 	    }
! 	    return CSCOPE_FAILURE;
! 	}
  #endif
  	/* expand the cscope exec for env var's */
  	if ((prog = (char *)alloc(MAXPATHL + 1)) == NULL)
***************
*** 784,789 ****
--- 796,802 ----
  #ifdef UNIX
  	    return CSCOPE_FAILURE;
  #else
+ 	    /* WIN32 */
  	    goto err_closing;
  #endif
  	}
***************
*** 800,805 ****
--- 813,819 ----
  #ifdef UNIX
  		return CSCOPE_FAILURE;
  #else
+ 		/* WIN32 */
  		goto err_closing;
  #endif
  	    }
***************
*** 818,823 ****
--- 832,838 ----
  #ifdef UNIX
  	    return CSCOPE_FAILURE;
  #else
+ 	    /* WIN32 */
  	    goto err_closing;
  #endif
  	}
***************
*** 826,831 ****
--- 841,847 ----
  #if defined(UNIX)
  	(void)sprintf(cmd, "exec %s -dl -f %s", prog, csinfo[i].fname);
  #else
+ 	/* WIN32 */
  	(void)sprintf(cmd, "%s -dl -f %s", prog, csinfo[i].fname);
  #endif
  	if (csinfo[i].ppath != NULL)
***************
*** 851,910 ****
  	exit(127);
  	/* NOTREACHED */
      default:	/* parent. */
- #else
- # ifdef FEAT_GUI
- 	activewnd = GetForegroundWindow(); /* on win9x cscope steals focus */
- 	/* Dirty hack to hide annoying console window */
- 	if (AllocConsole())
- 	{
- 	    char *title;
- 	    title = (char *)alloc(1024);
- 	    if (title == NULL)
- 		FreeConsole();
- 	    else
- 	    {
- 		GetConsoleTitle(title, 1024); /* save for future restore */
- 		SetConsoleTitle(
- 		    "GVIMCS{5499421B-CBEF-45b0-85EF-38167FDEA5C5}GVIMCS");
- 		Sleep(40); /* as stated in MS KB we must wait 40 ms */
- 		consolewnd = FindWindow(NULL,
- 			"GVIMCS{5499421B-CBEF-45b0-85EF-38167FDEA5C5}GVIMCS");
- 		if (consolewnd != NULL)
- 		    ShowWindow(consolewnd, SW_HIDE);
- 		SetConsoleTitle(title);
- 		vim_free(title);
- 	    }
- 	}
- # endif
- 	/* May be use &shell, &shellquote etc */
- # ifdef __BORLANDC__
- 	/* BCC 5.5 uses a different function name for spawnlp */
- 	ph = (long_i)spawnlp(P_NOWAIT, prog, cmd, NULL);
- # else
- 	ph = (long_i)_spawnlp(_P_NOWAIT, prog, cmd, NULL);
- # endif
- 	vim_free(prog);
- 	vim_free(cmd);
- # ifdef FEAT_GUI
- 	/* Dirty hack part two */
- 	if (activewnd != NULL)
- 	    /* restoring focus */
- 	    SetForegroundWindow(activewnd);
- 	if (consolewnd != NULL)
- 	    FreeConsole();
- 
- # endif
- 	if (ph == -1)
- 	{
- 	    PERROR(_("cs_create_connection exec failed"));
- 	    (void)EMSG(_("E623: Could not spawn cscope process"));
- 	    goto err_closing;
- 	}
- 	/* else */
- 	csinfo[i].pid = 0;
- 	csinfo[i].hProc = (HANDLE)ph;
- 
- #endif /* !UNIX */
  	/*
  	 * Save the file descriptors for later duplication, and
  	 * reopen as streams.
--- 867,872 ----
***************
*** 914,935 ****
  	if ((csinfo[i].fr_fp = fdopen(from_cs[0], "r")) == NULL)
  	    PERROR(_("cs_create_connection: fdopen for fr_fp failed"));
  
- #if defined(UNIX)
  	/* close unused */
  	(void)close(to_cs[0]);
  	(void)close(from_cs[1]);
  
  	break;
      }
  #else
! 	/* restore stdhandles */
!     dup2(in_save, STDIN_FILENO);
!     dup2(out_save, STDOUT_FILENO);
!     dup2(err_save, STDERR_FILENO);
!     close(in_save);
!     close(out_save);
!     close(err_save);
! #endif
      return CSCOPE_SUCCESS;
  } /* cs_create_connection */
  
--- 876,927 ----
  	if ((csinfo[i].fr_fp = fdopen(from_cs[0], "r")) == NULL)
  	    PERROR(_("cs_create_connection: fdopen for fr_fp failed"));
  
  	/* close unused */
  	(void)close(to_cs[0]);
  	(void)close(from_cs[1]);
  
  	break;
      }
+ 
  #else
!     /* WIN32 */
!     /* Create a new process to run cscope and use pipes to talk with it */
!     GetStartupInfo(&si);
!     si.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;
!     si.wShowWindow = SW_HIDE;  /* Hide child application window */
!     si.hStdOutput = stdout_wr;
!     si.hStdError  = stdout_wr;
!     si.hStdInput  = stdin_rd;
!     created = CreateProcess(NULL, cmd, NULL, NULL, TRUE, CREATE_NEW_CONSOLE,
! 							NULL, NULL, &si, &pi);
!     vim_free(prog);
!     vim_free(cmd);
! 
!     if (!created)
!     {
! 	PERROR(_("cs_create_connection exec failed"));
! 	(void)EMSG(_("E623: Could not spawn cscope process"));
! 	goto err_closing;
!     }
!     /* else */
!     csinfo[i].pid = pi.dwProcessId;
!     csinfo[i].hProc = pi.hProcess;
!     CloseHandle(pi.hThread);
! 
!     /* TODO - tidy up after failure to create files on pipe handles. */
!     if (((fd = _open_osfhandle((intptr_t)stdin_wr, _O_TEXT|_O_APPEND)) < 0)
! 	    || ((csinfo[i].to_fp = _fdopen(fd, "w")) == NULL))
! 	PERROR(_("cs_create_connection: fdopen for to_fp failed"));
!     if (((fd = _open_osfhandle((intptr_t)stdout_rd, _O_TEXT|_O_RDONLY)) < 0)
! 	    || ((csinfo[i].fr_fp = _fdopen(fd, "r")) == NULL))
! 	PERROR(_("cs_create_connection: fdopen for fr_fp failed"));
! 
!     /* Close handles for file descriptors inherited by the cscope process */
!     CloseHandle(stdin_rd);
!     CloseHandle(stdout_wr);
! 
! #endif /* !UNIX */
! 
      return CSCOPE_SUCCESS;
  } /* cs_create_connection */
  
***************
*** 2097,2104 ****
  /*
   * PRIVATE: cs_release_csp
   *
!  * does the actual free'ing for the cs ptr with an optional flag of whether
!  * or not to free the filename.  called by cs_kill and cs_reset.
   */
      static void
  cs_release_csp(i, freefnpp)
--- 2089,2096 ----
  /*
   * PRIVATE: cs_release_csp
   *
!  * Does the actual free'ing for the cs ptr with an optional flag of whether
!  * or not to free the filename.  Called by cs_kill and cs_reset.
   */
      static void
  cs_release_csp(i, freefnpp)
***************
*** 2116,2125 ****
  	(void)fputs("q\n", csinfo[i].to_fp);
  	(void)fflush(csinfo[i].to_fp);
      }
!     /* give cscope chance to exit normally */
!     if (csinfo[i].hProc != NULL
! 	    && WaitForSingleObject(csinfo[i].hProc, 1000) == WAIT_TIMEOUT)
! 	TerminateProcess(csinfo[i].hProc, 0);
  #endif
  
      if (csinfo[i].fr_fp != NULL)
--- 2108,2120 ----
  	(void)fputs("q\n", csinfo[i].to_fp);
  	(void)fflush(csinfo[i].to_fp);
      }
!     if (csinfo[i].hProc != NULL)
!     {
! 	/* Give cscope a chance to exit normally */
! 	if (WaitForSingleObject(csinfo[i].hProc, 1000) == WAIT_TIMEOUT)
! 	    TerminateProcess(csinfo[i].hProc, 0);
! 	CloseHandle(csinfo[i].hProc);
!     }
  #endif
  
      if (csinfo[i].fr_fp != NULL)
***************
*** 2301,2306 ****
--- 2296,2316 ----
      wait_return(TRUE);
      return CSCOPE_SUCCESS;
  } /* cs_show */
+ 
+ 
+ /*
+  * PUBLIC: cs_end
+  *
+  * Only called when VIM exits to quit any cscope sessions.
+  */
+     void
+ cs_end()
+ {
+     int i;
+ 
+     for (i = 0; i < CSCOPE_MAX_CONNECTIONS; i++)
+ 	cs_release_csp(i, TRUE);
+ }
  
  #endif	/* FEAT_CSCOPE */
  
*** ../vim-7.1.099/src/if_cscope.h	Thu Jun 30 23:59:58 2005
--- src/if_cscope.h	Sun Sep  2 16:51:08 2007
***************
*** 72,78 ****
      ino_t	    st_ino;	/* inode number of cscope db */
  #else
  # if defined(WIN32)
!     int	    pid;	/* Can't get pid so set it to 0 ;) */
      HANDLE	    hProc;	/* cscope process handle */
      DWORD	    nVolume;	/* Volume serial number, instead of st_dev */
      DWORD	    nIndexHigh;	/* st_ino has no meaning in the Windows */
--- 72,78 ----
      ino_t	    st_ino;	/* inode number of cscope db */
  #else
  # if defined(WIN32)
!     DWORD	    pid;	/* PID of the connected cscope process. */
      HANDLE	    hProc;	/* cscope process handle */
      DWORD	    nVolume;	/* Volume serial number, instead of st_dev */
      DWORD	    nIndexHigh;	/* st_ino has no meaning in the Windows */
*** ../vim-7.1.099/src/main.c	Thu Aug 30 12:24:21 2007
--- src/main.c	Sun Sep  2 16:44:36 2007
***************
*** 1331,1336 ****
--- 1331,1339 ----
  #ifdef FEAT_NETBEANS_INTG
      netbeans_end();
  #endif
+ #ifdef FEAT_CSCOPE
+     cs_end();
+ #endif
  
      mch_exit(exitval);
  }
***************
*** 3671,3677 ****
  	mainerr_arg_missing((char_u *)filev[-1]);
      if (mch_dirname(cwd, MAXPATHL) != OK)
  	return NULL;
!     if ((p = vim_strsave_escaped_ext(cwd, PATH_ESC_CHARS, '\\', TRUE)) == NULL)
  	return NULL;
      ga_init2(&ga, 1, 100);
      ga_concat(&ga, (char_u *)"<C-\\><C-N>:cd ");
--- 3674,3686 ----
  	mainerr_arg_missing((char_u *)filev[-1]);
      if (mch_dirname(cwd, MAXPATHL) != OK)
  	return NULL;
!     if ((p = vim_strsave_escaped_ext(cwd,
! #ifdef BACKSLASH_IN_FILENAME
! 		    "",  /* rem_backslash() will tell what chars to escape */
! #else
! 		    PATH_ESC_CHARS,
! #endif
! 		    '\\', TRUE)) == NULL)
  	return NULL;
      ga_init2(&ga, 1, 100);
      ga_concat(&ga, (char_u *)"<C-\\><C-N>:cd ");
*** ../vim-7.1.099/src/proto/if_cscope.pro	Sat May  5 19:15:39 2007
--- src/proto/if_cscope.pro	Sun Sep  2 16:51:34 2007
***************
*** 6,9 ****
--- 6,10 ----
  void cs_free_tags __ARGS((void));
  void cs_print_tags __ARGS((void));
  int cs_connection __ARGS((int num, char_u *dbpath, char_u *ppath));
+ void cs_end __ARGS((void));
  /* vim: set ft=c : */
*** ../vim-7.1.099/src/version.c	Thu Sep  6 16:33:47 2007
--- src/version.c	Thu Sep  6 17:27:51 2007
***************
*** 668,669 ****
--- 668,671 ----
  {   /* Add new patch number below this line */
+ /**/
+     100,
  /**/

-- 
I have to exercise early in the morning before my brain
figures out what I'm doing.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\        download, build and distribute -- http://www.A-A-P.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
