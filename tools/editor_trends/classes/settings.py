#!/usr/bin/python
# -*- coding: utf-8 -*-
'''
Copyright (C) 2010 by Diederik van Liere (dvanliere@gmail.com)
This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License version 2
as published by the Free Software Foundation.
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details, at
http://www.fsf.org/licenses/gpl.html
'''

__author__ = '''\n'''.join(['Diederik van Liere (dvanliere@gmail.com)'])
__email__ = 'dvanliere at gmail dot com'
__date__ = '2010-10-21'
__version__ = '0.1'

from multiprocessing import cpu_count
import ConfigParser
import os
import sys
import platform
import subprocess

from classes import exceptions

try:
    from _winreg import HKEY_CURRENT_USER, KEY_READ, OpenKey, QueryValueEx
    from pywin import win32file
    '''increase the maximum number of open files on Windows to 1024'''
    win32file._setmaxstdio(1024)
except ImportError:
    pass

try:
    import resource
except ImportError:
    pass

class Settings:
    #__metaclass__ = singleton.Singleton

    def __init__(self):
        self.minimum_python_version = (2, 6)
        self.detect_python_version()

        self.platform = self.determine_platform()
        self.root = os.path.expanduser('~') \
            if self.platform != 'Windows' else 'c:\\'
        self.working_directory = self.determine_working_directory()

        result = self.load_configuration()
        if not result:
            self.input_location = os.path.join(self.root, 'wikimedia')
            self.base_location = os.path.join(self.root, 'wikimedia')

        #Date format as used by Erik Zachte
        self.date_format = '%Y-%m-%d'
        # Timestamp format as generated by the MediaWiki dumps
        self.timestamp_format = '%Y-%m-%dT%H:%M:%SZ'
        self.timestamp_server = '%a, %d %b %Y %H:%M:%S %Z'

        #67108864   # ==64Mb, see http://hadoop.apache.org/common/docs/r0.20.0/hdfs_design.html#Large+Data+Setsfor reason
        self.max_xmlfile_size = 4096 * 1024

        #Change this to match your computers configuration (RAM / CPU)
        # I want to get rid off these two variables.
        self.number_of_processes = cpu_count()
        #self.windows_register = {'7z.exe': 'Software\\7-Zip'}

        self.wp_dump_location = 'http://dumps.wikimedia.org'

        self.architecture = platform.machine()
        self.tab_width = 4 if self.platform == 'Windows' else 8

        self.update_python_path()

        self.max_filehandles = self.determine_max_filehandles_open()

        # This is the place where log files are stored for debugging purposes
        self.log_location = os.path.join(self.working_directory, 'logs')
        self.csv_location = os.path.join(self.working_directory, 'data', 'csv')
        self.dataset_location = os.path.join(self.working_directory, 'datasets')
        self.binary_location = os.path.join(self.working_directory, 'data', 'objects')
        self.storage = 'mongo'
        self.default_language = 'en'
        self.default_project = 'wiki'

    def detect_config(self):
        if not os.path.exists(os.path.join(self.working_directory, 'wiki.cfg')):
            raise exceptions.GenericMessage('not_configured')

    def load_configuration(self):
        config = ConfigParser.RawConfigParser()
        try:
            config.read(os.path.join(self.working_directory, 'wiki.cfg'))
            self.working_directory = config.get('file_locations', 'working_directory')
            self.input_location = config.get('file_locations', 'input_location')
            self.base_location = config.get('file_locations', 'base_location')
            self.default_project = config.get('wiki', 'project')
            self.default_language = config.get('wiki', 'language')
            self.storage = config.get('storage', 'db')
            self.master = config.get('cluster', 'master')
            self.slaves = config.get('cluster', 'slaves')
            return True
        except Exception, error:
            #raise exceptions.GenericMessage('corrupted_config')
            return False

    def determine_working_directory(self):
        cwd = os.getcwd()
        slashes = cwd.count(os.sep)
        paths = []
        paths.append(cwd)
        while slashes > 0 :
            pos = cwd.rfind(os.sep)
            cwd = cwd[:pos]
            if cwd != '':
                paths.append(cwd)
            slashes -= 1
        for cwd in paths:
            for root, dirs, files in os.walk(cwd, topdown=True):
                if os.path.exists(os.path.join(root, 'manage.py')):
                    return root
        raise exceptions.GenericMessage('corrupted_install')

    def detect_python_version(self):
        version = sys.version_info[0:2]
        if version < self.minimum_python_version:
            raise exceptions.OutDatedPythonVersionError

    def determine_platform(self):
        if platform.system() == 'Darwin':
            return 'OSX'
        else:
            return platform.system()

    def verify_environment(self, directories):
        for directory in directories:
            if not os.path.exists(directory):
                try:
                    error = False
                    os.makedirs(directory)
                except IOError, error:
                    pass
                except OSError, error:
                    pass
                finally:
                    if error:
                        print 'Configuration Error, could not create directory %s.'\
                            % directory
                        print 'The reason is: %s' % error
                        sys.exit(-1)

    def detect_windows_program(self, program):
        entry = self.windows_register.get(program, None)
        try:
            key = OpenKey(HKEY_CURRENT_USER, entry, 0, KEY_READ)
            return QueryValueEx(key, 'Path')[0]
        except WindowsError:
            return None

    def detect_linux_program(self, program):
        path = subprocess.Popen(['which', '%s' % program],
                                stdout=subprocess.PIPE).communicate()[0]
        return path.strip()

    def detect_installed_program(self, program):
        if self.platform == 'Windows':
            if not program.endswith('.exe'):
                program = program + '.exe'
                path = self.detect_windows_program(program)
            if path != None:
                path = path + program
        elif self.platform == 'Linux':
            path = self.detect_linux_program(program)
        return path

    def determine_max_filehandles_open(self):
        if self.platform == 'Windows' and self.architecture == 'i386':
            return win32file._getmaxstdio()
        elif self.platform != 'Windows':
            return resource.getrlimit(resource.RLIMIT_NOFILE)[0] - 100
        else:
            return 500

    def update_python_path(self):
        IGNORE_DIRS = ['wikistats', 'zips', 'datasets', 'mapreduce', 'logs',
                       'statistics', 'js_scripts', 'deployment',
                       'documentation', 'data', 'code-snippets']
        dirs = [name for name in os.listdir(self.working_directory) if
            os.path.isdir(os.path.join(self.working_directory, name))]
        for subdirname in dirs:
            if not subdirname.startswith('.') and subdirname not in IGNORE_DIRS:
                sys.path.append(os.path.join(self.working_directory,
                                            subdirname))
