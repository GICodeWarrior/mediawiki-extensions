<?php
/**
 * Support functions for evaluating datatypes that accept dates.
 * Support both XSD dates and seconds before/since 1970
 * See http://www.w3.org/TR/xmlschema-2/#dateTime
 * The implementation is dependent on PHP's strtotime(),
 * which in turn uses GNU get_date().
 *
 * @author skierpage
 */

/******* Datatype handler classes ********/

class SMWDateTimeTypeHandler implements SMWTypeHandler {


	/** @public */

	function getID() {
		return 'datetime';
	}

	function getXSDType() {
		return 'http://www.w3.org/2001/XMLSchema#dateTime';
	}

	function getUnits() { //no units for string
		//return array('STDUNIT'=>'ISO8601', 'ALLUNITS'=> array('ISO8601', 'seconds since 1970') ); //->this is not what we want -- mak
		return array('STDUNIT'=>false, 'ALLUNITS'=>array());
	}


    /**
	 * This method transforms the user-provided value of an
	 * attribute into several output strings (one for XML,
	 * one for printout, etc.) and reports parsing errors if
	 * the value is not valid for the given data type.
	 *
	 * @access public
	 */
	function processValue($v,&$datavalue) {
		// For a DateTime, "units" is really a format from an inline query
		// rather than the units of a float. 
		$desiredUnits = $datavalue->getDesiredUnits();
		$str_val = trim($v);

		$no_date_yet = true;
		$year_offset = 0;		
		// First we need to call in to float support to handle dates like
		// 7,600,000.03 mya "million years ago"
		// and bypass strtotime().
		// Also handle BC/BCE and AD/CE dates. Have to pick a cutoff date
		// where we don't bother with adding 1970 years to numeric value'
		// Or (?), do this as a separate class, as in Geologic time;
		// any reason to force "years ago" into a 1776-07-04 datetime class?

		// Then, *IF* we had PHP >= 5.2, we could date_create(), it works for 
		// all dates from 0000 to 9999 AD.

		// *OTHERWISE* since strtotime handles all kinds of dates, but only in a limited range.
		// If date doesn't seem to have month and day, just
		// subtract date from 1970 and multiply by seconds in year.
		// ? How do we tell such dates apart from 20061206 ?

		// If date has day and month part, one strategy is to 
		// move dates into the range 1920-2020 and then 
		// add (offset_years * secs_in_year) to $time.
		// We need to check for ISO 8601 dates outside the 32-bit supported
		// range (before 1912 and after 2038).
		if ($no_date_yet) {
			// Look for +/-, digits, and a -.
			if (preg_match('^[+-]?(\d{4})-', $str_val, $matches, PREG_OFFSET_CAPTURE) ) {
				$year = $matches[0][0];
				if ($year <= 1912 || $year > 2038) {
					$year_offset = $year - 1920;
					// Replace year in str_val with adjusted year.
				}
			}	
		}
			
		// Then we need to do simplistic parsing of dates outside this range like
		// "Boston Massacre on March 5, 1770" 
		// in both cases remember start and end pos.
		// If year out of range we need to offset it to years before or after 1920

		$time = strtotime($str_val);
		if ($time == -1 || $time === false) {
			$datavalue->setError('<span class="smwwarning">' . wfMsgForContent('smw_nodatetime',$v) . '</span>');
			return;
		}

		// strtotime accepts non-ISO8601 times like 02/01/70 and even "yesterday",
		// so reformat back to ISO8601. Unfortunately, ISO in
		// general is not compatible with XSD; but it should work
		// for the restricted interval we currently support.
		$date_part = strftime("%Y-%m-%d", $time);
		$str_val = $date_part . strftime("T%H:%M:%S", $time); // always show time in XSD
		$datavalue->setProcessedValues($v, $str_val, $time);

		// Determine the user-visible string.		
		if (count($desiredUnits) ==0) {
			// The default user-visible string shows date, plus 
			// time of day separated by space if it's significant.
			$user_val = $date_part;
			// See if there is a significant time component.
			// TODO: what about TimeZone?!
			if ( abs($time - strtotime($str_val)) > 0.5) {
				$user_val .= strftime(" %H:%M:%S", $time);
			}
			$datavalue->setPrintoutString($user_val);
		} else {
			// Print the date in all wanted formats (even if some of them would be equivalent -- we obey the user's wish)
			foreach ($desiredUnits as $wantedFormat) {
				$datavalue->setPrintoutString(strftime($wantedFormat, $time));
			}
		}

		//smwfNumberFormat($time) . ' seconds since 1970' ;
		// do not show the seconds since 1970; showing a date in multiple calendar systems could be a future output enhancement (Roman, Gregorian, whatever calendar), if the date is "historical" enough

		$datavalue->addQuicksearchLink();
		$datavalue->addServiceLinks($str_val); //possibly provide single values (year, month, ...) in the future
		return;
	}

	/**
	 * This method parses the value in the XSD form that was
	 * generated by parsing some user input. It is needed since
	 * the XSD form must be compatible to XML, and thus does not
	 * respect the internationalization settings. E.g. the German
	 * input value "1,234" is translated into XSD "1.234" which,
	 * if reparsed as a user input would be misinterpreted as 1234.
	 *
	 * @public
	 */
	function processXSDValue($value,$unit,&$datavalue) {
		//just insert the local decimal separator
		//(kilo separators do not occur in XSD)
		return $this->processValue(
		        str_replace('.',wfMsgForContent('smw_decseparator'),$value) . $unit, $datavalue);
	}

	/** @private */

	/**
	 * DateTime is stored as a number (seconds since 1970), but its XSD 
	 * format ISO8601 is not numeric.  Hmmm.
	 */
	function isNumeric() {
		return TRUE;
	}
} //SMWDateTimeTypeHandler

//register type handler:
//SMWTypeHandlerFactory::registerTypeHandler($smwgContLang->getDatatypeLabel('smw_datetime'),
//                       new SMWDateTimeTypeHandler());

?>
