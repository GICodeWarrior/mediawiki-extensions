= JS2 Support Extension =

The JS2 Support extension includes a ScriptLoader, mwEmbed javascript library
and a repository for shared javascript like jquery.ui components. 

The js2-work branch has been depreciated.

== mwEmbed Stand Alone ==
mwEmbed also works stand alone but does not work stand alone from a js2 support checkout. 
You can learn more about mwEmbed stand alone in 
/branches/mwEmbedStandAlone/README  
and or
http://www.kaltura.org/project/html5-kaltura-library

This extension solely supports other extensions, and hence would be a good candidate for 
inclusion into core. Its built as an extension to enable development to move forward while
the core integration is sorted out.


== Developing with JS2 ==

To add the base js2 library support simply add the following to your LocalSettings.php: 
require_once( "$IP/extensions/JS2Support/JS2Support.php" );

By default js2 support groups script and css requests. To disable script grouping in your localSettings.php set:  
$wgEnableScriptLoader = false; 

If you want a fresh copy of all the scripts ( and to disable minification in when wgEnableScriptLoader= true you can set )  
$wgDebugJavaScript = true;

== LocalSettings.php to enable all js2 extensions == 

# Base JS2 Support ( includes mwEmbed )
require_once( "$IP/extensions/JS2Support/JS2Support.php"  );

# Add Media Wizard
require_once( "$IP/extensions/AddMediaWizard/AddMediaWizard.php" ); 

# Upload Wizard
require_once( "$IP/extensions/UploadWizard/UploadWizard.php" );

# TimedMediaHandler, update to Ogg Handler with html5 player, multi-format transcoding & subtitle support. 
require_once( "$IP/extensions/TimedMediaHandler/TimedMediaHandler.php" );


== Using JS2 script-grouping with your extension ==

Once you include the extension you can use the following: 

To add a javascript or css to the named paths ( so that the script loader can load it by name )
$wgScriptLoaderNamedPaths[ 'myExtension' ] = 'extensions/myExtension/myExtension.js';

Then in your php you can include your with the following line:   
$wgOut->addScriptClass( 'myExtension' /* scriptloader named path */ , 'page'/* group bucket id */ );
This lets you use the named-path for includes and gives you control over script grouping with the 
grouping argument. If for example your script is included on a set of special pages then you could
create a bucket id string for that set to not mangle the cache of each special page .

If important that user-specific js like user-selected gadgets or user-custom pages are put into the 
user bucket. This is so in the future cookie based request can be issued for javascript browsers enabling
us to send the same "cached" page to all logging users that share a base configuration.
 
If you would like to keep compatibility with non-js2 extension support you can use the base outputPage 
addScriptFile method:
$wgOut->addScriptFile( 'extensions/myExtension/myExtension.js' )
This way regardless of if your running the js2support extension or not script-includes will continue to work.
But you won't be able to control the script bucket, and the script-loader will have to guess 
what group to put it in. ( This should be resolved with updates to the trunk output page) 

For more info see  ScriptLoaderOutputPage.php $mScriptLoaderClassList


== Using JS2 with JS-modules ==

JS Modules are reusable sets of javascript that can be dynamically configured, loaded and executed in 
arbitrary application contexts. Javascript modules promote a clean separation of configuration,
interface, and application flow. These modules define relative paths for assets and can be hosted 
inside extensions or optionally used in stand-alone javascript interfaces. 

The use of "loaders" enables dynamic packaging of modules with the intent of avoiding multiple requests, 
for dynamically loaded interfaces.    

To add a javascript Module to your extension you must supply the relative path to the module in your main 
extension .php file: 

$wgExtensionJavascriptModules[ 'myJsModule' ] =  'extensions/myExtension/MyJsModule';

Your MyJsModule folder should contain: 
loader.js ( "module loader" ) 
{moduleName}.i18n.php ( "mediaWiki localization format localization file" )
{libraryCode.js files} ( "library code" ) 

== JS Module Components == 

The three components of a js-module are  "module loaders", "module activators" and "library code and assets". 

* "module loaders"  define named paths and build the request set of the javascript and css assets 
for a given interface "module". The set of requested libraries can driven by site configuration, 
and user preferences. The requested set of modules can include core libraries like jquery.ui helpers.   

* "module activators" Call the module loaders in a given application context and then 
invoke the interface or application.  

* "library code and assets" These consist of library code and assets that is the user interface or application. 
These libraries are driven by a given configuration.    

== Example Flow and File Contents == 

When an application wants to use a interface component it calls the module loader from its activator.
The module loader checks relevant configuration, it then issues a single script-loader
request that checks javascript application state for existing satisfied dependencies or native browser support
it then retrieves all the needed javascript, css and localized message text for that interface. 
The returned javascript will be minfied and gziped and cached on the server. 
The activator gets a callback that the interface library is loaded, and can then use that interface.

=== Example Loader loader.js:  ===

Loaders should define named class paths, named "module loader" functions and default configuration 
if appropriate. Style sheet assets should be named mw.style[ {styleName} ] this is so we can 
register the presence of style sheets in javascript and libraries can dynamically
share style sheet components.

/* 
* First we define the named script class paths
* Each class  "mw.myJsModuleUI" defines its class name in the javascript
* Note these named paths should be in "JSON" not javascript 
* The scriptLoader will parse these named paths.
* 
* By putting these in javascript instead of php we can develop the library 
* in "raw" file mode ( by setting wgEnableScriptLoader = false )  
*/
mw.addClassFilePaths( {
	"mw.myJsModuleHandler" : "js/mw.myJSModuleHandler.js", 
	"mw.myJsModuleUI" : "js/mw.myJSModuleUI.js"
	"mw.style.myJsModule" : "css/mw.style.myJsModule.css"		
});

/* 
* Then we setup the module loader that builds a loader request for the given module 
*/
mw.addModuleLoader( 'myJsModule', function( callback ){
	// Set the intial request set: 
	var requestSet = ["mw.myJsModuleHandler", "mw.myJsModuleUI", "mw.style.myJsModule", "$j.ui", "$j.ui.tabs" ];
	
	// Check configuration and add to request set 
	if( mw.getConfig( 'myJsModuleFeatureOrSubModuleEnabled' ){
		// add the given feature or submodule to the requestSet
	}
	
	// If we want to enable other  "extensions" or "modules" to "addHooks" to our module loader we do that here
	$j( mw ).trigger( 'LoaderMyJsModuleAddFeatures', requestSet ); 
	
	// Load the request set and run the ModuleLoader callback. 
	mw.load( requestSet, callback ); 
	
});

=== Example "Activator" MyModulePage.js === 
/* 
* MyModulePage.js is included on pages that we want via normal php extension hooks.
* Once we want to use the module we simply call the module loader
*/ 
var myModuleConfig = {
	'configOption1' : mw.getConfig( 'myJsModule.configOption1' )
}
mw.load( 'myJsModule', function(){
	var myModule = new mw.myJsModule( myModuleConfig );
	myModule.drawUI();
	
	// if your interface operates on a DOM element like a jQuery plugin you may 
	// invoke it differently ie: 
	$j('#targetElement').myJsModule( myModuleConfig );	 
}

=== Example Library Code ===

The key thing to remember about library code is that it defines a named class ie: 
a file by name 'mw.Foo.js'  would define a object named 'mw.Foo' ie something like:
  
mw.Foo = function( options ){
	this.init( options ); 
}

mw.Foo.prototype = { 
	'init' : function(){ /* constructor */ }
	'drawUI' : function(){ ... }  
} 

Library code should operate off of global configuration mw.getConfig( 'configurationOption' ) 
and or local configuration ( where appropriate ) ie the constructor gets passed an options object 
that defines named value pairs of configuration or callbacks. 

The other key thing to remember about library code is to handle localization in some way. 
The localization options are presented bellow

== Localization ==

Each javascript module hosts a {moduleName}.i18n.php file that works with the 
existing mediaWiki translate system. Note when the script-loader populates
the msg replacements it uses mediaWiki's wfGetMsg function so any database
MediaWiki namespace strings ''will be'' included in your javascript messages. 

You have three options for packaging messages in your javascript module

1) If your javascript module is simple and your interface is mostly set in a single
file you may want to load all your msgs at once.  You can get all the msgs in your javascript
module's localization file by simply running: 
mw.includeAllModuleMessages(); 

Putting this function call at the top of your primary library code javascript file will be 
replaced with all the msgs in your modules php localization file in the current language. 
NOTE you won't be able to pull in msgKeys that are hosted outside of your extension ( to do that 
you must list the keys you want at the top of the javascript file with localization option 2 )

2 ) If your code includes many sub-modules and you may want fine grain control over what msgs 
are packaged when. You can define the set of msg keys it at the top of any javascript file.

For example: 
mw.addMessageKeys( ['list', 'of', 'msg-keys' ] );

Will be replaced by the script-loader with the localized msgs for every listed key. 
  
3) If you are doing a lot of stand alone testing it can be faster to use a json array
at the top of your javascript file.   
mw.addMesseges( { "msg-key" : "English fallback" } );

  Your javascript file then becomes your developer reference English messages. A maintenance scripts then
copy your English fallbacks into the php localization file for the translate wiki scripts to work with.  
Running the JS2Support maintenance script "mergeJavascriptMsgs.php" will sync javascript into phpt files. 

This is the most complicated setup, if your unsure use the first option and call: 
mw.includeAllModuleMsgs(); 
In your primary library code javascript. 
  
=== Accessing Msgs in Javascript ===

The JS2 Localization system works similar to its php counterpart. It includes
support for {{PLURAL}} transforms. 

To get a message simply issue the call: 
gM( 'msg-key', 'replacement1', 'replacement2', 'etc' );

Note you can pass jQuery replacements in the case of links ie: 
gM( 'msg-key', $j('<a />').text( gM( 'link-text' ) );

For full documentation see: mwEmbed/languages/mw.Language.js function: mw.getMsg

  


