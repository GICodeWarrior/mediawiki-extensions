#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <antlr3.h>
#include <mwParser.h>
#include <mwLexer.h>
#include <tracingcontext.h>
#include <sys/time.h>

int main(int argc, char *const* argv)
{
    if (argc != 2) {
        fprintf(stderr, "Usage: %s <test input>\n", argv[0]);
        return 1;
    }

    struct timeval start;
    gettimeofday(&start, NULL);

    int i;
    for (i = 0; i < 1; i++) {

    // Now we declare the ANTLR related local variables we need.
    // Note that unless you are convinced you will never need thread safe
    // versions for your project, then you should always create such things
    // as instance variables for each invocation.
    // -------------------
 
    // Name of the input file. Note that we always use the abstract type pANTLR3_UINT8
    // for ASCII/8 bit strings - the runtime library guarantees that this will be
    // good on all platforms. This is a general rule - always use the ANTLR3 supplied
    // typedefs for pointers/types/etc.
    //
    pANTLR3_UINT8      fName = argv[1];
 
    // The ANTLR3 character input stream, which abstracts the input source such that
    // it is easy to privide inpput from different sources such as files, or 
    // memory strings.
    //
    // For an ASCII/latin-1 memory string use:
    //     input = antlr3NewAsciiStringInPlaceStream (stringtouse, (ANTLR3_UINT32) length, NULL);
    //
    // For a UCS2 (16 bit) memory string use:
    //     input = antlr3NewUCS2StringInPlaceStream (stringtouse, (ANTLR3_UINT32) length, NULL);
    //
    // For input from a file, see code below
    //
    // Note that this is essentially a pointer to a structure containing pointers to functions.
    // You can create your own input stream type (copy one of the existing ones) and override any
    // individual function by installing your own pointer after you have created the standard 
    // version.
    //
    pANTLR3_INPUT_STREAM       input;
 
    // The lexer is of course generated by ANTLR, and so the lexer type is not upper case.
    // The lexer is supplied with a pANTLR3_INPUT_STREAM from whence it consumes its
    // input and generates a token stream as output. This is the ctx (CTX macro) pointer
    // for your lexer.
    //
    pmwLexer             lxr;
 
    // The token stream is produced by the ANTLR3 generated lexer. Again it is a structure based
    // API/Object, which you can customise and override methods of as you wish. a Token stream is
    // supplied to the generated parser, and you can write your own token stream and pass this in
    // if you wish.
    //
    pANTLR3_COMMON_TOKEN_STREAM        tstream;
 
    // The Lang parser is also generated by ANTLR and accepts a token stream as explained
    // above. The token stream can be any source in fact, so long as it implements the 
    // ANTLR3_TOKEN_SOURCE interface. In this case the parser does not return anything
    // but it can of course specify any kind of return type from the rule you invoke
    // when calling it. This is the ctx (CTX macro) pointer for your parser.
    //
    pmwParser                psr;
 
    // The tree nodes are managed by a tree adaptor, which doles
    // out the nodes upon request. You can make your own tree types and adaptors
    // and override the built in versions. See runtime source for details and
    // eventually the wiki entry for the C target.
    //
    pANTLR3_COMMON_TREE_NODE_STREAM    nodes;
 
    // Create the input stream using the supplied file name
    // (Use antlr3AsciiFileStreamNew for UCS2/16bit input).
    //
    input  = antlr3FileStreamNew(fName, ANTLR3_ENC_UTF8);
 
    // The input will be created successfully, providing that there is enough
    // memory and the file exists etc
    //
    if ( input == NULL ) {
        ANTLR3_FPRINTF(stderr, "Unable to open file %s due to malloc() failure1\n", (char *)fName);
    }
    // Our input stream is now open and all set to go, so we can create a new instance of our
    // lexer and set the lexer input to our input stream:
    //  (file | memory | ?) --> inputstream -> lexer --> tokenstream --> parser ( --> treeparser )?
    //
    lxr        = mwLexerNew(input);      // CLexerNew is generated by ANTLR
 
    // Need to check for errors
    //
    if ( lxr == NULL ) {
        ANTLR3_FPRINTF(stderr, "Unable to create the lexer due to malloc() failure1\n");
        exit(ANTLR3_ERR_NOMEM);
    }
 
    // Our lexer is in place, so we can create the token stream from it
    // NB: Nothing happens yet other than the file has been read. We are just 
    // connecting all these things together and they will be invoked when we
    // call the parser rule. ANTLR3_SIZE_HINT can be left at the default usually
    // unless you have a very large token stream/input. Each generated lexer
    // provides a token source interface, which is the second argument to the
    // token stream creator.
    // Note tha even if you implement your own token structure, it will always
    // contain a standard common token within it and this is the pointer that
    // you pass around to everything else. A common token as a pointer within
    // it that should point to your own outer token structure.
    //
    tstream = antlr3CommonTokenStreamSourceNew(ANTLR3_SIZE_HINT, TOKENSOURCE(lxr));
 
    if (tstream == NULL) {
        ANTLR3_FPRINTF(stderr, "Out of memory trying to allocate token stream\n");
        exit(ANTLR3_ERR_NOMEM);
    }
 
    // Finally, now that we have our lexer constructed, we can create the parser
    //
    psr        = mwParserNew(tstream);  // CParserNew is generated by ANTLR3
 
    if (psr == NULL) {
        ANTLR3_FPRINTF(stderr, "Out of memory trying to allocate parser\n");
        exit(ANTLR3_ERR_NOMEM);
    }

    // Tracing context for mediawiki parser
    MWPARSERCONTEXT *mwParserContext = MWTracingContextNew(psr->pParser);
    if (mwParserContext == NULL) {
        ANTLR3_FPRINTF(stderr, "Out of memory when allocating mediawiki parser context.\n");
        exit(ANTLR3_ERR_NOMEM);
    }

    MWLEXERCONTEXT *mwLexerContext = MWLexerContextNew(lxr->pLexer);
    if (mwLexerContext == NULL) {
        ANTLR3_FPRINTF(stderr, "Out of memory when allocating mediawiki lexer context.\n");
        exit(ANTLR3_ERR_NOMEM);
    }

    psr->article(psr);

    mwLexerContext->free(mwLexerContext);
    mwParserContext->free(mwParserContext);
 
    // We did not return anything from this parser rule, so we can finish. It only remains
    // to close down our open objects, in the reverse order we created them
    //
    psr     ->free  (psr);      psr     = NULL;
    tstream ->free  (tstream);  tstream = NULL;
    lxr     ->free  (lxr);      lxr     = NULL;
    input   ->close (input);    input   = NULL;


    }
    struct timeval stop;
    gettimeofday(&stop, NULL);

    int diff_s = stop.tv_sec - start.tv_sec;
    int diff_us = stop.tv_usec - start.tv_usec;

    diff_us += diff_s * 1000000;
    //            fprintf(stderr, "Time: %d micro seconds\n", diff_us);

    return 0;
}
